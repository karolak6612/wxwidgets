<?xml version="1.0" ?>
<PALETTE-BrushList>
  <id>PALETTE-BrushList</id>
  <section>UI Elements</section>
  <title>Implement Brush List Palette</title>
  <original_input_files>
    <original_input_file>wxwidgets/palette_brushlist.h</original_input_file>
    <original_input_file>wxwidgets/palette_brushlist.cpp</original_input_file>
    <original_input_file>wxwidgets/palette_window.h</original_input_file>
    <original_input_file>wxwidgets/palette_window.cpp</original_input_file>
  </original_input_files>
  <analyzed_input_files>
    <analyzed_input_file>
      <file_path>wxwidgets/palette_brushlist.h</file_path>
      <description>Declares `BrushListBox` (a `wxVListBox` implementation of `BrushBoxInterface`)
and `BrushPanel` which can host different brush views.
This suggests a UI component that can list various brushes, perhaps all loaded ones,
potentially with icons and names, allowing the user to select one to make it active.
</description>
    </analyzed_input_file>
    <analyzed_input_file>
      <file_path>wxwidgets/palette_window.h</file_path>
      <description>Declares `PaletteWindow` which uses a `wxChoicebook` to switch between different
palette categories. A &quot;Brush List&quot; could be one such category or a view mode
within other palettes.
</description>
    </analyzed_input_file>
  </analyzed_input_files>
  <dependencies>
    <dependencie>UI-02</dependencie>
    <dependencie>CORE-BRUSH-FRAMEWORK</dependencie>
    <dependencie>REFACTOR-01</dependencie>
    <dependencie>LOGIC-01</dependencie>
  </dependencies>
  <current_functionality_summary>The legacy system has components like `BrushListBox` and `BrushPanel` within the
overall palette framework (`PaletteWindow`) that can display lists of brushes.
This task is to create a dedicated palette tab or view that lists all (or a filtered set of)
available brushes, allowing users to select one to activate it. This might be a master list
or a specific type of brush presentation not covered by other specialized palettes.
</current_functionality_summary>
  <qt6_migration_steps>1. Create `BrushListPaletteTab.h/.cpp` inheriting `QWidget`.
2. Design UI:
   - A `QListView` or `QTreeView` to display brush names, possibly with icons.
   - Optional: Filters (e.g., by brush type/group if brushes have such metadata).
3. Populate the view:
   - Get all registered brushes from `BrushManagerService` (from `CORE-BRUSH-FRAMEWORK`).
   - Create model items for each brush (name, icon).
4. Handle selection:
   - When a brush is selected in the view, notify `BrushStateService` (from `REFACTOR-01`)
     or `EditorController` to set it as the active brush.
5. Integrate this tab into the main palette system (`QTabWidget` in `UI-02`).
</qt6_migration_steps>
  <definition_of_done>- A `BrushListPaletteTab` widget is implemented and added to the main palette system.
- The palette lists available brushes from `BrushManagerService`.
- Users can select a brush from this list to make it the active drawing brush.
- Filtering or categorization of brushes is implemented if deemed necessary.
</definition_of_done>
  <boilerplate_coder_ai_prompt>Implement a `BrushListPaletteTab` Qt widget.

1.  **`BrushListPaletteTab.h`:**
    ```cpp
    #include &lt;QWidget&gt;
    class QListView;
    class QStringListModel; // Or a custom model
    class BrushManagerService; // From CORE-BRUSH-FRAMEWORK
    class BrushStateService;   // From REFACTOR-01

    class BrushListPaletteTab : public QWidget {
        Q_OBJECT
    public:
        BrushListPaletteTab(BrushManagerService* brushManager, BrushStateService* brushStateService, QWidget* parent = nullptr);
        void refreshBrushList();
    private slots:
        void onBrushSelectionChanged(const QModelIndex&amp; current, const QModelIndex&amp; previous);
    private:
        QListView* m_brushListView;
        QStringListModel* m_brushModel; // Or custom model storing Brush* or names
        BrushManagerService* m_brushManager;
        BrushStateService* m_brushStateService;
    };
    ```
2.  **`BrushListPaletteTab.cpp`:**
    - Constructor: Setup UI (ListView), store managers. Call `refreshBrushList()`. Connect `m_brushListView-&gt;selectionModel()-&gt;currentChanged` to `onBrushSelectionChanged`.
    - `refreshBrushList()`: Clear model. Get all brushes from `m_brushManager`. Populate `m_brushModel` (e.g., with brush names; store actual `Brush*` or unique name in `Qt::UserRole`).
    - `onBrushSelectionChanged()`: Get selected brush identifier (name or pointer). Call `m_brushStateService-&gt;setActiveBrushByName(brushName);` or `m_brushStateService-&gt;setActiveBrush(brushPtr);`.
Integrate this tab into the main palette `QTabWidget` (from `UI-02`).
</boilerplate_coder_ai_prompt>
  <documentation_references>
    <documentation_reference>QListView</documentation_reference>
    <documentation_reference>QStringListModel</documentation_reference>
    <documentation_reference>QAbstractItemModel</documentation_reference>
    <documentation_reference>UI-02</documentation_reference>
    <documentation_reference>CORE-BRUSH-FRAMEWORK</documentation_reference>
    <documentation_reference>REFACTOR-01</documentation_reference>
  </documentation_references>
  <estimation_effort>Medium</estimation_effort>
</PALETTE-BrushList>
