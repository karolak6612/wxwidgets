#include <QtTest/QtTest>
#include "core/Position.h" // Class to test
#include "core/map_constants.h" // For validation constants

// Make sure RME namespace is accessible
using namespace RME;

class TestPosition : public QObject
{
    Q_OBJECT

private slots:
    void testDefaultConstructor();
    void testValueConstructor();
    void testEqualityOperators();
    void testLessThanOperator();
    void testAdditionSubtraction();
    void testIsValid();
    void testTranslated();
    void testStdHash();
};

void TestPosition::testDefaultConstructor()
{
    Position p;
    QCOMPARE(p.x, 0);
    QCOMPARE(p.y, 0);
    QCOMPARE(p.z, 0);
}

void TestPosition::testValueConstructor()
{
    Position p(10, 20, 5);
    QCOMPARE(p.x, 10);
    QCOMPARE(p.y, 20);
    QCOMPARE(p.z, 5);
}

void TestPosition::testEqualityOperators()
{
    Position p1(1, 2, 3);
    Position p2(1, 2, 3);
    Position p3(4, 5, 6);
    Position p4(1, 2, 7);

    QVERIFY(p1 == p2);
    QVERIFY(p1 != p3);
    QVERIFY(p2 != p4);
    QVERIFY(!(p1 != p2));
    QVERIFY(!(p1 == p3));
}

void TestPosition::testLessThanOperator()
{
    // Order: z, then y, then x
    QVERIFY(Position(1, 1, 0) < Position(1, 1, 1)); // z smaller
    QVERIFY(Position(1, 0, 1) < Position(1, 1, 1)); // y smaller
    QVERIFY(Position(0, 1, 1) < Position(1, 1, 1)); // x smaller

    QVERIFY(!(Position(1,1,1) < Position(1,1,1))); // equal
    QVERIFY(!(Position(1,1,2) < Position(1,1,1))); // z greater
}

void TestPosition::testAdditionSubtraction()
{
    Position p1(10, 20, 5);
    Position p2(1, 2, 3);

    Position sum = p1 + p2;
    QCOMPARE(sum, Position(11, 22, 8));

    Position diff = p1 - p2;
    QCOMPARE(diff, Position(9, 18, 2));

    p1 += p2;
    QCOMPARE(p1, Position(11, 22, 8));

    p1 -= p2; // p1 is now (11,22,8), p2 is (1,2,3)
    QCOMPARE(p1, Position(10, 20, 5));
}

void TestPosition::testIsValid()
{
    QVERIFY(Position(0, 0, 0).isValid());
    QVERIFY(Position(MAP_MAX_WIDTH - 1, MAP_MAX_HEIGHT - 1, MAP_MAX_FLOOR).isValid());

    QVERIFY(!Position(-1, 0, 0).isValid());
    QVERIFY(!Position(0, -1, 0).isValid());
    QVERIFY(!Position(0, 0, -1).isValid()); // Assuming MAP_MIN_FLOOR is 0
    QVERIFY(!Position(0, 0, MAP_MAX_FLOORS).isValid()); // z is too high
    QVERIFY(!Position(MAP_MAX_WIDTH, 0, 0).isValid()); // x is too high
    QVERIFY(!Position(0, MAP_MAX_HEIGHT, 0).isValid());// y is too high
}

void TestPosition::testTranslated()
{
    Position p(10, 20, 5);
    QCOMPARE(p.translated(1, 1, 1), Position(11, 21, 6));
    QCOMPARE(p.translated(-1, -1, -1), Position(9, 19, 4));
    QCOMPARE(p.translated(0, 0, 1), Position(10, 20, 6)); // Change only z
}

void TestPosition::testStdHash()
{
    std::hash<Position> hasher;
    Position p1(10, 20, 5);
    Position p2(10, 20, 5);
    Position p3(1, 2, 3);

    QCOMPARE(hasher(p1), hasher(p2));
    QVERIFY(hasher(p1) != hasher(p3)); // Highly probable, not guaranteed for bad hash
}

QTEST_MAIN(TestPosition)
#include "TestPosition.moc" // Generated by MOC
