wbs_item_id: CORE-03
name: Port Action & History System
description: Migrate the action recording and history (undo/redo) mechanisms from
  `mapcore` (likely within `action.cpp`/`.h`) to a robust Qt6/C++ implementation.
  This should support various editor operations and provide a reliable undo/redo stack.
dependencies:
- CORE-02
input_files:
- wxwidgets/action.cpp
- wxwidgets/action.h
analyzed_input_files:
- file_path: wxwidgets/action.cpp
  description: Implementation of Action, Change, BatchAction, and ActionQueue classes
    for managing undo/redo history and specific editor operations.
- file_path: wxwidgets/action.h
  description: Header file for the action and history system, defining interfaces
    for Action, Change, BatchAction, and ActionQueue.
documentation_references:
- 'Qt Command Pattern: https://doc.qt.io/qt-6/qtwidgets-mainwindows-application-example.html#command-pattern'
- 'QUndoStack: https://doc.qt.io/qt-6/qundostack.html'
- 'QUndoCommand: https://doc.qt.io/qt-6/qundocommand.html'
- 'std::unique_ptr: https://en.cppreference.com/w/cpp/memory/unique_ptr'
current_functionality_summary: 'The wxWidgets-based action system consists of:

  - `Change`: Encapsulates data for a modification (e.g., a copy of a `Tile` before
  changes).

  - `Action`: Represents an operation that can be undone/redone. It holds a list of
  `Change` objects. Key methods are `commit()` (apply changes) and `undo()`.

  - `BatchAction`: Groups multiple related `Action` instances, often of the same type,
  if they occur close in time (stacking delay). It manages a list of sub-actions.

  - `ActionQueue`: Manages a list of `BatchAction` objects, providing `undo()` and
  `redo()` capabilities. It also handles memory limits for the undo stack.'
definition_of_done:
- 'A Qt6/C++ Command pattern is implemented, including:'
- '  - An abstract `Action` (or `Command`) base class with virtual `execute()`, `undo()`,
  and potentially `redo()` methods.'
- '  - A mechanism equivalent to the `Change` class to encapsulate the actual data/state
  modification for undo/redo purposes.'
- '  - An `ActionQueue` (or `UndoStack`) class capable of managing a list of `Action`
  objects.'
- 'The `ActionQueue` supports:'
- '  - Adding new actions to the stack.'
- '  - Performing undo operations, which revert the last executed action.'
- '  - Performing redo operations, which re-apply the last undone action.'
- '  - Clearing actions that are undone when a new action is added.'
- '  - Limits on undo stack size (memory or count) as per original settings (e.g.,
  `UNDO_MEM_SIZE`, `UNDO_SIZE`).'
- '`Action` objects correctly store the necessary context or `Change` objects to perform
  and revert their specific operations.'
- Memory management for `Action` objects and their associated `Change` data is handled
  using modern C++ practices (e.g., smart pointers).
- The system is designed to be extensible for various editor operations (drawing,
  deleting, pasting, etc.) by creating new classes derived from the `Action` base
  class.
- 'Basic unit tests are created for the `ActionQueue` to verify:'
- '  - Adding actions.'
- '  - Correct execution of undo and redo.'
- '  - Stack limits and clearing behavior.'
- Unit tests for a sample concrete `Action` implementation to verify its execute/undo
  logic and interaction with `Change` objects.
- The ported code compiles successfully within a Qt6 project structure.
- A brief report detailing the mapping from the old action system to the new Command
  pattern, highlighting design choices.
boilerplate_coder_ai_prompt: "The user wants to migrate an action and history (undo/redo)\
  \ system from an old C++/wxWidgets application to Qt6/modern C++.\nAnalyze the provided\
  \ C++ header and source file snippets for `Action`, `Change`, `BatchAction`, and\
  \ `ActionQueue` (from `wxwidgets/action.cpp` and `wxwidgets/action.h`).\n\n**1.\
  \ Change Object Equivalent:**\n   - Design a class or struct (e.g., `ChangeData`\
  \ or use `QVariant` / `std::any` for flexibility) to encapsulate the information\
  \ needed to undo/redo a specific modification. The original `Change` class stores\
  \ a `type` and `void* data` (pointing to old `Tile*`, `std::pair` for moves, etc.).\
  \ The new system should be more type-safe.\n   - For example, a `TileChangeData`\
  \ might store a copy of the `Tile` before modification, or pointers/references to\
  \ the old and new states.\n\n**2. Action (Command) Class:**\n   - Create an abstract\
  \ base class `Action` (or `Command`) with pure virtual methods:\n     - `virtual\
  \ void execute() = 0;`\n     - `virtual void undo() = 0;`\n     - (Optional: a `redo()`\
  \ method, which might simply call `execute()`, if redo is always a re-execution).\n\
  \   - Concrete action classes (e.g., `DrawTileAction`, `MoveItemAction`) will derive\
  \ from this and implement these methods.\n   - Each concrete action will be responsible\
  \ for creating and storing the necessary `ChangeData` objects during its `execute()`\
  \ method to allow `undo()` to function.\n   - The constructor for a concrete action\
  \ should take all necessary parameters to perform the operation (e.g., target position,\
  \ item data).\n\n**3. ActionQueue (UndoStack) Class:**\n   - Implement an `ActionQueue`\
  \ class to manage the undo/redo history.\n   - It should use a container (e.g.,\
  \ `QList<std::unique_ptr<Action>>` or `std::vector<std::unique_ptr<Action>>`) to\
  \ store executed actions.\n   - Maintain an index to the current position in the\
  \ list (top of the undo stack).\n   - `push(std::unique_ptr<Action> action)`: Adds\
  \ a new action. This should execute the action. If there are actions in the \"redo\"\
  \ part of the stack (i.e., current index < list size - 1), they should be cleared.\n\
  \   - `undo()`: If possible, calls `undo()` on the action at the current index and\
  \ decrements the index.\n   - `redo()`: If possible, calls `execute()` (or `redo()`)\
  \ on the action at the next index and increments the index.\n   - `canUndo()`: Returns\
  \ true if actions can be undone.\n   - `canRedo()`: Returns true if actions can\
  \ be redone.\n   - Implement logic for limiting the stack size (e.g., based on item\
  \ count or estimated memory, similar to `UNDO_MEM_SIZE` and `UNDO_SIZE` from `Config`).\
  \ When the limit is reached, the oldest actions are discarded.\n   - The `BatchAction`\
  \ concept from the original code allowed grouping multiple `Action` instances, often\
  \ of the same type, if they occurred close in time (stacking delay). Consider if\
  \ this is a requirement for the initial port. If so, the `ActionQueue::push` logic\
  \ would need to check the last action and potentially merge the new one if it meets\
  \ the criteria, or a `BatchAction` itself could be an `Action` subclass that manages\
  \ a list of sub-actions. For simplicity, individual actions might be sufficient\
  \ for a first pass.\n\n**General Porting Instructions:**\n   - Replace wxWidgets\
  \ specific types or utilities with Qt/STL equivalents.\n   - Ensure robust memory\
  \ management using smart pointers (`std::unique_ptr` is highly recommended for actions\
  \ in the queue).\n   - The `Action` classes will need to interact with the map data.\
  \ This interaction should ideally be through well-defined interfaces or references\
  \ to map manipulation services, passed into the actions or accessible globally (though\
  \ direct global access is less ideal).\n   - The `ActionIdentifier` enum can be\
  \ reused or adapted.\n   - The `DirtyList` from the original code seems related\
  \ to notifying other parts of the system about changes. This can be handled by having\
  \ actions emit signals (if using Qt's signal/slot mechanism) or by calling a notification\
  \ service after execution/undo.\n   - Provide header (.h) and source (.cpp) files\
  \ for the `Action` base class, the `ActionQueue`, and any example concrete action(s).\n\
  \   - Include basic unit tests (e.g., using Qt Test framework) for `ActionQueue`\
  \ functionality and a sample action.\n"
