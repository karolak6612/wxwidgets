#include "core/brush/EraserBrush.h"
#include "core/map/Map.h" // For canApply's Map argument and Position
#include "core/assets/AssetManager.h" // Included for completeness, though provider comes via settings
#include "core/assets/IItemTypeProvider.h" // For IItemTypeProvider interface
#include "core/assets/ItemData.h"     // For ItemType/isComplex/isBorder if needed directly by brush (not currently)
#include "core/brush/BrushSettings.h"
#include "core/editor_logic/EditorControllerInterface.h" // For controller in apply
#include "core/Position.h" // For RME::core::Position
#include <QString>
#include <QDebug> // For placeholder warnings and qInfo
#include <QObject> // For QObject::tr

namespace RME {
namespace core {
namespace brush {

EraserBrush::EraserBrush() : Brush() {
}

QString EraserBrush::getName() const {
    return QObject::tr("Eraser");
}

int EraserBrush::getLookID(const BrushSettings& /*settings*/) const {
    return EDITOR_SPRITE_ERASER_LOOKID;
}

bool EraserBrush::canApply(const map::Map* map, const Position& pos, const BrushSettings& /*settings*/) const {
    return map ? map->isPositionValid(pos) : false;
}

void EraserBrush::apply(editor::EditorControllerInterface* controller, const Position& pos, const BrushSettings& settings) {
    if (!controller) {
        qWarning("EraserBrush::apply: EditorControllerInterface is null for position (%d,%d,%d).", pos.x, pos.y, pos.z);
        return;
    }
    // IItemTypeProvider is needed if EraserBrush itself needs to check item properties.
    // However, the current plan is for the controller to handle this logic.
    // const IItemTypeProvider* provider = settings.getItemTypeProvider();
    // if (!provider) {
    //     qWarning("EraserBrush::apply: ItemTypeProvider not available in BrushSettings for position (%d,%d,%d).", pos.x, pos.y, pos.z);
    //     return;
    // }

    // TODO: Get this from AppSettings via REFACTOR-01 (passed through settings or controller context)
    bool leaveUniqueItemsSetting = false;
    // qInfo("EraserBrush::apply: 'Leave Unique Items' setting is currently hardcoded to %s for position (%d,%d,%d).",
    //       leaveUniqueItemsSetting ? "true" : "false", pos.x, pos.y, pos.z);

    bool isAggressive = settings.isAggressiveEraseMode();

    if (isAggressive) {
        qInfo("EraserBrush::apply (Aggressive) at (%d,%d,%d)", pos.x, pos.y, pos.z);
        // Conceptual call: controller will handle removing all items (except unique if specified),
        // creatures, and potentially spawns/house references from the tile.
        controller->clearTileAggressively(pos, leaveUniqueItemsSetting);
        qWarning("EraserBrush::apply (Aggressive): Call to controller->clearTileAggressively is a placeholder.");
    } else { // Normal Erase
        qInfo("EraserBrush::apply (Normal) at (%d,%d,%d)", pos.x, pos.y, pos.z);
        // Conceptual call: controller will handle removing top non-ground items,
        // or ground if it's not 'permanent' and no other items are present,
        // respecting leaveUniqueItemsSetting.
        controller->clearTileNormally(pos, leaveUniqueItemsSetting);
        qWarning("EraserBrush::apply (Normal): Call to controller->clearTileNormally is a placeholder.");
    }

    // The need for border updates is signaled by needsBorders() returning true.
    // The EditorController or a command generated by it would typically query this
    // and then trigger the necessary border updates for the affected area.
    // No direct call from brush to map for border updates.
    // qInfo("EraserBrush::apply: Border update would be requested by controller for area around (%d,%d,%d)", pos.x, pos.y, pos.z);
}

} // namespace brush
} // namespace core
} // namespace RME
