<?xml version="1.0" ?>
<UI-09>
  <id>UI-09</id>
  <section>UI Elements</section>
  <title>Port Live Server Control Panel</title>
  <original_task_id>UI-09</original_task_id>
  <description>Recreate the UI for managing a live editing server. This includes displaying connected clients, server logs/chat, server settings (port, password), and controls to start/stop the server.</description>
  <dependencies>
    <dependencie>NET-02 # LiveServerQt logic that this UI will control and interact with.</dependencie>
    <dependencie>UI-01  # Main window might host this as a dock widget or dialog.</dependencie>
    <dependencie>REFACTOR-01 # For QSettings, if server settings are persisted.</dependencie>
    <dependencie>LOGIC-01</dependencie>
  </dependencies>
  <input_files>
    <input_file>wxwidgets/live_server.cpp</input_file>
    <input_file>wxwidgets/live_server.h</input_file>
    <input_file>wxwidgets/main_menubar.cpp # Contains dialog logic for initiating server hosting.</input_file>
  </input_files>
  <analyzed_input_files>
    <analyzed_input_file>
      <file_path>wxwidgets/live_server.h</file_path>
      <description>Declares the `LiveServer` class (derived from `LiveSocket`). Defines its interface for binding to a port, accepting client connections (`LivePeer`), closing the server, broadcasting map changes, cursor updates, and chat messages. It also holds a pointer to the `Editor` instance and the `LiveLogTab` (its UI component for displaying logs, chat, and client lists).</description>
    </analyzed_input_file>
    <analyzed_input_file>
      <file_path>wxwidgets/live_server.cpp</file_path>
      <description>Implements `LiveServer`. Uses Boost.Asio for network communication. `bind()`: Binds to a port, with logic to try subsequent ports if the initial one is busy. `acceptClient()`: Asynchronously accepts new client connections, creating a `LivePeer` for each. `removeClient()`: Handles client disconnections. `broadcastNodes()`, `broadcastCursor()`, `broadcastChat()`: Send relevant data to all connected peers. `createLogWindow()`: Creates and returns a `LiveLogTab` instance, which is the wxWidgets UI panel this WBS item's `LiveServerControlPanelQt` aims to replace/enhance by providing server controls alongside the information display.</description>
    </analyzed_input_file>
    <analyzed_input_file>
      <file_path>wxwidgets/main_menubar.cpp</file_path>
      <description>(Partially relevant for UI-09) Contains event handlers like `OnStartLive` and `onServerHost`. These methods in `MainMenuBar` create `wxDialog` instances to gather server configuration details (server name (cosmetic), port, password) from the user *before* the `LiveServer` instance is created and started. These input fields will need to be part of the new `LiveServerControlPanelQt`.</description>
    </analyzed_input_file>
  </analyzed_input_files>
  <documentation_references>
    <documentation_reference>QDialog: https://doc.qt.io/qt-6/qdialog.html</documentation_reference>
    <documentation_reference>QDockWidget: https://doc.qt.io/qt-6/qdockwidget.html</documentation_reference>
    <documentation_reference>QTcpServer (conceptual reference, actual server logic in NET-02): https://doc.qt.io/qt-6/qtcpserver.html</documentation_reference>
    <documentation_reference>QTextEdit: https://doc.qt.io/qt-6/qtextedit.html (for logs/chat)</documentation_reference>
    <documentation_reference>QListView / QStringListModel: https://doc.qt.io/qt-6/qlistview.html (for client list)</documentation_reference>
    <documentation_reference>QSpinBox, QLineEdit, QPushButton: Standard input widgets for controls.</documentation_reference>
  </documentation_references>
  <current_functionality_summary>In the wxWidgets version, live server hosting is typically initiated via dialogs launched from the `MainMenuBar` (e.g., `OnStartLive` handler). These dialogs collect server parameters like a cosmetic server name, port number, and password.

The `LiveServer` class itself then handles the networking logic:
- Binding to the specified port (with retry logic for subsequent ports if the initial one is occupied).
- Accepting incoming client connections, each managed as a `LivePeer` instance.
- Broadcasting map changes, cursor position updates, and chat messages to all connected clients.

For UI feedback, the `LiveServer` instance creates a `LiveLogTab`. This `LiveLogTab` is a `wxPanel` (likely added to the main application's `wxAuiNotebook` or similar tabbed interface) responsible for:
- Displaying server status messages and operational logs.
- Showing chat messages exchanged during the session.
- Listing currently connected clients.
The `LiveLogTab` is primarily for information display; server control (start/stop) is not managed through it but via the initial dialogs and menu actions.
</current_functionality_summary>
  <definition_of_done>
    <element>A `LiveServerControlPanelQt` widget (e.g., a `QDialog` or preferably a `QDockWidget` for better integration) is implemented in Qt6.</element>
    <element>The panel includes UI elements for:</element>
    <element>  - Inputting server port (`QSpinBox`) and password (`QLineEdit` with `Password` echo mode).</element>
    <element>  - A `QPushButton` to 'Start Server' and another to 'Stop Server'.</element>
    <element>  - A `QTextEdit` (read-only) to display server logs, chat messages, and client connection/disconnection events.</element>
    <element>  - A `QListView` (with `QStringListModel` or custom model if more client details are needed) to display names/IDs of currently connected clients.</element>
    <element>  - A `QLineEdit` and `QPushButton` for the server host to type and send chat messages.</element>
    <element>The 'Start Server' button action:</element>
    <element>  - Retrieves port and password from the UI controls.</element>
    <element>  - Instantiates (or accesses an existing instance of) the `LiveServerQt` (from `NET-02`).</element>
    <element>  - Calls a method on `LiveServerQt` (e.g., `startListening(port, password)`) to bind and start listening. This method should replicate the logic of trying subsequent ports if the initial one fails.</element>
    <element>  - Updates the UI to reflect the server's running state (e.g., disable 'Start Server' button, enable 'Stop Server' button, clear and update port field if it auto-incremented, log success/failure message to the `QTextEdit`).</element>
    <element>The 'Stop Server' button action:</element>
    <element>  - Calls a method on `LiveServerQt` (e.g., `closeServer()`) to close all client connections and stop listening.</element>
    <element>  - Updates the UI to reflect the server stopped state (e.g., enable 'Start Server', disable 'Stop Server', log server stopped message).</element>
    <element>The server log/chat `QTextEdit` is dynamically updated with messages received from `LiveServerQt` via signals (e.g., `logMessage(QString)`, `chatMessageReceived(QString_speaker, QString_message)`, `clientActivity(QString_clientName, bool_connected)`).</element>
    <element>The connected clients `QListView` is dynamically updated when clients connect or disconnect, based on signals from `LiveServerQt`.</element>
    <element>The host can type messages into the chat `QLineEdit` and click the &quot;Send&quot; `QPushButton` to have `LiveServerQt` broadcast them. The sent message also appears in the host's log/chat display.</element>
    <element>UI controls for port and password are disabled when the server is running and re-enabled when stopped.</element>
    <element>Initial default values for port and password may be loaded from `QSettings`.</element>
  </definition_of_done>
  <estimation_effort>Medium (7-10 developer days)</estimation_effort>
  <known_missing_files/>
  <boilerplate_coder_ai_prompt>Your task is to create the Qt6 UI for a Live Server Control Panel. This panel will allow the user to configure, start, and stop a live editing server (`LiveServerQt` from `NET-02`), as well as monitor connected clients and server activity/chat.

**Reference Files:**
- `wxwidgets/live_server.cpp` &amp; `wxwidgets/live_server.h`: For understanding `LiveServer`'s existing functionalities (port binding, client management, logging via `LiveLogTab`, chat broadcasting).
- `wxwidgets/main_menubar.cpp`: For the dialogs used to gather server settings (`OnStartLive`, `onServerHost`).

**1. `LiveServerControlPanelQt` Widget (Design as a `QWidget` suitable for being placed in a `QDialog` or `QDockWidget` by `UI-01`):**

   **Layout (Example using `QVBoxLayout` and `QGroupBox`):**
   ```
   QVBoxLayout* mainLayout = new QVBoxLayout(this);

   // Server Configuration GroupBox
   QGroupBox* configGroup = new QGroupBox(&quot;Server Configuration&quot;);
   QFormLayout* configLayout = new QFormLayout(configGroup);
   m_portSpinBox = new QSpinBox(); // Range 1-65535, Default e.g. 31313
   m_passwordEdit = new QLineEdit(); // EchoMode: Password
   configLayout-&gt;addRow(&quot;Port:&quot;, m_portSpinBox);
   configLayout-&gt;addRow(&quot;Password:&quot;, m_passwordEdit);
   mainLayout-&gt;addWidget(configGroup);

   // Controls
   QHBoxLayout* controlsLayout = new QHBoxLayout();
   m_startServerButton = new QPushButton(&quot;Start Server&quot;);
   m_stopServerButton = new QPushButton(&quot;Stop Server&quot;);
   m_stopServerButton-&gt;setEnabled(false);
   controlsLayout-&gt;addWidget(m_startServerButton);
   controlsLayout-&gt;addWidget(m_stopServerButton);
   mainLayout-&gt;addLayout(controlsLayout);

   // Client List GroupBox
   QGroupBox* clientsGroup = new QGroupBox(&quot;Connected Clients&quot;);
   QVBoxLayout* clientsLayout = new QVBoxLayout(clientsGroup);
   m_clientListView = new QListView();
   m_clientListModel = new QStringListModel(this); // Or a custom model
   m_clientListView-&gt;setModel(m_clientListModel);
   clientsLayout-&gt;addWidget(m_clientListView);
   mainLayout-&gt;addWidget(clientsGroup);

   // Log &amp; Chat GroupBox
   QGroupBox* logChatGroup = new QGroupBox(&quot;Log &amp; Chat&quot;);
   QVBoxLayout* logChatLayout = new QVBoxLayout(logChatGroup);
   m_logTextEdit = new QTextEdit();
   m_logTextEdit-&gt;setReadOnly(true);
   logChatLayout-&gt;addWidget(m_logTextEdit, 1); // Make log area stretch
   QHBoxLayout* chatInputLayout = new QHBoxLayout();
   m_chatInputEdit = new QLineEdit();
   m_sendChatButton = new QPushButton(&quot;Send&quot;);
   chatInputLayout-&gt;addWidget(m_chatInputEdit, 1);
   chatInputLayout-&gt;addWidget(m_sendChatButton);
   logChatLayout-&gt;addLayout(chatInputLayout);
   mainLayout-&gt;addWidget(logChatGroup, 1); // Make log/chat group stretch
   ```

   **Private Members in Header:**
   ```cpp
   // Qt UI Elements
   QSpinBox* m_portSpinBox;
   QLineEdit* m_passwordEdit;
   QPushButton* m_startServerButton;
   QPushButton* m_stopServerButton;
   QListView* m_clientListView;
   QStringListModel* m_clientListModel; // Or custom model
   QTextEdit* m_logTextEdit;
   QLineEdit* m_chatInputEdit;
   QPushButton* m_sendChatButton;

   LiveServerQt* m_liveServer; // Pointer to the actual server logic instance (from NET-02)
   QSettings* m_settings; // For persisting port/password
   ```

   **Functionality:**
   - **Constructor:**
     - Initialize UI elements.
     - `m_settings = new QSettings(...)`
     - Load last used port/password from `m_settings` into `m_portSpinBox` and `m_passwordEdit`.
     - `m_liveServer = /* Get instance of LiveServerQt from NET-02, e.g., via a singleton or service locator */ ;`
     - Connect `m_startServerButton-&gt;clicked` to `onStartServer()`.
     - Connect `m_stopServerButton-&gt;clicked` to `onStopServer()`.
     - Connect `m_sendChatButton-&gt;clicked` to `onSendChat()`.
     - Connect `m_chatInputEdit-&gt;returnPressed` to `onSendChat()`.
     - Connect signals from `m_liveServer` to corresponding slots in this panel:
       - `connect(m_liveServer, &amp;LiveServerQt::logMessage, this, &amp;LiveServerControlPanelQt::appendLogMessage);`
       - `connect(m_liveServer, &amp;LiveServerQt::clientConnected, this, &amp;LiveServerControlPanelQt::addClientToList);`
       - `connect(m_liveServer, &amp;LiveServerQt::clientDisconnected, this, &amp;LiveServerControlPanelQt::removeClientFromList);`
       - `connect(m_liveServer, &amp;LiveServerQt::chatMessageReceived, this, &amp;LiveServerControlPanelQt::displayChatMessage);`
       - `connect(m_liveServer, &amp;LiveServerQt::serverStatusChanged, this, &amp;LiveServerControlPanelQt::updateServerUIState);`

   - **`onStartServer()` slot:**
     1. Retrieve `port = m_portSpinBox-&gt;value()` and `password = m_passwordEdit-&gt;text()`.
     2. Save `port` and `password` to `m_settings`.
     3. Call `bool success = m_liveServer-&gt;startListening(port, password);`.
     4. `updateServerUIState(success, m_liveServer-&gt;getCurrentPort());` // `LiveServerQt` should provide method to get actual port if it auto-incremented.

   - **`onStopServer()` slot:**
     1. Call `m_liveServer-&gt;closeServer();`.
     2. `updateServerUIState(false, 0);`

   - **`updateServerUIState(bool isRunning, quint16 actualPort)` slot:**
     - `m_startServerButton-&gt;setDisabled(isRunning);`
     - `m_portSpinBox-&gt;setDisabled(isRunning);`
     - `m_passwordEdit-&gt;setDisabled(isRunning);`
     - `m_stopServerButton-&gt;setEnabled(isRunning);`
     - If `isRunning`, `appendLogMessage(QString(&quot;Server started on port %1.&quot;).arg(actualPort));`
     - Else, `appendLogMessage(&quot;Server stopped.&quot;);`

   - **`appendLogMessage(const QString&amp; message)` slot:**
     - `m_logTextEdit-&gt;append(message);`

   - **`addClientToList(const QString&amp; clientName, int /*clientId*/)` slot:**
     - `m_clientListModel-&gt;insertRow(m_clientListModel-&gt;rowCount());`
     - `m_clientListModel-&gt;setData(m_clientListModel-&gt;index(m_clientListModel-&gt;rowCount() - 1), clientName);`
     - `appendLogMessage(QString(&quot;Client connected: %1&quot;).arg(clientName));`

   - **`removeClientFromList(const QString&amp; clientName, int /*clientId*/)` slot:**
     - Find and remove `clientName` from `m_clientListModel`.
     - `appendLogMessage(QString(&quot;Client disconnected: %1&quot;).arg(clientName));`

   - **`displayChatMessage(const QString&amp; speaker, const QString&amp; message)` slot:**
     - `appendLogMessage(QString(&quot;[%1]: %2&quot;).arg(speaker, message));`

   - **`onSendChat()` slot:**
     1. `QString message = m_chatInputEdit-&gt;text().trimmed();`
     2. If `!message.isEmpty()`:
        - `m_liveServer-&gt;broadcastChatMessageAsHost(message);` // Method to be implemented in `LiveServerQt`
        - `appendLogMessage(QString(&quot;[HOST]: %1&quot;).arg(message));`
        - `m_chatInputEdit-&gt;clear();`

This control panel provides the UI for managing the live server instance created by `NET-02`.
</boilerplate_coder_ai_prompt>
</UI-09>
