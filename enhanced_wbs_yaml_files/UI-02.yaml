wbs_item_id: UI-02
name: Port Toolbars & Palettes
description: Recreate main application toolbars (standard, brushes, position, sizes) and the palette system (terrain, doodad, item, creature, house, waypoint, etc.) using Qt6 widgets.
dependencies:
- UI-01
- CORE-02
- CORE-04
input_files:
- wxwidgets/main_toolbar.cpp
- wxwidgets/main_toolbar.h
- wxwidgets/palette_window.cpp
- wxwidgets/palette_window.h
- wxwidgets/palette_brushlist.cpp
- wxwidgets/palette_brushlist.h
- wxwidgets/palette_creature.cpp
- wxwidgets/palette_creature.h
- wxwidgets/palette_house.cpp
- wxwidgets/palette_house.h
- wxwidgets/palette_waypoints.cpp
- wxwidgets/palette_waypoints.h
analyzed_input_files:
- file_path: wxwidgets/main_toolbar.cpp
  description: Implements `MainToolBar` which creates and manages several `wxAuiToolBar` instances (standard, brushes, position, sizes) with various controls and actions. Handles their layout and updates their state.
  md5_hash: 4ff971ba2ba5c083806c689ff11800d7
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#include \"main.h\"\\n#include \"main_toolbar.h\"\
    \\n#include \"gui.h\"\\n#include \"editor.h\"\\n#include \"settings.h\"\\n#include \"brush.h\"\\n#include \"pngfiles.h\"\\n#include \"artprovider.h\"\\n#include <wx/artprov.h>\\n#include <wx/mstream.h>\\n#include \"hotkey_manager.h\"\\n#include <pugixml.hpp>\\n\\nconst wxString MainToolBar::STANDARD_BAR_NAME = \"standard_toolbar\";\\nconst wxString MainToolBar::BRUSHES_BAR_NAME = \"brushes_toolbar\";\\nconst wxString MainToolBar::POSITION_BAR_NAME = \"position_toolbar\";\\nconst wxString MainToolBar::SIZES_BAR_NAME = \"sizes_toolbar\";\\n\\n#define loadPNGFile(name) _wxGetBitmapFromMemory(name, sizeof(name))\\ninline wxBitmap* _wxGetBitmapFromMemory(const unsigned char* data, int length) {\\n\twxMemoryInputStream is(data, length);\\n\twxImage img(is, \"image/png\");\\n\tif (!img.IsOk()) {\\n\t\treturn nullptr;\\n\t}\\n\treturn newd wxBitmap(img, -1);\\n}\\n\\nMainToolBar::MainToolBar(wxWindow* parent, wxAuiManager* manager) {\\n\twxSize icon_size = FROM_DIP(parent, wxSize(16, 16));\\\
    n\twxBitmap new_bitmap = wxArtProvider::GetBitmap(wxART_NEW, wxART_TOOLBAR, icon_size);\\n\twxBitmap open_bitmap = wxArtProvider::GetBitmap(wxART_FILE_OPEN, wxART_TOOLBAR, icon_size);\\n\twxBitmap save_bitmap = wxArtProvider::GetBitmap(wxART_FILE_SAVE, wxART_TOOLBAR, icon_size);\\n\twxBitmap saveas_bitmap = wxArtProvider::GetBitmap(wxART_FILE_SAVE_AS, wxART_TOOLBAR, icon_size);\\n\twxBitmap undo_bitmap = wxArtProvider::GetBitmap(wxART_UNDO, wxART_TOOLBAR, icon_size);\\n\twxBitmap redo_bitmap = wxArtProvider::GetBitmap(wxART_REDO, wxART_TOOLBAR, icon_size);\\n\twxBitmap cut_bitmap = wxArtProvider::GetBitmap(wxART_CUT, wxART_TOOLBAR, icon_size);\\n\twxBitmap copy_bitmap = wxArtProvider::GetBitmap(wxART_COPY, wxART_TOOLBAR, icon_size);\\n\twxBitmap paste_bitmap = wxArtProvider::GetBitmap(wxART_PASTE, wxART_TOOLBAR, icon_size);\\n\\n\tstandard_toolbar = newd wxAuiToolBar(parent, TOOLBAR_STANDARD, wxDefaultPosition, wxDefaultSize, wxAUI_TB_DEFAULT_STYLE);\\n\tstandard_toolbar->SetToolBitmapSize(icon_size);\\\
    n\tstandard_toolbar->AddTool(wxID_NEW, wxEmptyString, new_bitmap, wxNullBitmap, wxITEM_NORMAL, \"New Map\", wxEmptyString, NULL);\\n\tstandard_toolbar->AddTool(wxID_OPEN, wxEmptyString, open_bitmap, wxNullBitmap, wxITEM_NORMAL, \"Open Map\", wxEmptyString, NULL);\\n\tstandard_toolbar->AddTool(wxID_SAVE, wxEmptyString, save_bitmap, wxNullBitmap, wxITEM_NORMAL, \"Save Map\", wxEmptyString, NULL);\\n\tstandard_toolbar->AddTool(wxID_SAVEAS, wxEmptyString, saveas_bitmap, wxNullBitmap, wxITEM_NORMAL, \"Save Map As...\", wxEmptyString, NULL);\\n\tstandard_toolbar->AddSeparator();\\n\tstandard_toolbar->AddTool(wxID_UNDO, wxEmptyString, undo_bitmap, wxNullBitmap, wxITEM_NORMAL, \"Undo\", wxEmptyString, NULL);\\n\tstandard_toolbar->AddTool(wxID_REDO, wxEmptyString, redo_bitmap, wxNullBitmap, wxITEM_NORMAL, \"Redo\", wxEmptyString, NULL);\\n\tstandard_toolbar->AddSeparator();\\n\tstandard_toolbar->AddTool(wxID_CUT, wxEmptyString, cut_bitmap, wxNullBitmap, wxITEM_NORMAL, \"Cut\", wxEmptyString,\
    \ NULL);\\n\tstandard_toolbar->AddTool(wxID_COPY, wxEmptyString, copy_bitmap, wxNullBitmap, wxITEM_NORMAL, \"Copy\", wxEmptyString, NULL);\\n\tstandard_toolbar->AddTool(wxID_PASTE, wxEmptyString, paste_bitmap, wxNullBitmap, wxITEM_NORMAL, \"Paste\", wxEmptyString, NULL);\\n\tstandard_toolbar->Realize();\\n\\n\twxBitmap* border_bitmap = loadPNGFile(optional_border_small_png);\\n\twxBitmap* eraser_bitmap = loadPNGFile(eraser_small_png);\\n\twxBitmap pz_bitmap = wxArtProvider::GetBitmap(ART_PZ_BRUSH, wxART_TOOLBAR, icon_size);\\n\twxBitmap nopvp_bitmap = wxArtProvider::GetBitmap(ART_NOPVP_BRUSH, wxART_TOOLBAR, icon_size);\\n\twxBitmap nologout_bitmap = wxArtProvider::GetBitmap(ART_NOLOOUT_BRUSH, wxART_TOOLBAR, icon_size);\\n\twxBitmap pvp_bitmap = wxArtProvider::GetBitmap(ART_PVP_BRUSH, wxART_TOOLBAR, icon_size);\\n\twxBitmap normal_bitmap = wxArtProvider::GetBitmap(ART_DOOR_NORMAL_SMALL, wxART_TOOLBAR, icon_size);\\n\twxBitmap locked_bitmap = wxArtProvider::GetBitmap(ART_DOOR_LOCKED_SMALL,\
    \ wxART_TOOLBAR, icon_size);\\n\twxBitmap magic_bitmap = wxArtProvider::GetBitmap(ART_DOOR_MAGIC_SMALL, wxART_TOOLBAR, icon_size);\\n\twxBitmap quest_bitmap = wxArtProvider::GetBitmap(ART_DOOR_QUEST_SMALL, wxART_TOOLBAR, icon_size);\\n\twxBitmap normal_alt_bitmap = wxArtProvider::GetBitmap(ART_DOOR_NORMAL_ALT_SMALL, wxART_TOOLBAR, icon_size);\\n\twxBitmap archway_bitmap = wxArtProvider::GetBitmap(ART_DOOR_ARCHWAY_SMALL, wxART_TOOLBAR, icon_size);\\n\\n\twxBitmap* hatch_bitmap = loadPNGFile(window_hatch_small_png);\\n\twxBitmap* window_bitmap = loadPNGFile(window_normal_small_png);\\n\\n\tbrushes_toolbar = newd wxAuiToolBar(parent, TOOLBAR_BRUSHES, wxDefaultPosition, wxDefaultSize, wxAUI_TB_DEFAULT_STYLE);\\n\tbrushes_toolbar->SetToolBitmapSize(icon_size);\\n\tbrushes_toolbar->AddTool(PALETTE_TERRAIN_OPTIONAL_BORDER_TOOL, wxEmptyString, *border_bitmap, wxNullBitmap, wxITEM_CHECK, \"Border\", wxEmptyString, NULL);\\n\tbrushes_toolbar->AddTool(PALETTE_TERRAIN_ERASER, wxEmptyString, *eraser_bitmap,\
    \ wxNullBitmap, wxITEM_CHECK, \"Eraser\", wxEmptyString, NULL);\\n\tbrushes_toolbar->AddSeparator();\\n\tbrushes_toolbar->AddTool(PALETTE_TERRAIN_PZ_TOOL, wxEmptyString, pz_bitmap, wxNullBitmap, wxITEM_CHECK, \"Protected Zone\", wxEmptyString, NULL);\\n\tbrushes_toolbar->AddTool(PALETTE_TERRAIN_NOPVP_TOOL, wxEmptyString, nopvp_bitmap, wxNullBitmap, wxITEM_CHECK, \"No PvP Zone\", wxEmptyString, NULL);\\n\tbrushes_toolbar->AddTool(PALETTE_TERRAIN_NOLOGOUT_TOOL, wxEmptyString, nologout_bitmap, wxNullBitmap, wxITEM_CHECK, \"No Logout Zone\", wxEmptyString, NULL);\\n\tbrushes_toolbar->AddTool(PALETTE_TERRAIN_PVPZONE_TOOL, wxEmptyString, pvp_bitmap, wxNullBitmap, wxITEM_CHECK, \"PvP Zone\", wxEmptyString, NULL);\\n\tbrushes_toolbar->AddTool(PALETTE_TERRAIN_ZONE_BRUSH, wxEmptyString, normal_bitmap, wxNullBitmap, wxITEM_CHECK, \"Zone Brush\", wxEmptyString, NULL);\\n\tbrushes_toolbar->AddSeparator();\\n\\n\tbrushes_toolbar->AddTool(PALETTE_TERRAIN_NORMAL_DOOR, wxEmptyString, normal_bitmap, wxNullBitmap,\
    \ wxITEM_CHECK, \"Normal Door\", wxEmptyString, NULL);\\n\tbrushes_toolbar->AddTool(PALETTE_TERRAIN_LOCKED_DOOR, wxEmptyString, locked_bitmap, wxNullBitmap, wxITEM_CHECK, \"Locked Door\", wxEmptyString, NULL);\\n\tbrushes_toolbar->AddTool(PALETTE_TERRAIN_MAGIC_DOOR, wxEmptyString, magic_bitmap, wxNullBitmap, wxITEM_CHECK, \"Magic Door\", wxEmptyString, NULL);\\n\tbrushes_toolbar->AddTool(PALETTE_TERRAIN_QUEST_DOOR, wxEmptyString, quest_bitmap, wxNullBitmap, wxITEM_CHECK, \"Quest Door\", wxEmptyString, NULL);\\n\tbrushes_toolbar->AddTool(PALETTE_TERRAIN_NORMAL_ALT_DOOR, wxEmptyString, normal_alt_bitmap, wxNullBitmap, wxITEM_CHECK, \"Normal Door (alt)\", wxEmptyString, NULL);\\n\tbrushes_toolbar->AddTool(PALETTE_TERRAIN_ARCHWAY_DOOR, wxEmptyString, archway_bitmap, wxNullBitmap, wxITEM_CHECK, \"Archway\", wxEmptyString, NULL);\\n\tbrushes_toolbar->AddSeparator();\\n\tbrushes_toolbar->AddTool(PALETTE_TERRAIN_HATCH_DOOR, wxEmptyString, *hatch_bitmap, wxNullBitmap, wxITEM_CHECK, \"Hatch Window\"\
    , wxEmptyString, NULL);\\n\tbrushes_toolbar->AddTool(PALETTE_TERRAIN_WINDOW_DOOR, wxEmptyString, *window_bitmap, wxNullBitmap, wxITEM_CHECK, \"Window\", wxEmptyString, NULL);\\n\tbrushes_toolbar->Realize();\\n\\n\twxBitmap go_bitmap = wxArtProvider::GetBitmap(ART_POSITION_GO, wxART_TOOLBAR, icon_size);\\n\\n\tposition_toolbar = newd wxAuiToolBar(parent, TOOLBAR_POSITION, wxDefaultPosition, wxDefaultSize, wxAUI_TB_DEFAULT_STYLE | wxAUI_TB_HORZ_TEXT);\\n\tposition_toolbar->SetToolBitmapSize(icon_size);\\n\tx_control = newd NumberTextCtrl(position_toolbar, wxID_ANY, 0, 0, MAP_MAX_WIDTH, wxTE_PROCESS_ENTER, \"X\", wxDefaultPosition, FROM_DIP(parent, wxSize(60, 20)));\\n\tx_control->SetToolTip(\"X Coordinate\");\\n\ty_control = newd NumberTextCtrl(position_toolbar, wxID_ANY, 0, 0, MAP_MAX_HEIGHT, wxTE_PROCESS_ENTER, \"Y\", wxDefaultPosition, FROM_DIP(parent, wxSize(60, 20)));\\n\ty_control->SetToolTip(\"Y Coordinate\");\\n\tz_control = newd NumberTextCtrl(position_toolbar, wxID_ANY, 0, 0,\
    \ MAP_MAX_LAYER, wxTE_PROCESS_ENTER, \"Z\", wxDefaultPosition, FROM_DIP(parent, wxSize(35, 20)));\\n\tz_control->SetToolTip(\"Z Coordinate\");\\n\tgo_button = newd wxButton(position_toolbar, TOOLBAR_POSITION_GO, wxEmptyString, wxDefaultPosition, parent->FromDIP(wxSize(22, 20)));\\n\tgo_button->SetBitmap(go_bitmap);\\n\tgo_button->SetToolTip(\"Go To Position\");\\n\tposition_toolbar->AddControl(x_control);\\n\tposition_toolbar->AddControl(y_control);\\n\tposition_toolbar->AddControl(z_control);\\n\tposition_toolbar->AddControl(go_button);\\n\tposition_toolbar->Realize();\\n\\n\twxBitmap circular_bitmap = wxArtProvider::GetBitmap(ART_CIRCULAR, wxART_TOOLBAR, icon_size);\\n\twxBitmap rectangular_bitmap = wxArtProvider::GetBitmap(ART_RECTANGULAR, wxART_TOOLBAR, icon_size);\\n\twxBitmap size1_bitmap = wxArtProvider::GetBitmap(ART_RECTANGULAR_1, wxART_TOOLBAR, icon_size);\\n\twxBitmap size2_bitmap = wxArtProvider::GetBitmap(ART_RECTANGULAR_2, wxART_TOOLBAR, icon_size);\\n\twxBitmap size3_bitmap\
    \ = wxArtProvider::GetBitmap(ART_RECTANGULAR_3, wxART_TOOLBAR, icon_size);\\n\twxBitmap size4_bitmap = wxArtProvider::GetBitmap(ART_RECTANGULAR_4, wxART_TOOLBAR, icon_size);\\n\twxBitmap size5_bitmap = wxArtProvider::GetBitmap(ART_RECTANGULAR_5, wxART_TOOLBAR, icon_size);\\n\twxBitmap size6_bitmap = wxArtProvider::GetBitmap(ART_RECTANGULAR_6, wxART_TOOLBAR, icon_size);\\n\twxBitmap size7_bitmap = wxArtProvider::GetBitmap(ART_RECTANGULAR_7, wxART_TOOLBAR, icon_size);\\n\\n\tsizes_toolbar = newd wxAuiToolBar(parent, TOOLBAR_SIZES, wxDefaultPosition, wxDefaultSize, wxAUI_TB_DEFAULT_STYLE);\\n\tsizes_toolbar->SetToolBitmapSize(icon_size);\\n\tsizes_toolbar->AddTool(TOOLBAR_SIZES_RECTANGULAR, wxEmptyString, rectangular_bitmap, wxNullBitmap, wxITEM_CHECK, \"Rectangular Brush\", wxEmptyString, NULL);\\n\tsizes_toolbar->AddTool(TOOLBAR_SIZES_CIRCULAR, wxEmptyString, circular_bitmap, wxNullBitmap, wxITEM_CHECK, \"Circular Brush\", wxEmptyString, NULL);\\n\tsizes_toolbar->AddSeparator();\\n\t\
    sizes_toolbar->AddTool(TOOLBAR_SIZES_1, wxEmptyString, size1_bitmap, wxNullBitmap, wxITEM_CHECK, \"Size 1\", wxEmptyString, NULL);\\n\tsizes_toolbar->AddTool(TOOLBAR_SIZES_2, wxEmptyString, size2_bitmap, wxNullBitmap, wxITEM_CHECK, \"Size 2\", wxEmptyString, NULL);\\n\tsizes_toolbar->AddTool(TOOLBAR_SIZES_3, wxEmptyString, size3_bitmap, wxNullBitmap, wxITEM_CHECK, \"Size 3\", wxEmptyString, NULL);\\n\tsizes_toolbar->AddTool(TOOLBAR_SIZES_4, wxEmptyString, size4_bitmap, wxNullBitmap, wxITEM_CHECK, \"Size 4\", wxEmptyString, NULL);\\n\tsizes_toolbar->AddTool(TOOLBAR_SIZES_5, wxEmptyString, size5_bitmap, wxNullBitmap, wxITEM_CHECK, \"Size 5\", wxEmptyString, NULL);\\n\tsizes_toolbar->AddTool(TOOLBAR_SIZES_6, wxEmptyString, size6_bitmap, wxNullBitmap, wxITEM_CHECK, \"Size 6\", wxEmptyString, NULL);\\n\tsizes_toolbar->AddTool(TOOLBAR_SIZES_7, wxEmptyString, size7_bitmap, wxNullBitmap, wxITEM_CHECK, \"Size 7\", wxEmptyString, NULL);\\n\tsizes_toolbar->Realize();\\n\tsizes_toolbar->ToggleTool(TOOLBAR_SIZES_RECTANGULAR,\
    \ true);\\n\tsizes_toolbar->ToggleTool(TOOLBAR_SIZES_1, true);\\n\\n\tmanager->AddPane(standard_toolbar, wxAuiPaneInfo().Name(STANDARD_BAR_NAME).ToolbarPane().Top().Row(1).Position(1).Floatable(false));\\n\tmanager->AddPane(brushes_toolbar, wxAuiPaneInfo().Name(BRUSHES_BAR_NAME).ToolbarPane().Top().Row(1).Position(2).Floatable(false));\\n\tmanager->AddPane(position_toolbar, wxAuiPaneInfo().Name(POSITION_BAR_NAME).ToolbarPane().Top().Row(1).Position(4).Floatable(false));\\n\tmanager->AddPane(sizes_toolbar, wxAuiPaneInfo().Name(SIZES_BAR_NAME).ToolbarPane().Top().Row(1).Position(3).Floatable(false));\\n\\n\tstandard_toolbar->Bind(wxEVT_COMMAND_MENU_SELECTED, &MainToolBar::OnStandardButtonClick, this);\\n\tbrushes_toolbar->Bind(wxEVT_COMMAND_MENU_SELECTED, &MainToolBar::OnBrushesButtonClick, this);\\n\tx_control->Bind(wxEVT_TEXT_PASTE, &MainToolBar::OnPastePositionText, this);\\n\tx_control->Bind(wxEVT_KEY_UP, &MainToolBar::OnPositionKeyUp, this);\\n\ty_control->Bind(wxEVT_TEXT_PASTE, &MainToolBar::OnPastePositionText,\
    \ this);\\n\ty_control->Bind(wxEVT_KEY_UP, &MainToolBar::OnPositionKeyUp, this);\\n\tz_control->Bind(wxEVT_TEXT_PASTE, &MainToolBar::OnPastePositionText, this);\\n\tz_control->Bind(wxEVT_KEY_UP, &MainToolBar::OnPositionKeyUp, this);\\n\tgo_button->Bind(wxEVT_BUTTON, &MainToolBar::OnPositionButtonClick, this);\\n\tsizes_toolbar->Bind(wxEVT_COMMAND_MENU_SELECTED, &MainToolBar::OnSizesButtonClick, this);\\n\\n\tHideAll();\\n}"
- file_path: wxwidgets/main_toolbar.h
  description: Header for `MainToolBar`.
  md5_hash: 6c066361904aa69e0da0209d4a7a2eca
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#ifndef RME_MAINTOOLBAR_H_\\n#define\
    \ RME_MAINTOOLBAR_H_\\n\\n#include <wx/wx.h>\\n#include <wx/aui/aui.h>\\n#include <wx/aui/auibar.h>\\n\\n#include \"gui_ids.h\"\\n#include \"numbertextctrl.h\"\\n\\nclass MainToolBar : public wxEvtHandler {\\npublic:\\n\tMainToolBar(wxWindow* parent, wxAuiManager* manager);\\n\t~MainToolBar();\\n\\n\twxAuiPaneInfo& GetPane(ToolBarID id);\\n\tvoid UpdateButtons();\\n\tvoid UpdateBrushButtons();\\n\tvoid UpdateBrushSize(BrushShape shape, int size);\\n\tvoid Show(ToolBarID id, bool show);\\n\tvoid HideAll(bool update = true);\\n\tvoid LoadPerspective();\\n\tvoid SavePerspective();\\n\tvoid RegisterHotkeys();\\n\\n\tvoid OnStandardButtonClick(wxCommandEvent& event);\\n\tvoid OnBrushesButtonClick(wxCommandEvent& event);\\n\tvoid OnPositionButtonClick(wxCommandEvent& event);\\n\tvoid OnPositionKeyUp(wxKeyEvent& event);\\n\tvoid OnPastePositionText(wxClipboardTextEvent& event);\\n\tvoid OnSizesButtonClick(wxCommandEvent& event);\\n\\nprivate:\\n\tstatic const wxString STANDARD_BAR_NAME;\\n\t\
    static const wxString BRUSHES_BAR_NAME;\\n\tstatic const wxString POSITION_BAR_NAME;\\n\tstatic const wxString SIZES_BAR_NAME;\\n\\n\twxAuiToolBar* standard_toolbar;\\n\twxAuiToolBar* brushes_toolbar;\\n\twxAuiToolBar* position_toolbar;\\n\tNumberTextCtrl* x_control;\\n\tNumberTextCtrl* y_control;\\n\tNumberTextCtrl* z_control;\\n\twxButton* go_button;\\n\twxAuiToolBar* sizes_toolbar;\\n};\\n\\n#endif // RME_MAINTOOLBAR_H_"
- file_path: wxwidgets/palette_window.cpp
  description: Implements `PaletteWindow`, a `wxPanel` containing a `wxChoicebook` to switch between different palette types (Terrain, Doodad, Item, Creature, House, Waypoint, RAW). Manages creation and state of these individual palette panels.
  md5_hash: 2dbb8e0e1caddb9b074ee1b69196ff4d
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#include \"main.h\"\\n\\n#include \"\
    settings.h\"\\n#include \"gui.h\"\\n#include \"brush.h\"\\n#include \"map_display.h\"\\n\\n#include \"palette_window.h\"\\n#include \"palette_brushlist.h\"\\n#include \"palette_house.h\"\\n#include \"palette_creature.h\"\\n#include \"palette_waypoints.h\"\\n\\n#include \"house_brush.h\"\\n#include \"map.h\"\\n\\n// ============================================================================\\n// Palette window\\n\\nBEGIN_EVENT_TABLE(PaletteWindow, wxPanel)\\nEVT_CHOICEBOOK_PAGE_CHANGING(PALETTE_CHOICEBOOK, PaletteWindow::OnSwitchingPage)\\nEVT_CHOICEBOOK_PAGE_CHANGED(PALETTE_CHOICEBOOK, PaletteWindow::OnPageChanged)\\nEVT_CLOSE(PaletteWindow::OnClose)\\n\\nEVT_KEY_DOWN(PaletteWindow::OnKey)\\nEVT_TEXT(wxID_ANY, PaletteWindow::OnActionIDChange)\\nEVT_CHECKBOX(wxID_ANY, PaletteWindow::OnActionIDToggle)\\nEND_EVENT_TABLE()\\n\\nPaletteWindow::PaletteWindow(wxWindow* parent, const TilesetContainer& tilesets) :\\n\twxPanel(parent, wxID_ANY, wxDefaultPosition, wxSize(230, 250)),\\n\tchoicebook(nullptr),\\\
    n\tterrain_palette(nullptr),\\n\tdoodad_palette(nullptr),\\n\titem_palette(nullptr),\\n\tcollection_palette(nullptr),\\n\tcreature_palette(nullptr),\\n\thouse_palette(nullptr),\\n\twaypoint_palette(nullptr),\\n\traw_palette(nullptr),\\n\taction_id_input(nullptr),\\n\taction_id_checkbox(nullptr),\\n\taction_id(0),\\n\taction_id_enabled(false) {\\n\t\\n\t// Allow resizing but maintain minimum size\\n\tSetMinSize(wxSize(225, 250));\\n\t\\n\t// Create main sizer\\n\twxSizer* main_sizer = new wxBoxSizer(wxVERTICAL);\\n\\n\t// Create action ID controls\\n\twxSizer* action_id_sizer = new wxBoxSizer(wxHORIZONTAL);\\n\taction_id_input = new wxTextCtrl(this, wxID_ANY, \"0\", wxDefaultPosition, wxSize(60, -1));\\n\taction_id_input->SetToolTip(\"Enter action ID (0-65535)\");\\n\taction_id_checkbox = new wxCheckBox(this, wxID_ANY, \"Enable Action ID\");\\n\taction_id_checkbox->SetToolTip(\"When enabled, placed items will have this action ID\");\\n\t\\n\taction_id_sizer->Add(action_id_input, 0, wxALIGN_CENTER_VERTICAL\
    \ | wxRIGHT, 5);\\n\taction_id_sizer->Add(action_id_checkbox, 0, wxALIGN_CENTER_VERTICAL);\\n\t\\n\tmain_sizer->Add(action_id_sizer, 0, wxEXPAND | wxALL, 5);\\n\t\\n\t// Create choicebook with EXPAND flag to fill available space\\n\tchoicebook = new wxChoicebook(this, PALETTE_CHOICEBOOK, wxDefaultPosition, wxDefaultSize);\\n\\n\tterrain_palette = static_cast<BrushPalettePanel*>(CreateTerrainPalette(choicebook, tilesets));\\n\tchoicebook->AddPage(terrain_palette, terrain_palette->GetName());\\n\\n\tdoodad_palette = static_cast<BrushPalettePanel*>(CreateDoodadPalette(choicebook, tilesets));\\n\tchoicebook->AddPage(doodad_palette, doodad_palette->GetName());\\n\\n\tcollection_palette = static_cast<BrushPalettePanel*>(CreateCollectionPalette(choicebook, tilesets));\\n\tchoicebook->AddPage(collection_palette, collection_palette->GetName());\\n\\n\titem_palette = static_cast<BrushPalettePanel*>(CreateItemPalette(choicebook, tilesets));\\n\tchoicebook->AddPage(item_palette, item_palette->GetName());\\\
    n\\n\thouse_palette = static_cast<HousePalettePanel*>(CreateHousePalette(choicebook, tilesets));\\n\tchoicebook->AddPage(house_palette, house_palette->GetName());\\n\\n\twaypoint_palette = static_cast<WaypointPalettePanel*>(CreateWaypointPalette(choicebook, tilesets));\\n\tchoicebook->AddPage(waypoint_palette, waypoint_palette->GetName());\\n\\n\tcreature_palette = static_cast<CreaturePalettePanel*>(CreateCreaturePalette(choicebook, tilesets));\\n\tchoicebook->AddPage(creature_palette, creature_palette->GetName());\\n\\n\traw_palette = static_cast<BrushPalettePanel*>(CreateRAWPalette(choicebook, tilesets));\\n\tchoicebook->AddPage(raw_palette, raw_palette->GetName());\\n\\n\t// Add choicebook to main sizer\\n\tmain_sizer->Add(choicebook, 1, wxEXPAND | wxALL, 2);\\n\tSetSizer(main_sizer);\\n\\n\t// Load first page\\n\tLoadCurrentContents();\\n}\\n\\nPaletteWindow::~PaletteWindow() {\\n\t// Clean up all brushes and caches in each palette panel\\n\tif (choicebook) {\\n\t\t// Ensure each\
    \ panel type is properly cleaned up\\n\t\tif (terrain_palette) {\\n\t\t\tterrain_palette->DestroyAllCaches();\\n\t\t}\\n\t\tif (doodad_palette) {\\n\t\t\tdoodad_palette->DestroyAllCaches();\\n\t\t}\\n\t\tif (item_palette) {\\n\t\t\titem_palette->DestroyAllCaches();\\n\t\t}\\n\t\tif (collection_palette) {\\n\t\t\tcollection_palette->DestroyAllCaches();\\n\t\t}\\n\t\tif (raw_palette) {\\n\t\t\traw_palette->DestroyAllCaches();\\n\t\t}\\n\t\t\\n\t\t// Other palette types may need specific cleanup\\n\t\tfor (size_t iz = 0; iz < choicebook->GetPageCount(); ++iz) {\\n\t\t\tPalettePanel* panel = dynamic_cast<PalettePanel*>(choicebook->GetPage(iz));\\n\t\t\tif (panel) {\\n\t\t\t\tpanel->InvalidateContents();\\n\t\t\t}\\n\t\t}\\n\t}\\n}\\n\\nPalettePanel* PaletteWindow::CreateTerrainPalette(wxWindow* parent, const TilesetContainer& tilesets) {\\n\tBrushPalettePanel* panel = newd BrushPalettePanel(parent, tilesets, TILESET_TERRAIN);\\n\tpanel->SetListType(wxstr(g_settings.getString(Config::PALETTE_TERRAIN_STYLE)));\\\
    n\\n\tBrushToolPanel* tool_panel = newd BrushToolPanel(panel);\\n\ttool_panel->SetToolbarIconSize(g_settings.getBoolean(Config::USE_LARGE_TERRAIN_TOOLBAR));\\n\tpanel->AddToolPanel(tool_panel);\\n\\n\tBrushSizePanel* size_panel = newd BrushSizePanel(panel);\\n\tsize_panel->SetToolbarIconSize(g_settings.getBoolean(Config::USE_LARGE_TERRAIN_TOOLBAR));\\n\tpanel->AddToolPanel(size_panel);\\n\t\\n\tZoneBrushPanel* zone_brush_panel = newd ZoneBrushPanel(panel);\\n\tzone_brush_panel->SetToolbarIconSize(g_settings.getBoolean(Config::USE_LARGE_TERRAIN_TOOLBAR));\\n\tpanel->AddToolPanel(zone_brush_panel);\\n\\n\treturn panel;\\n}\\n\\nPalettePanel* PaletteWindow::CreateCollectionPalette(wxWindow* parent, const TilesetContainer& tilesets) {\\n\tBrushPalettePanel* panel = newd BrushPalettePanel(parent, tilesets, TILESET_COLLECTION);\\n\tpanel->SetListType(wxstr(g_settings.getString(Config::PALETTE_COLLECTION_STYLE)));\\n\\n\t// terrain palette tools\\n\tBrushToolPanel* tool_panel = newd BrushToolPanel(panel);\\\
    n\ttool_panel->SetToolbarIconSize(g_settings.getBoolean(Config::USE_LARGE_COLLECTION_TOOLBAR));\\n\tpanel->AddToolPanel(tool_panel);\\n\\n\t// brush thickness panel\\n\tpanel->AddToolPanel(newd BrushThicknessPanel(panel));\\n\\n\t// brush size tools\\n\tBrushSizePanel* size_panel = newd BrushSizePanel(panel);\\n\tsize_panel->SetToolbarIconSize(g_settings.getBoolean(Config::USE_LARGE_COLLECTION_TOOLBAR));\\n\tpanel->AddToolPanel(size_panel);\\n\\n\treturn panel;\\n}\\n\\nPalettePanel* PaletteWindow::CreateDoodadPalette(wxWindow* parent, const TilesetContainer& tilesets) {\\n\tBrushPalettePanel* panel = newd BrushPalettePanel(parent, tilesets, TILESET_DOODAD);\\n\tpanel->SetListType(wxstr(g_settings.getString(Config::PALETTE_DOODAD_STYLE)));\\n\\n\tpanel->AddToolPanel(newd BrushThicknessPanel(panel));\\n\\n\tBrushSizePanel* size_panel = newd BrushSizePanel(panel);\\n\tsize_panel->SetToolbarIconSize(g_settings.getBoolean(Config::USE_LARGE_DOODAD_SIZEBAR));\\n\tpanel->AddToolPanel(size_panel);\\\
    n\\n\treturn panel;\\n}\\n\\nPalettePanel* PaletteWindow::CreateItemPalette(wxWindow* parent, const TilesetContainer& tilesets) {\\n\tBrushPalettePanel* panel = newd BrushPalettePanel(parent, tilesets, TILESET_ITEM);\\n\tpanel->SetListType(wxstr(g_settings.getString(Config::PALETTE_ITEM_STYLE)));"
- file_path: wxwidgets/palette_window.h
  description: Header for `PaletteWindow`.
  md5_hash: 5da4ca64355302005659520d1aa4c96e
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#ifndef RME_PALETTE_H_\\n#define RME_PALETTE_H_\\\
    n\\n#include \"palette_common.h\"\\n\\nclass BrushPalettePanel;\\nclass CreaturePalettePanel;\\nclass HousePalettePanel;\\nclass WaypointPalettePanel;\\n\\nclass PaletteWindow : public wxPanel {\\npublic:\\n\tPaletteWindow(wxWindow* parent, const TilesetContainer& tilesets);\\n\t~PaletteWindow();\\n\\n\t// Interface\\n\t// Reloads layout g_settings from g_settings (and using map)\\n\tvoid ReloadSettings(Map* from);\\n\t// Flushes all pages and forces them to be reloaded from the palette data again\\n\tvoid InvalidateContents();\\n\t// (Re)Loads all currently displayed data, called from InvalidateContents implicitly\\n\tvoid LoadCurrentContents();\\n\t// Goes to the selected page and selects any brush there\\n\tvoid SelectPage(PaletteType palette);\\n\t// The currently selected brush in this palette\\n\tBrush* GetSelectedBrush() const;\\n\t// The currently selected brush size in this palette\\n\tint GetSelectedBrushSize() const;\\n\t// The currently selected page (terrain, doodad...)\\\
    n\tPaletteType GetSelectedPage() const;\\n\\n\t// Get the current action ID value\\n\tuint16_t GetActionID() const { return action_id; }\\n\t// Check if action ID is enabled\\n\tbool IsActionIDEnabled() const { return action_id_enabled; }\\n\\n\t// Custom Event handlers (something has changed?)\\n\t// Finds the brush pointed to by whatbrush and selects it as the current brush (also changes page)\\n\t// Returns if the brush was found in this palette\\n\tvirtual bool OnSelectBrush(const Brush* whatbrush, PaletteType primary = TILESET_UNKNOWN);\\n\t// Updates the palette window to use the current brush size\\n\tvirtual void OnUpdateBrushSize(BrushShape shape, int size);\\n\t// Updates the content of the palette (eg. houses, creatures)\\n\tvirtual void OnUpdate(Map* map);\\n\\n\t// wxWidgets Event Handlers\\n\tvoid OnSwitchingPage(wxChoicebookEvent& event);\\n\tvoid OnPageChanged(wxChoicebookEvent& event);\\n\t// Forward key events to the parent window (The Map Window)\\n\tvoid OnKey(wxKeyEvent&\
    \ event);\\n\tvoid OnClose(wxCloseEvent&);\\n\tvoid OnActionIDChange(wxCommandEvent& event);\\n\tvoid OnActionIDToggle(wxCommandEvent& event);\\n\\nprotected:\\n\tstatic PalettePanel* CreateTerrainPalette(wxWindow* parent, const TilesetContainer& tilesets);\\n\tstatic PalettePanel* CreateDoodadPalette(wxWindow* parent, const TilesetContainer& tilesets);\\n\tstatic PalettePanel* CreateItemPalette(wxWindow* parent, const TilesetContainer& tilesets);\\n\tstatic PalettePanel* CreateCollectionPalette(wxWindow* parent, const TilesetContainer& tilesets);\\n\tstatic PalettePanel* CreateCreaturePalette(wxWindow* parent, const TilesetContainer& tilesets);\\n\tstatic PalettePanel* CreateHousePalette(wxWindow* parent, const TilesetContainer& tilesets);\\n\tstatic PalettePanel* CreateWaypointPalette(wxWindow* parent, const TilesetContainer& tilesets);\\n\tstatic PalettePanel* CreateRAWPalette(wxWindow* parent, const TilesetContainer& tilesets);\\n\\n\twxChoicebook* choicebook;\\n\\n\tBrushPalettePanel*\
    \ terrain_palette;\\n\tBrushPalettePanel* doodad_palette;\\n\tBrushPalettePanel* item_palette;\\n\tBrushPalettePanel* collection_palette;\\n\tCreaturePalettePanel* creature_palette;\\n\tHousePalettePanel* house_palette;\\n\tWaypointPalettePanel* waypoint_palette;\\n\tBrushPalettePanel* raw_palette;\\n\\n\t// Action ID controls\\n\twxTextCtrl* action_id_input;\\n\twxCheckBox* action_id_checkbox;\\n\tuint16_t action_id;\\n\tbool action_id_enabled;\\n\\n\tDECLARE_EVENT_TABLE()\\n};\\n\\n#endif"
- file_path: wxwidgets/palette_brushlist.cpp
  description: Implements `BrushPalettePanel` (generic panel for Terrain, Doodad, Item, etc., palettes, containing another `wxChoicebook` for tilesets) and `BrushPanel` (displays brushes from a specific tileset category using different view modes like lists or icon grids, including `DirectDrawBrushPanel` and `SeamlessGridPanel`).
  md5_hash: 339d6c6bef52cba1729f9336976346a2
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#include \"main.h\"\\n\\n#include <set>\\\
    n#include <algorithm> // Add this for std::min\\n#include \"palette_brushlist.h\"\\n#include \"gui.h\"\\n#include \"brush.h\"\\n#include \"raw_brush.h\"\\n#include \"add_tileset_window.h\"\\n#include \"add_item_window.h\"\\n#include \"materials.h\"\\n#include \"border_editor_window.h\"\\n\\n// Define BrushPanelState class at the top of the file\\nclass BrushPanelState {\\npublic:\\n\tBrushBoxInterface* grid_view;\\n\tBrushBoxInterface* list_view;\\n\twxBoxSizer* zoom_sizer;\\n\twxStaticText* zoom_value_label;\\n\tbool grid_view_shown;\\n\t\\n\tBrushPanelState() : grid_view(nullptr), list_view(nullptr), zoom_sizer(nullptr), \\n\t\t\t\t\t   zoom_value_label(nullptr), grid_view_shown(false) {}\\n\t\t\t\t\t   \\n\t~BrushPanelState() {}\\n};\\n\\n// Keep a static map of constructed brush panels by tileset\\nstd::map<const TilesetCategory*, BrushPanelState> g_brush_panel_cache;\\n\\n// ============================================================================\\n// Brush Palette Panel\\n//\
    \ A common class for terrain/doodad/item/raw palette\\n\\nBEGIN_EVENT_TABLE(BrushPalettePanel, PalettePanel)\\n\tEVT_BUTTON(wxID_ADD, BrushPalettePanel::OnClickAddItemTileset)\\n\tEVT_BUTTON(wxID_NEW, BrushPalettePanel::OnClickAddTileset)\\n\tEVT_BUTTON(BUTTON_QUICK_ADD_ITEM, BrushPalettePanel::OnClickQuickAddItemTileset)\\n\tEVT_BUTTON(BUTTON_ADD_BORDER, BrushPalettePanel::OnClickCreateBorder)\\n\tEVT_CHOICEBOOK_PAGE_CHANGING(wxID_ANY, BrushPalettePanel::OnSwitchingPage)\\n\tEVT_CHOICEBOOK_PAGE_CHANGED(wxID_ANY, BrushPalettePanel::OnPageChanged)\\nEND_EVENT_TABLE()\\n\\nBrushPalettePanel::BrushPalettePanel(wxWindow* parent, const TilesetContainer& tilesets, TilesetCategoryType category, wxWindowID id) :\\n\tPalettePanel(parent, id),\\n\tpalette_type(category),\\n\tchoicebook(nullptr),\\n\tsize_panel(nullptr),\\n\tquick_add_button(nullptr),\\n\tlast_tileset_name(\"\") {\\n\twxSizer* topsizer = newd wxBoxSizer(wxVERTICAL);\\n\\n\t// Create the tileset panel\\n\twxSizer* ts_sizer = newd\
    \ wxStaticBoxSizer(wxVERTICAL, this, \"Tileset\");\\n\twxChoicebook* tmp_choicebook = newd wxChoicebook(this, wxID_ANY, wxDefaultPosition, wxSize(180, 250));\\n\tts_sizer->Add(tmp_choicebook, 1, wxEXPAND);\\n\ttopsizer->Add(ts_sizer, 1, wxEXPAND);\\n\\n\tif (g_settings.getBoolean(Config::SHOW_TILESET_EDITOR)) {\\n\t\t// Create a vertical sizer to hold the two rows of buttons\\n\t\twxSizer* buttonSizer = newd wxBoxSizer(wxVERTICAL);\\n\t\t\\n\t\t// First row - Add Tileset and Add Item\\n\t\twxSizer* firstRowSizer = newd wxBoxSizer(wxHORIZONTAL);\\n\t\twxButton* buttonAddTileset = newd wxButton(this, wxID_NEW, \"Add new Tileset\");\\n\t\tfirstRowSizer->Add(buttonAddTileset, wxSizerFlags(1).Expand());\\n\t\t\\n\t\twxButton* buttonAddItemToTileset = newd wxButton(this, wxID_ADD, \"Add new Item\");\\n\t\tfirstRowSizer->Add(buttonAddItemToTileset, wxSizerFlags(1).Expand());\\n\t\t\\n\t\t// Add first row to the button sizer\\n\t\tbuttonSizer->Add(firstRowSizer, wxSizerFlags(0).Expand());\\\
    n\t\t\\n\t\t// Add a small space between rows\\n\t\tbuttonSizer->AddSpacer(5);\\n\t\t\\n\t\t// Second row - Quick Add Item and Create Border\\n\t\twxSizer* secondRowSizer = newd wxBoxSizer(wxHORIZONTAL);\\n\t\t\\n\t\t// Create the Quick Add Item button, initially disabled\\n\t\tquick_add_button = newd wxButton(this, BUTTON_QUICK_ADD_ITEM, \"Quick Add Item\");\\n\t\tquick_add_button->SetToolTip(\"Quickly add the currently selected brush to the last used tileset\");\\n\t\tquick_add_button->Enable(false); // Disabled until a tileset is added\\n\t\tsecondRowSizer->Add(quick_add_button, wxSizerFlags(1).Expand());\\n\t\t\\n\t\t// Create Border button\\n\t\twxButton* buttonCreateBorder = newd wxButton(this, BUTTON_ADD_BORDER, \"Create Border\");\\n\t\tbuttonCreateBorder->SetToolTip(\"Open the Border Editor to create or edit auto-borders\");\\n\t\tsecondRowSizer->Add(buttonCreateBorder, wxSizerFlags(1).Expand());\\n\t\t\\n\t\t// Add second row to the button sizer\\n\t\tbuttonSizer->Add(secondRowSizer,\
    \ wxSizerFlags(0).Expand());\\n\t\t\\n\t\t// Add the complete button sizer to the top sizer\\n\t\ttopsizer->Add(buttonSizer, 0, wxEXPAND | wxALL, 5);\\n\t}\\n\\n\tfor (TilesetContainer::const_iterator iter = tilesets.begin(); iter != tilesets.end(); ++iter) {\\n\t\tconst TilesetCategory* tcg = iter->second->getCategory(category);\\n\t\tif (tcg && tcg->size() > 0) {\\n\t\t\tBrushPanel* panel = newd BrushPanel(tmp_choicebook);\\n\t\t\tpanel->AssignTileset(tcg);\\n\t\t\ttmp_choicebook->AddPage(panel, wxstr(iter->second->name));\\n\t\t}\\n\t}\\n\\n\tSetSizerAndFit(topsizer);\\n\\n\tchoicebook = tmp_choicebook;\\n}\\n\\nBrushPalettePanel::~BrushPalettePanel() {\\n\t// Ensure all caches are destroyed\\n\tDestroyAllCaches();\\n}\\n\\nvoid BrushPalettePanel::DestroyAllCaches() {\\n\t// Force cleanup of all panels to prevent memory leaks when application exits\\n\tif (choicebook) {\\n\t\tfor (size_t iz = 0; iz < choicebook->GetPageCount(); ++iz) {\\n\t\t\tBrushPanel* panel = dynamic_cast<BrushPanel*>(choicebook->GetPage(iz));\\\
    n\t\t\tif (panel) {\\n\t\t\t\tpanel->InvalidateContents();\\n\t\t\t}\\n\t\t}\\n\t}\\n\t\\n\t// Clear remembered brushes\\n\tremembered_brushes.clear();\\n}\\n\\nvoid BrushPalettePanel::InvalidateContents() {\\n\tfor (size_t iz = 0; iz < choicebook->GetPageCount(); ++iz) {\\n\t\tBrushPanel* panel = dynamic_cast<BrushPanel*>(choicebook->GetPage(iz));\\n\t\tpanel->InvalidateContents();\\n\t}\\n\tPalettePanel::InvalidateContents();\\n}\\n\\nvoid BrushPalettePanel::LoadCurrentContents() {\\n\twxWindow* page = choicebook->GetCurrentPage();\\n\tBrushPanel* panel = dynamic_cast<BrushPanel*>(page);\\n\tif (panel) {\\n\t\tpanel->OnSwitchIn();\\n\t}\\n\tPalettePanel::LoadCurrentContents();\\n}\\n\\nvoid BrushPalettePanel::LoadAllContents() {\\n\tfor (size_t iz = 0; iz < choicebook->GetPageCount(); ++iz) {\\n\t\tBrushPanel* panel = dynamic_cast<BrushPanel*>(choicebook->GetPage(iz));\\n\t\tpanel->LoadContents();\\n\t}\\n\tPalettePanel::LoadAllContents();\\n}\\n\\nPaletteType BrushPalettePanel::GetType()\
    \ const {\\n\treturn palette_type;\\n}\\n\\nvoid BrushPalettePanel::SetListType(wxString ltype) {\\n\tif (!choicebook) {\\n\t\treturn;\\n\t}\\n\tfor (size_t iz = 0; iz < choicebook->GetPageCount(); ++iz) {\\n\t\tBrushPanel* panel = dynamic_cast<BrushPanel*>(choicebook->GetPage(iz));\\n\t\tpanel->SetListType(ltype);\\n\t}\\n}\\n\\nBrush* BrushPalettePanel::GetSelectedBrush() const {\\n\tif (!choicebook) {\\n\t\treturn nullptr;\\n\t}\\n\twxWindow* page = choicebook->GetCurrentPage();\\n\tBrushPanel* panel = dynamic_cast<BrushPanel*>(page);\\n\tBrush* res = nullptr;\\n\tif (panel) {\\n\t\tfor (ToolBarList::const_iterator iter = tool_bars.begin(); iter != tool_bars.end(); ++iter) {\\n\t\t\tres = (*iter)->GetSelectedBrush();\\n\t\t\tif (res) {\\n\t\t\t\treturn res;"
- file_path: wxwidgets/palette_brushlist.h
  description: Header for `BrushPalettePanel`, `BrushPanel`, and various brush display interfaces/classes (`BrushBoxInterface`, `BrushListBox`, `BrushIconBox`, `DirectDrawBrushPanel`, `SeamlessGridPanel`).
  md5_hash: b863ba13d1dd1df20eb76fde0628ebc7
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#ifndef RME_PALETTE_BRUSHLIST_H_\\\
    n#define RME_PALETTE_BRUSHLIST_H_\\n\\n#include <wx/panel.h>\\n#include <wx/listctrl.h>\\n#include <wx/vscroll.h>\\n#include <wx/timer.h>\\n#include <wx/dcbuffer.h>\\n#include <wx/sizer.h>\\n#include <wx/checkbox.h>\\n#include <wx/choice.h>\\n#include <wx/choicebk.h>\\n\\n#include <map>\\n#include <set>\\n#include <vector>\\n\\n#include \"tileset.h\"\\n#include \"palette_common.h\"\\n\\n// Forward declarations\\nclass ItemPalettePanel;\\nclass BrushPalettePanel;\\nclass BrushButton;\\nclass BrushPanel;\\nclass BrushBoxInterface;\\n\\nenum BrushListType {\\n\tBRUSHLIST_LARGE_ICONS,\\n\tBRUSHLIST_SMALL_ICONS,\\n\tBRUSHLIST_LISTBOX,\\n\tBRUSHLIST_TEXT_LISTBOX,\\n\tBRUSHLIST_GRID,\\n\tBRUSHLIST_DIRECT_DRAW,\\n\tBRUSHLIST_SEAMLESS_GRID\\n};\\n\\nenum {\\n\tPALETTE_LAYOUT_STYLE_BORDER,\\n\tPALETTE_LAYOUT_STYLE_LARGE,\\n\tPALETTE_LAYOUT_STYLE_LISTBOX,\\n\tPALETTE_LAYOUT_STYLE_NEWUI,\\n\tBUTTON_QUICK_ADD_ITEM,\\n\tBUTTON_ADD_BORDER\\n};\\n\\n// Custom ID for Quick Add button\\n#define BUTTON_QUICK_ADD_ITEM\
    \ 1001\\n#define BUTTON_ADD_BORDER 1002\\n\\nclass BrushBoxInterface {\\npublic:\\n\tBrushBoxInterface(const TilesetCategory* _tileset) :\\n\t\ttileset(_tileset), loaded(false) {\\n\t\tASSERT(tileset);\\n\t}\\n\tvirtual ~BrushBoxInterface() { }\\n\\n\tvirtual wxWindow* GetSelfWindow() = 0;\\n\\n\t// Select the first brush\\n\tvirtual void SelectFirstBrush() = 0;\\n\t// Returns the currently selected brush (First brush if panel is not loaded)\\n\tvirtual Brush* GetSelectedBrush() const = 0;\\n\t// Select the brush in the parameter, this only changes the look of the panel\\n\tvirtual bool SelectBrush(const Brush* brush) = 0;\\n\\nprotected:\\n\tconst TilesetCategory* tileset;\\n\tbool loaded;\\n};\\n\\n// New class for direct drawing of sprites in grid\\nclass DirectDrawBrushPanel : public wxScrolledWindow, public BrushBoxInterface {\\npublic:\\n\tDirectDrawBrushPanel(wxWindow* parent, const TilesetCategory* _tileset);\\n\t~DirectDrawBrushPanel();\\n\\n\twxWindow* GetSelfWindow() { return\
    \ this; }\\n\\n\t// Select the first brush\\n\tvoid SelectFirstBrush();\\n\t// Returns the currently selected brush\\n\tBrush* GetSelectedBrush() const;\\n\t// Select the brush in the parameter\\n\tbool SelectBrush(const Brush* brush);\\n\\n\t// Event handling\\n\tvoid OnMouseClick(wxMouseEvent& event);\\n\tvoid OnPaint(wxPaintEvent& event);\\n\tvoid OnSize(wxSizeEvent& event);\\n\tvoid OnScroll(wxScrollWinEvent& event);\\n\tvoid OnTimer(wxTimerEvent& event);\\n\t\\n\t// Make timer accessible\\n\twxTimer* loading_timer;\\n\\nprotected:\\n\tvoid RecalculateGrid();\\n\tvoid DrawItemsToPanel(wxDC& dc);\\n\tvoid UpdateViewableItems(); // Method for lazy loading visible items\\n\tvoid StartProgressiveLoading(); // Method for progressive loading with visual feedback\\n\\nprotected:\\n\tint columns;\\n\tint item_width;\\n\tint item_height;\\n\tint selected_index;\\n\twxBitmap* buffer;\\n\t\\n\t// Lazy loading properties\\n\tint first_visible_row;\\n\tint last_visible_row;\\n\tint visible_rows_margin;\
    \ // Extra rows to load above/below viewport\\n\tint total_rows;\\n\tbool need_full_redraw;\\n\t\\n\t// Progressive loading properties\\n\tbool use_progressive_loading;\\n\tbool is_large_tileset;\\n\tint loading_step;\\n\tint max_loading_steps;\\n\t// Moved loading_timer to public section\\n\\n\tstatic const int LARGE_TILESET_THRESHOLD = 1000; // Number of items considered \"large\"\\n\\n\tDECLARE_EVENT_TABLE();\\n};\\n\\nclass BrushListBox : public wxVListBox, public BrushBoxInterface {\\npublic:\\n\tBrushListBox(wxWindow* parent, const TilesetCategory* _tileset);\\n\t~BrushListBox();\\n\\n\twxWindow* GetSelfWindow() {\\n\t\treturn this;\\n\t}\\n\\n\t// Select the first brush\\n\tvoid SelectFirstBrush();\\n\t// Returns the currently selected brush (First brush if panel is not loaded)\\n\tBrush* GetSelectedBrush() const;\\n\t// Select the brush in the parameter, this only changes the look of the panel\\n\tbool SelectBrush(const Brush* brush);\\n\\n\t// Event handlers\\n\tvirtual void\
    \ OnDrawItem(wxDC& dc, const wxRect& rect, size_t n) const;\\n\tvirtual wxCoord OnMeasureItem(size_t n) const;\\n\\n\tvoid OnKey(wxKeyEvent& event);\\n\\n\tDECLARE_EVENT_TABLE();\\n};\\n\\nclass BrushIconBox : public wxScrolledWindow, public BrushBoxInterface {\\npublic:\\n\tBrushIconBox(wxWindow* parent, const TilesetCategory* _tileset, RenderSize rsz);\\n\t~BrushIconBox();\\n\\n\twxWindow* GetSelfWindow() {\\n\t\treturn this;\\n\t}\\n\\n\t// Scrolls the window to the position of the named brush button\\n\tvoid EnsureVisible(BrushButton* btn);\\n\tvoid EnsureVisible(size_t n);\\n\\n\t// Select the first brush\\n\tvoid SelectFirstBrush();\\n\t// Returns the currently selected brush (First brush if panel is not loaded)\\n\tBrush* GetSelectedBrush() const;\\n\t// Select the brush in the parameter, this only changes the look of the panel\\n\tbool SelectBrush(const Brush* brush);\\n\\n\t// Event handling...\\n\tvoid OnClickBrushButton(wxCommandEvent& event);\\n\\nprotected:\\n\t// Used internally\
    \ to deselect all buttons before selecting a newd one.\\n\tvoid DeselectAll();\\n\\nprotected:\\n\tstd::vector<BrushButton*> brush_buttons;"
- file_path: wxwidgets/palette_creature.cpp
  description: Implements `CreaturePalettePanel`, specialized for selecting creature brushes and spawn settings. Includes search, view toggles (list/sprite), and NPC/Monster file loading.
  md5_hash: dcfacc5c3ac128f3b97c82b1d808e3b9
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#include \"main.h\"\\n\\n#include \"\
    settings.h\"\\n#include \"brush.h\"\\n#include \"gui.h\"\\n#include \"palette_creature.h\"\\n#include \"creature_brush.h\"\\n#include \"spawn_brush.h\"\\n#include \"materials.h\"\\n#include <wx/dir.h>\\n#include <wx/filefn.h>\\n#include <wx/textdlg.h>\\n#include \"creature_sprite_manager.h\"\\n\\n// Define the new event ID for the Load NPCs button\\n#define PALETTE_LOAD_NPCS_BUTTON 1952\\n#define PALETTE_LOAD_MONSTERS_BUTTON 1953\\n#define PALETTE_PURGE_CREATURES_BUTTON 1954\\n#define PALETTE_SEARCH_BUTTON 1955\\n#define PALETTE_SEARCH_FIELD 1956\\n#define PALETTE_VIEW_TOGGLE_BUTTON 1957\\n#define PALETTE_CREATURE_LARGE_SPRITES_TOGGLE 1958\\n#define PALETTE_CREATURE_ZOOM_BUTTON 1959\\n\\n// ============================================================================\\n// Creature palette\\n\\nBEGIN_EVENT_TABLE(CreaturePalettePanel, PalettePanel)\\nEVT_CHOICE(PALETTE_CREATURE_TILESET_CHOICE, CreaturePalettePanel::OnTilesetChange)\\nEVT_LISTBOX(PALETTE_CREATURE_LISTBOX, CreaturePalettePanel::OnListBoxChange)\\\
    nEVT_COMMAND(wxID_ANY, wxEVT_COMMAND_LISTBOX_SELECTED, CreaturePalettePanel::OnSpriteSelected)\\nEVT_TOGGLEBUTTON(PALETTE_CREATURE_BRUSH_BUTTON, CreaturePalettePanel::OnClickCreatureBrushButton)\\nEVT_TOGGLEBUTTON(PALETTE_SPAWN_BRUSH_BUTTON, CreaturePalettePanel::OnClickSpawnBrushButton)\\nEVT_TOGGLEBUTTON(PALETTE_VIEW_TOGGLE_BUTTON, CreaturePalettePanel::OnClickViewToggle)\\nEVT_TOGGLEBUTTON(PALETTE_CREATURE_VIEW_STYLE_TOGGLE, CreaturePalettePanel::OnClickViewStyleToggle)\\nEVT_TOGGLEBUTTON(PALETTE_CREATURE_LARGE_SPRITES_TOGGLE, CreaturePalettePanel::OnClickLargeSpritesToggle)\\nEVT_BUTTON(PALETTE_CREATURE_ZOOM_BUTTON, CreaturePalettePanel::OnClickZoomButton)\\nEVT_BUTTON(PALETTE_LOAD_NPCS_BUTTON, CreaturePalettePanel::OnClickLoadNPCsButton)\\nEVT_BUTTON(PALETTE_LOAD_MONSTERS_BUTTON, CreaturePalettePanel::OnClickLoadMonstersButton)\\nEVT_BUTTON(PALETTE_PURGE_CREATURES_BUTTON, CreaturePalettePanel::OnClickPurgeCreaturesButton)\\nEVT_BUTTON(PALETTE_SEARCH_BUTTON, CreaturePalettePanel::OnClickSearchButton)\\\
    nEVT_TEXT(PALETTE_SEARCH_FIELD, CreaturePalettePanel::OnSearchFieldText)\\nEVT_SPINCTRL(PALETTE_CREATURE_SPAWN_TIME, CreaturePalettePanel::OnChangeSpawnTime)\\nEVT_SPINCTRL(PALETTE_CREATURE_SPAWN_SIZE, CreaturePalettePanel::OnChangeSpawnSize)\\nEND_EVENT_TABLE()\\n\\nCreaturePalettePanel::CreaturePalettePanel(wxWindow* parent, wxWindowID id) :\\n\tPalettePanel(parent, id),\\n\ttileset_choice(nullptr),\\n\tcreature_list(nullptr),\\n\tsprite_panel(nullptr),\\n\tseamless_panel(nullptr),\\n\tview_toggle(nullptr),\\n\tview_style_toggle(nullptr),\\n\tlarge_sprites_toggle(nullptr),\\n\tzoom_button(nullptr),\\n\tview_sizer(nullptr),\\n\tuse_sprite_view(false),\\n\tuse_seamless_view(true), // Seamless is now the default\\n\tuse_large_sprites(false),\\n\tzoom_factor(1),\\n\thandling_event(false),\\n\tsearch_field(nullptr),\\n\tsearch_button(nullptr),\\n\tload_npcs_button(nullptr),\\n\tload_monsters_button(nullptr),\\n\tpurge_creatures_button(nullptr),\\n\tcreature_spawntime_spin(nullptr),\\n\t\
    spawn_size_spin(nullptr),\\n\tcreature_brush_button(nullptr),\\n\tspawn_brush_button(nullptr) {\\n\t\\n\t// Create the controls\\n\twxSizer* topsizer = newd wxBoxSizer(wxVERTICAL);\\n\t\\n\twxSizer* sidesizer = newd wxStaticBoxSizer(wxVERTICAL, this, \"Creatures\");\\n\t\\n\t// Tileset choice\\n\ttileset_choice = newd wxChoice(this, PALETTE_CREATURE_TILESET_CHOICE, wxDefaultPosition, wxDefaultSize, 0, nullptr, wxCB_READONLY);\\n\tsidesizer->Add(tileset_choice, 0, wxEXPAND | wxALL, 5);\\n\t\\n\t// Search field\\n\twxBoxSizer* searchSizer = newd wxBoxSizer(wxHORIZONTAL);\\n\tsearchSizer->Add(newd wxStaticText(this, wxID_ANY, \"Search:\"), 0, wxCENTER | wxLEFT, 5);\\n\tsearch_field = newd wxTextCtrl(this, wxID_ANY, \"\", wxDefaultPosition, wxDefaultSize, wxTE_PROCESS_ENTER);\\n\tsearchSizer->Add(search_field, 1, wxCENTER | wxLEFT, 5);\\n\tsearch_button = newd wxButton(this, PALETTE_SEARCH_BUTTON, \"Go\", wxDefaultPosition, wxDefaultSize, wxBU_EXACTFIT);\\n\tsearchSizer->Add(search_button,\
    \ 0, wxLEFT, 5);\\n\tsidesizer->Add(searchSizer, 0, wxEXPAND | wxTOP, 5);\\n\t\\n\t// Connect the focus events to disable hotkeys during typing\\n\tsearch_field->Connect(wxEVT_SET_FOCUS, wxFocusEventHandler(CreaturePalettePanel::OnSearchFieldFocus), nullptr, this);\\n\tsearch_field->Connect(wxEVT_KILL_FOCUS, wxFocusEventHandler(CreaturePalettePanel::OnSearchFieldKillFocus), nullptr, this);\\n\t// Connect key down event to handle key presses in the search field\\n\tsearch_field->Connect(wxEVT_KEY_DOWN, wxKeyEventHandler(CreaturePalettePanel::OnSearchFieldKeyDown), nullptr, this);\\n\\n\t// Create view container that will hold both list and sprite views\\n\tview_sizer = newd wxBoxSizer(wxVERTICAL);\\n\t\\n\t// Create both views\\n\tcreature_list = newd SortableListBox(this, PALETTE_CREATURE_LISTBOX);\\n\tsprite_panel = newd CreatureSpritePanel(this);\\n\tseamless_panel = newd CreatureSeamlessGridPanel(this);\\n\t\\n\t// Add views to sizer (only one will be shown at a time)\\n\tview_sizer->Add(creature_list,\
    \ 1, wxEXPAND);\\n\tview_sizer->Add(sprite_panel, 1, wxEXPAND);\\n\tview_sizer->Add(seamless_panel, 1, wxEXPAND);\\n\tsprite_panel->Hide(); // Initially hide the sprite view\\n\tseamless_panel->Hide(); // Initially hide the seamless view\\n\t\\n\tsidesizer->Add(view_sizer, 1, wxEXPAND | wxTOP, 5);\\n\t\\n\t// Add buttons for loading NPCs, monsters, and purging creatures\\n\twxSizer* buttonSizer = newd wxBoxSizer(wxHORIZONTAL);\\n\t\\n\tload_npcs_button = newd wxButton(this, PALETTE_LOAD_NPCS_BUTTON, \"Load NPCs Folder\");\\n\tbuttonSizer->Add(load_npcs_button, 1, wxEXPAND | wxRIGHT, 5);\\n\t\\n\tload_monsters_button = newd wxButton(this, PALETTE_LOAD_MONSTERS_BUTTON, \"Load Monsters Folder\");\\n\tbuttonSizer->Add(load_monsters_button, 1, wxEXPAND | wxLEFT, 5);\\n\t\\n\tsidesizer->Add(buttonSizer, 0, wxEXPAND | wxTOP, 5);\\n\t\\n\tpurge_creatures_button = newd wxButton(this, PALETTE_PURGE_CREATURES_BUTTON, \"Purge Creatures\");\\n\tsidesizer->Add(purge_creatures_button, 0, wxEXPAND |\
    \ wxTOP, 5);\\n\t\\n\t// View mode toggle\\n\twxBoxSizer* viewModeSizer = newd wxBoxSizer(wxHORIZONTAL);\\n\tview_toggle = newd wxToggleButton(this, PALETTE_VIEW_TOGGLE_BUTTON, \"Sprite View\");\\n\tviewModeSizer->Add(view_toggle, 1, wxEXPAND);\\n\t\\n\t// Large sprites toggle\\n\tlarge_sprites_toggle = newd wxToggleButton(this, PALETTE_CREATURE_LARGE_SPRITES_TOGGLE, \"64x64\");\\n\tlarge_sprites_toggle->Enable(false); // Only enabled in sprite view\\n\tviewModeSizer->Add(large_sprites_toggle, 1, wxEXPAND | wxLEFT, 5);\\n\t\\n\t// Zoom button\\n\tzoom_button = newd wxButton(this, PALETTE_CREATURE_ZOOM_BUTTON, \"Zoom 2x\");\\n\tzoom_button->Enable(false); // Only enabled in sprite view with large sprites\\n\tviewModeSizer->Add(zoom_button, 1, wxEXPAND | wxLEFT, 5);\\n\t\\n\tsidesizer->Add(viewModeSizer, 0, wxEXPAND | wxTOP, 5);\\n\t\\n\t// Add brush radio buttons\\n\twxToggleButton* creature_radio = newd wxToggleButton(this, PALETTE_CREATURE_BRUSH_BUTTON, \"Creature\");\\n\twxToggleButton*\
    \ spawn_radio = newd wxToggleButton(this, PALETTE_SPAWN_BRUSH_BUTTON, \"Spawn\");\\n\t\\n\twxBoxSizer* radiosizer = newd wxBoxSizer(wxHORIZONTAL);\\n\tradiosizer->Add(creature_radio, 1, wxEXPAND);\\n\tradiosizer->Add(spawn_radio, 1, wxEXPAND);\\n\t\\n\tsidesizer->Add(radiosizer, 0, wxEXPAND | wxTOP, 5);\\n\t\\n\t// Store references to the radio buttons\\n\tcreature_brush_button = creature_radio;\\n\tspawn_brush_button = spawn_radio;\\n\t\\n\t// Add spawn settings\\n\twxFlexGridSizer* settings_sizer = newd wxFlexGridSizer(2, 5, 5);\\n\tsettings_sizer->AddGrowableCol(1);\\n\tsettings_sizer->Add(newd wxStaticText(this, wxID_ANY, \"Spawntime\"));\\n\t\\n\tcreature_spawntime_spin = newd wxSpinCtrl(this, PALETTE_CREATURE_SPAWN_TIME, i2ws(g_settings.getInteger(Config::DEFAULT_SPAWNTIME)), \\n\t\t\t\t\t\t\t\t\t\t\twxDefaultPosition, wxDefaultSize, wxSP_ARROW_KEYS, 0, 3600, g_settings.getInteger(Config::DEFAULT_SPAWNTIME));\\n\t\\n\tsettings_sizer->Add(creature_spawntime_spin, 0, wxEXPAND);\\\
    n\tsettings_sizer->Add(newd wxStaticText(this, wxID_ANY, \"Size\"));\\n\t\\n\tspawn_size_spin = newd wxSpinCtrl(this, PALETTE_CREATURE_SPAWN_SIZE, i2ws(5), \\n\t\t\t\t\t\t\t\t\t  wxDefaultPosition, wxDefaultSize, wxSP_ARROW_KEYS, 1, 10, 5);\\n\t\\n\tsettings_sizer->Add(spawn_size_spin, 0, wxEXPAND);\\n\t\\n\tsidesizer->Add(settings_sizer, 0, wxEXPAND | wxTOP, 5);\\n\ttopsizer->Add(sidesizer, 1, wxEXPAND | wxALL, 5);\\n\t\\n\tSetSizerAndFit(topsizer);\\n\t\\n\t// Load all creatures\\n\tTilesetContainer tilesets;\\n\t\\n\t// Create a list of all creature tilesets"
- file_path: wxwidgets/palette_creature.h
  description: Header for `CreaturePalettePanel`, `CreatureSpritePanel`, and `CreatureSeamlessGridPanel`.
  md5_hash: 04254faeff1d7d286e2b754d8b871920
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#ifndef RME_TILESET_CREATURE_H_\\n#define\
    \ RME_TILESET_CREATURE_H_\\n\\n#include \"palette_common.h\"\\n\\n// New class for seamless grid view of creature sprites with direct rendering\\nclass CreatureSeamlessGridPanel : public wxScrolledWindow {\\npublic:\\n\tCreatureSeamlessGridPanel(wxWindow* parent);\\n\tvirtual ~CreatureSeamlessGridPanel();\\n\\n\tvoid Clear();\\n\tvoid LoadCreatures(const BrushVector& brushlist);\\n\tBrush* GetSelectedBrush() const;\\n\tbool SelectBrush(const Brush* brush);\\n\tvoid EnsureVisible(const Brush* brush);\\n\tvoid SelectIndex(int index);\\n\t\\n\t// Getter for sprite size\\n\tint GetSpriteSize() const { return sprite_size; }\\n\t\\n\t// Drawing handlers\\n\tvoid OnPaint(wxPaintEvent& event);\\n\tvoid OnSize(wxSizeEvent& event);\\n\tvoid OnScroll(wxScrollWinEvent& event);\\n\tvoid OnMouseClick(wxMouseEvent& event);\\n\tvoid OnMouseMove(wxMouseEvent& event);\\n\tvoid OnTimer(wxTimerEvent& event);\\n\\n\t// Creature brushes in this panel\\n\tBrushVector creatures;\\n\\n\t// Friend class declaration\
    \ to allow access to protected members\\n\tfriend class CreaturePalettePanel;\\n\\nprotected:\\n\tvoid RecalculateGrid();\\n\tint GetSpriteIndexAt(int x, int y) const;\\n\tint GetCreatureNaturalSize(CreatureType* ctype) const;\\n\tvoid DrawCreature(wxDC& dc, int x, int y, CreatureType* ctype, bool selected = false);\\n\tvoid DrawItemsToPanel(wxDC& dc);\\n\tvoid UpdateViewableItems();\\n\tvoid StartProgressiveLoading();\\n\\n\tint columns;\\n\tint sprite_size;\\n\tint selected_index;\\n\tint hover_index;\\n\twxBitmap* buffer;\\n\tstd::map<size_t, int> sprite_dimensions; // Maps creature index to natural size\\n\t\\n\t// Viewport and loading management\\n\tint first_visible_row;\\n\tint last_visible_row;\\n\tint visible_rows_margin;\\n\tint total_rows;\\n\tbool need_full_redraw;\\n\t\\n\t// Progressive loading properties\\n\tbool use_progressive_loading;\\n\tbool is_large_tileset;\\n\tint loading_step;\\n\tint max_loading_steps;\\n\twxTimer* loading_timer;\\n\tstatic const int LARGE_TILESET_THRESHOLD\
    \ = 200;\\n\\n\tDECLARE_EVENT_TABLE();\\n};\\n\\n// Original class for grid view of creature sprites with padding\\nclass CreatureSpritePanel : public wxScrolledWindow {\\npublic:\\n\tCreatureSpritePanel(wxWindow* parent);\\n\tvirtual ~CreatureSpritePanel();\\n\\n\tvoid Clear();\\n\tvoid LoadCreatures(const BrushVector& brushlist);\\n\tBrush* GetSelectedBrush() const;\\n\tbool SelectBrush(const Brush* brush);\\n\tvoid EnsureVisible(const Brush* brush);\\n\tvoid SelectIndex(int index);\\n\t\\n\t// Getter for sprite size\\n\tint GetSpriteSize() const;\\n\t\\n\t// Drawing handlers\\n\tvoid OnPaint(wxPaintEvent& event);\\n\tvoid OnSize(wxSizeEvent& event);\\n\tvoid OnScroll(wxScrollWinEvent& event);\\n\tvoid OnMouseClick(wxMouseEvent& event);\\n\tvoid OnMouseMove(wxMouseEvent& event);\\n\\n\t// Creature brushes in this panel\\n\tBrushVector creatures;\\n\\n\t// Friend class declaration to allow access to protected members\\n\tfriend class CreaturePalettePanel;\\n\\nprotected:\\n\tvoid RecalculateGrid();\\\
    n\tint GetSpriteIndexAt(int x, int y) const;\\n\tvoid DrawSprite(wxDC& dc, int x, int y, CreatureType* ctype, bool selected = false);\\n\\n\tint columns;\\n\tint sprite_size;\\n\tint padding;\\n\tint selected_index;\\n\tint hover_index;\\n\twxBitmap* buffer;\\n\\n\tDECLARE_EVENT_TABLE();\\n};\\n\\nclass CreaturePalettePanel : public PalettePanel {\\npublic:\\n\tCreaturePalettePanel(wxWindow* parent, wxWindowID id = wxID_ANY);\\n\tvirtual ~CreaturePalettePanel();\\n\\n\tPaletteType GetType() const;\\n\\n\t// Select the first brush\\n\tvoid SelectFirstBrush();\\n\t// Returns the currently selected brush (first brush if panel is not loaded)\\n\tBrush* GetSelectedBrush() const;\\n\t// Returns the currently selected brush size\\n\tint GetSelectedBrushSize() const;\\n\t// Select the brush in the parameter, this only changes the look of the panel\\n\tbool SelectBrush(const Brush* whatbrush);\\n\\n\t// Updates the palette window to use the current brush size\\n\tvoid OnUpdateBrushSize(BrushShape\
    \ shape, int size);\\n\t// Called when this page is displayed\\n\tvoid OnSwitchIn();\\n\t// Called sometimes?\\n\tvoid OnUpdate();\\n\\nprotected:\\n\tvoid SelectTileset(size_t index);\\n\tvoid SelectCreature(size_t index);\\n\tvoid SelectCreature(std::string name);\\n\t// Switch between list view and sprite view modes\\n\tvoid SetViewMode(bool use_sprites);\\n\t// Set view style (regular grid vs seamless grid)\\n\tvoid SetViewStyle(bool use_seamless);\\n\t// Set large sprite mode (64x64 vs 32x32)\\n\tvoid SetLargeSpriteMode(bool use_large);\\n\t// Set zoom level for sprites\\n\tvoid SetZoomLevel(int zoom_factor);\\n\\npublic:\\n\t// Event handling\\n\tvoid OnChangeSpawnTime(wxSpinEvent& event);\\n\tvoid OnChangeSpawnSize(wxSpinEvent& event);\\n\\n\tvoid OnTilesetChange(wxCommandEvent& event);\\n\tvoid OnListBoxChange(wxCommandEvent& event);\\n\tvoid OnClickCreatureBrushButton(wxCommandEvent& event);\\n\tvoid OnClickSpawnBrushButton(wxCommandEvent& event);\\n\tvoid OnClickLoadNPCsButton(wxCommandEvent&\
    \ event);\\n\tvoid OnClickLoadMonstersButton(wxCommandEvent& event);\\n\tvoid OnClickPurgeCreaturesButton(wxCommandEvent& event);\\n\tvoid OnClickSearchButton(wxCommandEvent& event);\\n\tvoid OnSearchFieldText(wxCommandEvent& event);\\n\tvoid OnSearchFieldFocus(wxFocusEvent& event);\\n\tvoid OnSearchFieldKillFocus(wxFocusEvent& event);\\n\tvoid OnSearchFieldKeyDown(wxKeyEvent& event);\\n\tvoid OnClickViewToggle(wxCommandEvent& event);\\n\tvoid OnClickViewStyleToggle(wxCommandEvent& event);\\n\tvoid OnClickLargeSpritesToggle(wxCommandEvent& event);\\n\tvoid OnClickZoomButton(wxCommandEvent& event);\\n\tvoid OnSpriteSelected(wxCommandEvent& event);\\n\\nprotected:\\n\tvoid SelectCreatureBrush();\\n\tvoid SelectSpawnBrush();\\n\tbool LoadNPCsFromFolder(const wxString& folder);\\n\tbool LoadMonstersFromFolder(const wxString& folder);\\n\tbool PurgeCreaturePalettes();\\n\tvoid FilterCreatures(const wxString& search_text);\\n\\n\twxChoice* tileset_choice;\\n\tSortableListBox* creature_list;\\\
    n\tCreatureSpritePanel* sprite_panel;"
- file_path: wxwidgets/palette_house.cpp
  description: Implements `HousePalettePanel` for managing house brushes, selecting towns, and house exits. Includes an `EditHouseDialog`.
  md5_hash: bee24c8e73221b2fe87791085d0db05e
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#include \"main.h\"\\n\\n#include \"\
    palette_house.h\"\\n\\n#include \"settings.h\"\\n\\n#include \"brush.h\"\\n#include \"editor.h\"\\n#include \"map.h\"\\n\\n#include \"application.h\"\\n#include \"map_display.h\"\\n\\n#include \"house_brush.h\"\\n#include \"house_exit_brush.h\"\\n#include \"spawn_brush.h\"\\n\\n// ============================================================================\\n// House palette\\n\\nBEGIN_EVENT_TABLE(HousePalettePanel, PalettePanel)\\nEVT_TIMER(PALETTE_LAYOUT_FIX_TIMER, HousePalettePanel::OnLayoutFixTimer)\\n\\nEVT_CHOICE(PALETTE_HOUSE_TOWN_CHOICE, HousePalettePanel::OnTownChange)\\n\\nEVT_LISTBOX(PALETTE_HOUSE_LISTBOX, HousePalettePanel::OnListBoxChange)\\nEVT_LISTBOX_DCLICK(PALETTE_HOUSE_LISTBOX, HousePalettePanel::OnListBoxDoubleClick)\\nEVT_CONTEXT_MENU(HousePalettePanel::OnListBoxContextMenu)\\n\\nEVT_BUTTON(PALETTE_HOUSE_ADD_HOUSE, HousePalettePanel::OnClickAddHouse)\\nEVT_BUTTON(PALETTE_HOUSE_EDIT_HOUSE, HousePalettePanel::OnClickEditHouse)\\nEVT_BUTTON(PALETTE_HOUSE_REMOVE_HOUSE,\
    \ HousePalettePanel::OnClickRemoveHouse)\\n\\nEVT_TOGGLEBUTTON(PALETTE_HOUSE_BRUSH_BUTTON, HousePalettePanel::OnClickHouseBrushButton)\\nEVT_TOGGLEBUTTON(PALETTE_HOUSE_SELECT_EXIT_BUTTON, HousePalettePanel::OnClickSelectExitButton)\\n\\nEVT_MENU(PALETTE_HOUSE_CONTEXT_MOVE_TO_TOWN, HousePalettePanel::OnMoveHouseToTown)\\nEND_EVENT_TABLE()\\n\\nHousePalettePanel::HousePalettePanel(wxWindow* parent, wxWindowID id) :\\n\tPalettePanel(parent, id),\\n\tmap(nullptr),\\n\tdo_resize_on_display(true),\\n\tfix_size_timer(this, PALETTE_LAYOUT_FIX_TIMER) {\\n\twxSizer* topsizer = newd wxBoxSizer(wxVERTICAL);\\n\twxSizer* tmpsizer;\\n\\n\twxSizer* sidesizer = newd wxStaticBoxSizer(wxVERTICAL, this, \"Houses\");\\n\ttown_choice = newd wxChoice(this, PALETTE_HOUSE_TOWN_CHOICE, wxDefaultPosition, wxDefaultSize, (int)0, (const wxString*)nullptr);\\n\tsidesizer->Add(town_choice, 0, wxEXPAND);\\n\\n\thouse_list = newd SortableListBox(this, PALETTE_HOUSE_LISTBOX, wxDefaultPosition, wxDefaultSize, 0, nullptr,\
    \ wxLB_EXTENDED);\\n#ifdef __APPLE__\\n\t// Used for detecting a deselect\\n\thouse_list->Bind(wxEVT_LEFT_UP, &HousePalettePanel::OnListBoxClick, this);\\n#endif\\n\t// Bind context menu event to the list box\\n\thouse_list->Bind(wxEVT_CONTEXT_MENU, &HousePalettePanel::OnListBoxContextMenu, this);\\n\tsidesizer->Add(house_list, 1, wxEXPAND);\\n\\n\ttmpsizer = newd wxBoxSizer(wxHORIZONTAL);\\n\twxSizerFlags sizerFlags(1);\\n\ttmpsizer->Add(add_house_button = newd wxButton(this, PALETTE_HOUSE_ADD_HOUSE, \"Add\", wxDefaultPosition, wxSize(50, -1)), sizerFlags);\\n\ttmpsizer->Add(edit_house_button = newd wxButton(this, PALETTE_HOUSE_EDIT_HOUSE, \"Edit\", wxDefaultPosition, wxSize(50, -1)), sizerFlags);\\n\ttmpsizer->Add(remove_house_button = newd wxButton(this, PALETTE_HOUSE_REMOVE_HOUSE, \"Remove\", wxDefaultPosition, wxSize(70, -1)), sizerFlags);\\n\tsidesizer->Add(tmpsizer, wxSizerFlags(0).Right());\\n\\n\ttopsizer->Add(sidesizer, 1, wxEXPAND);\\n\\n\t// Temple position\\n\tsidesizer\
    \ = newd wxStaticBoxSizer(newd wxStaticBox(this, wxID_ANY, \"Brushes\", wxDefaultPosition, wxSize(150, 200)), wxVERTICAL);\\n\\n\t// sidesizer->Add(180, 1, wxEXPAND);\\n\\n\ttmpsizer = newd wxBoxSizer(wxHORIZONTAL);\\n\thouse_brush_button = newd wxToggleButton(this, PALETTE_HOUSE_BRUSH_BUTTON, \"House tiles\");\\n\ttmpsizer->Add(house_brush_button);\\n\tsidesizer->Add(tmpsizer, wxSizerFlags(1).Center());\\n\\n\ttmpsizer = newd wxBoxSizer(wxHORIZONTAL);\\n\tselect_position_button = newd wxToggleButton(this, PALETTE_HOUSE_SELECT_EXIT_BUTTON, \"Select Exit\");\\n\ttmpsizer->Add(select_position_button);\\n\tsidesizer->Add(tmpsizer, wxSizerFlags(1).Center());\\n\\n\ttopsizer->Add(sidesizer, 0, wxEXPAND);\\n\\n\tSetSizerAndFit(topsizer);\\n\\n\t// Create context menu\\n\tcontext_menu = newd wxMenu();\\n\tcontext_menu->Append(PALETTE_HOUSE_CONTEXT_MOVE_TO_TOWN, \"Move to Town...\");\\n}\\n\\nHousePalettePanel::~HousePalettePanel() {\\n\t////\\n}\\n\\nvoid HousePalettePanel::SetMap(Map* m) {\\\
    n\tg_gui.house_brush->setHouse(nullptr);\\n\tmap = m;\\n\tOnUpdate();\\n}\\n\\nvoid HousePalettePanel::OnSwitchIn() {\\n\tPalettePanel::OnSwitchIn();\\n\t// Extremely ugly hack to fix layout issue\\n\tif (do_resize_on_display) {\\n\t\tfix_size_timer.Start(100, true);\\n\t\tdo_resize_on_display = false;\\n\t}\\n}\\n\\nvoid HousePalettePanel::OnLayoutFixTimer(wxTimerEvent& WXUNUSED(event)) {\\n\twxWindow* w = this;\\n\twhile ((w = w->GetParent()) && dynamic_cast<PaletteWindow*>(w) == nullptr)\\n\t\t;\\n\\n\tif (w) {\\n\t\tw->SetSize(w->GetSize().GetWidth(), w->GetSize().GetHeight() + 1);\\n\t\tw->SetSize(w->GetSize().GetWidth(), w->GetSize().GetHeight() - 1);\\n\t}\\n}\\n\\nvoid HousePalettePanel::SelectFirstBrush() {\\n\tSelectHouseBrush();\\n}\\n\\nBrush* HousePalettePanel::GetSelectedBrush() const {\\n\tif (select_position_button->GetValue()) {\\n\t\tHouse* house = GetCurrentlySelectedHouse();\\n\t\tif (house) {\\n\t\t\tg_gui.house_exit_brush->setHouse(house);\\n\t\t}\\n\t\treturn (g_gui.house_exit_brush->getHouseID()\
    \ != 0 ? g_gui.house_exit_brush : nullptr);\\n\t} else if (house_brush_button->GetValue()) {\\n\t\tg_gui.house_brush->setHouse(GetCurrentlySelectedHouse());\\n\t\treturn (g_gui.house_brush->getHouseID() != 0 ? g_gui.house_brush : nullptr);\\n\t}\\n\treturn nullptr;\\n}\\n\\nbool HousePalettePanel::SelectBrush(const Brush* whatbrush) {\\n\tif (!whatbrush) {\\n\t\treturn false;\\n\t}\\n\\n\tif (whatbrush->isHouse() && map) {\\n\t\tconst HouseBrush* house_brush = static_cast<const HouseBrush*>(whatbrush);\\n\t\tfor (HouseMap::iterator house_iter = map->houses.begin(); house_iter != map->houses.end(); ++house_iter) {\\n\t\t\tif (house_iter->second->getID() == house_brush->getHouseID()) {\\n\t\t\t\tfor (uint32_t i = 0; i < town_choice->GetCount(); ++i) {\\n\t\t\t\t\tTown* town = reinterpret_cast<Town*>(town_choice->GetClientData(i));\\n\t\t\t\t\t// If it's \"No Town\" (nullptr) select it, or if it has the same town ID as the house\\n\t\t\t\t\tif (town == nullptr || town->getID() == house_iter->second->townid)\
    \ {\\n\t\t\t\t\t\tSelectTown(i);\\n\t\t\t\t\t\tfor (uint32_t j = 0; j < house_list->GetCount(); ++j) {\\n\t\t\t\t\t\t\tif (house_iter->second->getID() == reinterpret_cast<House*>(house_list->GetClientData(j))->getID()) {\\n\t\t\t\t\t\t\t\tSelectHouse(j);\\n\t\t\t\t\t\t\t\treturn true;\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t}\\n\t\t\t\t\t\treturn true;\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t} else if (whatbrush->isSpawn()) {\\n\t\tSelectExitBrush();\\n\t}\\n\treturn false;\\n}\\n\\nint HousePalettePanel::GetSelectedBrushSize() const {\\n\treturn 0;\\n}\\n\\nPaletteType HousePalettePanel::GetType() const {\\n\treturn TILESET_HOUSE;\\n}\\n\\nvoid HousePalettePanel::SelectTown(size_t index) {\\n\tASSERT(town_choice->GetCount() >= index);\\n"
- file_path: wxwidgets/palette_house.h
  description: Header for `HousePalettePanel` and `EditHouseDialog`.
  md5_hash: e357090cbc8ad19806d8439f682b5d78
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#ifndef RME_PALETTE_HOUSE_H_\\n#define\
    \ RME_PALETTE_HOUSE_H_\\n\\n#include \"palette_common.h\"\\n\\nclass House;\\n\\nclass HousePalettePanel : public PalettePanel {\\npublic:\\n\tHousePalettePanel(wxWindow* parent, wxWindowID id = wxID_ANY);\\n\t~HousePalettePanel();\\n\\n\tPaletteType GetType() const;\\n\\n\t// Select the first brush\\n\tvoid SelectFirstBrush();\\n\t// Returns the currently selected brush (first brush if panel is not loaded)\\n\tBrush* GetSelectedBrush() const;\\n\t// Returns the currently selected brush size\\n\tint GetSelectedBrushSize() const;\\n\t// Select the brush in the parameter, this only changes the look of the panel\\n\tbool SelectBrush(const Brush* whatbrush);\\n\\n\t// Called sometimes?\\n\tvoid OnUpdate();\\n\t// Called when this page is about to be displayed\\n\tvoid OnSwitchIn();\\n\\n\tvoid OnLayoutFixTimer(wxTimerEvent& event);\\n\\n\tvoid SetMap(Map* map);\\n\\nprotected:\\n\t// Internal use\\n\tvoid SaveHouse();\\n\tvoid SelectTown(size_t index);\\n\tvoid SelectHouse(size_t index);\\\
    n\\n\tHouse* GetCurrentlySelectedHouse() const;\\n\\n\tvoid SelectHouseBrush();\\n\tvoid SelectExitBrush();\\n\tvoid RefreshHouseList();\\n\\npublic:\\n\t// wxWidgets event handling\\n\tvoid OnTownChange(wxCommandEvent& event);\\n\tvoid OnListBoxChange(wxCommandEvent& event);\\n\tvoid OnListBoxDoubleClick(wxCommandEvent& event);\\n\tvoid OnClickHouseBrushButton(wxCommandEvent& event);\\n\tvoid OnClickSelectExitButton(wxCommandEvent& event);\\n\tvoid OnClickAddHouse(wxCommandEvent& event);\\n\tvoid OnClickEditHouse(wxCommandEvent& event);\\n\tvoid OnClickRemoveHouse(wxCommandEvent& event);\\n\tvoid OnListBoxContextMenu(wxContextMenuEvent& event);\\n\tvoid OnMoveHouseToTown(wxCommandEvent& event);\\n\\n#ifdef __APPLE__\\n\t// Used for detecting a deselect\\n\tvoid OnListBoxClick(wxMouseEvent& event);\\n#endif\\n\\nprotected:\\n\tMap* map;\\n\twxChoice* town_choice;\\n\tSortableListBox* house_list;\\n\twxToggleButton* house_brush_button;\\n\twxToggleButton* select_position_button;\\n\t\
    wxButton* add_house_button;\\n\twxButton* edit_house_button;\\n\twxButton* remove_house_button;\\n\twxMenu* context_menu;\\n\\n\t// Used for ugly hack\\n\tbool do_resize_on_display;\\n\twxTimer fix_size_timer;\\n\\n\tDECLARE_EVENT_TABLE()\\n};\\n\\nclass EditHouseDialog : public wxDialog {\\npublic:\\n\tEditHouseDialog(wxWindow* parent, Map* map, House* house);\\n\tvirtual ~EditHouseDialog();\\n\\n\tvoid OnFocusChange(wxFocusEvent&);\\n\\n\tvoid OnClickOK(wxCommandEvent&);\\n\tvoid OnClickCancel(wxCommandEvent&);\\n\\nprotected:\\n\tMap* map;\\n\tHouse* what_house;\\n\\n\twxString house_name, house_id, house_rent;\\n\\n\twxTextCtrl* name_field;\\n\twxChoice* town_id_field;\\n\twxSpinCtrl* id_field;\\n\twxTextCtrl* rent_field;\\n\twxCheckBox* guildhall_field;\\n\\n\tDECLARE_EVENT_TABLE();\\n};\\n\\n#endif"
- file_path: wxwidgets/palette_waypoints.cpp
  description: Implements `WaypointPalettePanel` for listing, adding, removing, and renaming waypoints.
  md5_hash: e90f5c9b31ee6a819e8a50131bcec282
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n// ============================================================================\\\
    n// Waypoint palette\\n\\n#include \"main.h\"\\n\\n#include \"gui.h\"\\n#include \"palette_waypoints.h\"\\n#include \"waypoint_brush.h\"\\n#include \"map.h\"\\n\\nBEGIN_EVENT_TABLE(WaypointPalettePanel, PalettePanel)\\nEVT_BUTTON(PALETTE_WAYPOINT_ADD_WAYPOINT, WaypointPalettePanel::OnClickAddWaypoint)\\nEVT_BUTTON(PALETTE_WAYPOINT_REMOVE_WAYPOINT, WaypointPalettePanel::OnClickRemoveWaypoint)\\n\\nEVT_LIST_BEGIN_LABEL_EDIT(PALETTE_WAYPOINT_LISTBOX, WaypointPalettePanel::OnBeginEditWaypointLabel)\\nEVT_LIST_END_LABEL_EDIT(PALETTE_WAYPOINT_LISTBOX, WaypointPalettePanel::OnEditWaypointLabel)\\nEVT_LIST_ITEM_SELECTED(PALETTE_WAYPOINT_LISTBOX, WaypointPalettePanel::OnClickWaypoint)\\nEND_EVENT_TABLE()\\n\\nWaypointPalettePanel::WaypointPalettePanel(wxWindow* parent, wxWindowID id) :\\n\tPalettePanel(parent, id),\\n\tmap(nullptr) {\\n\twxSizer* sidesizer = newd wxStaticBoxSizer(wxVERTICAL, this, \"Waypoints\");\\n\\n\twaypoint_list = newd wxListCtrl(this, PALETTE_WAYPOINT_LISTBOX, wxDefaultPosition,\
    \ wxDefaultSize, wxLC_REPORT | wxLC_SINGLE_SEL | wxLC_EDIT_LABELS | wxLC_NO_HEADER);\\n\twaypoint_list->InsertColumn(0, \"UNNAMED\", wxLIST_FORMAT_LEFT, 200);\\n\tsidesizer->Add(waypoint_list, 1, wxEXPAND);\\n\\n\twxSizer* tmpsizer = newd wxBoxSizer(wxHORIZONTAL);\\n\ttmpsizer->Add(add_waypoint_button = newd wxButton(this, PALETTE_WAYPOINT_ADD_WAYPOINT, \"Add\", wxDefaultPosition, wxSize(50, -1)), 1, wxEXPAND);\\n\ttmpsizer->Add(remove_waypoint_button = newd wxButton(this, PALETTE_WAYPOINT_REMOVE_WAYPOINT, \"Remove\", wxDefaultPosition, wxSize(70, -1)), 1, wxEXPAND);\\n\tsidesizer->Add(tmpsizer, 0, wxEXPAND);\\n\\n\tSetSizerAndFit(sidesizer);\\n}\\n\\nWaypointPalettePanel::~WaypointPalettePanel() {\\n\t////\\n}\\n\\nvoid WaypointPalettePanel::OnSwitchIn() {\\n\tPalettePanel::OnSwitchIn();\\n}\\n\\nvoid WaypointPalettePanel::OnSwitchOut() {\\n\tPalettePanel::OnSwitchOut();\\n}\\n\\nvoid WaypointPalettePanel::SetMap(Map* m) {\\n\tmap = m;\\n\tthis->Enable(m);\\n}\\n\\nvoid WaypointPalettePanel::SelectFirstBrush()\
    \ {\\n\t// SelectWaypointBrush();\\n}\\n\\nBrush* WaypointPalettePanel::GetSelectedBrush() const {\\n\tlong item = waypoint_list->GetNextItem(-1, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);\\n\tg_gui.waypoint_brush->setWaypoint(\\n\t\titem == -1 ? nullptr : map->waypoints.getWaypoint(nstr(waypoint_list->GetItemText(item)))\\n\t);\\n\treturn g_gui.waypoint_brush;\\n}\\n\\nbool WaypointPalettePanel::SelectBrush(const Brush* whatbrush) {\\n\tASSERT(whatbrush == g_gui.waypoint_brush);\\n\treturn false;\\n}\\n\\nint WaypointPalettePanel::GetSelectedBrushSize() const {\\n\treturn 0;\\n}\\n\\nPaletteType WaypointPalettePanel::GetType() const {\\n\treturn TILESET_WAYPOINT;\\n}\\n\\nwxString WaypointPalettePanel::GetName() const {\\n\treturn \"Waypoint Palette\";\\n}\\n\\nvoid WaypointPalettePanel::OnUpdate() {\\n\tif (wxTextCtrl* tc = waypoint_list->GetEditControl()) {\\n\t\tWaypoint* wp = map->waypoints.getWaypoint(nstr(tc->GetValue()));\\n\t\tif (wp && wp->pos == Position()) {\\n\t\t\tif (map->getTile(wp->pos))\
    \ {\\n\t\t\t\tmap->getTileL(wp->pos)->decreaseWaypointCount();\\n\t\t\t}\\n\t\t\tmap->waypoints.removeWaypoint(wp->name);\\n\t\t}\\n\t}\\n\twaypoint_list->DeleteAllItems();\\n\\n\tif (!map) {\\n\t\twaypoint_list->Enable(false);\\n\t\tadd_waypoint_button->Enable(false);\\n\t\tremove_waypoint_button->Enable(false);\\n\t} else {\\n\t\twaypoint_list->Enable(true);\\n\t\tadd_waypoint_button->Enable(true);\\n\t\tremove_waypoint_button->Enable(true);\\n\\n\t\tWaypoints& waypoints = map->waypoints;\\n\\n\t\tfor (WaypointMap::const_iterator iter = waypoints.begin(); iter != waypoints.end(); ++iter) {\\n\t\t\twaypoint_list->InsertItem(0, wxstr(iter->second->name));\\n\t\t}\\n\t}\\n}\\n\\nvoid WaypointPalettePanel::OnClickWaypoint(wxListEvent& event) {\\n\tif (!map) {\\n\t\treturn;\\n\t}\\n\\n\tstd::string wpname = nstr(event.GetText());\\n\tWaypoint* wp = map->waypoints.getWaypoint(wpname);\\n\tif (wp) {\\n\t\tg_gui.SetScreenCenterPosition(wp->pos);\\n\t\tg_gui.waypoint_brush->setWaypoint(wp);\\\
    n\t}\\n}\\n\\nvoid WaypointPalettePanel::OnBeginEditWaypointLabel(wxListEvent& event) {\\n\t// We need to disable all hotkeys, so we can type properly\\n\tg_gui.DisableHotkeys();\\n}\\n\\nvoid WaypointPalettePanel::OnEditWaypointLabel(wxListEvent& event) {\\n\tstd::string wpname = nstr(event.GetLabel());\\n\tstd::string oldwpname = nstr(waypoint_list->GetItemText(event.GetIndex()));\\n\tWaypoint* wp = map->waypoints.getWaypoint(oldwpname);\\n\\n\tif (event.IsEditCancelled()) {\\n\t\treturn;\\n\t}\\n\\n\tif (wpname == \"\") {\\n\t\tmap->waypoints.removeWaypoint(oldwpname);\\n\t\tg_gui.RefreshPalettes();\\n\t} else if (wp) {\\n\t\tif (wpname == oldwpname) {\\n\t\t\t; // do nothing\\n\t\t} else {\\n\t\t\tif (map->waypoints.getWaypoint(wpname)) {\\n\t\t\t\t// Already exists a waypoint with this name!\\n\t\t\t\tg_gui.SetStatusText(\"There already is a waypoint with this name.\");\\n\t\t\t\tevent.Veto();\\n\t\t\t\tif (oldwpname == \"\") {\\n\t\t\t\t\tmap->waypoints.removeWaypoint(oldwpname);\\\
    n\t\t\t\t\tg_gui.RefreshPalettes();\\n\t\t\t\t}\\n\t\t\t} else {\\n\t\t\t\tWaypoint* nwp = newd Waypoint(*wp);\\n\t\t\t\tnwp->name = wpname;\\n\\n\t\t\t\tWaypoint* rwp = map->waypoints.getWaypoint(oldwpname);\\n\t\t\t\tif (rwp) {\\n\t\t\t\t\tif (map->getTile(rwp->pos)) {\\n\t\t\t\t\t\tmap->getTileL(rwp->pos)->decreaseWaypointCount();\\n\t\t\t\t\t}\\n\t\t\t\t\tmap->waypoints.removeWaypoint(rwp->name);\\n\t\t\t\t}\\n\\n\t\t\t\tmap->waypoints.addWaypoint(nwp);\\n\t\t\t\tg_gui.waypoint_brush->setWaypoint(nwp);\\n\\n\t\t\t\t// Refresh other palettes\\n\t\t\t\trefresh_timer.Start(300, true);\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tif (event.IsAllowed()) {\\n\t\tg_gui.EnableHotkeys();\\n\t}\\n}\\n\\nvoid WaypointPalettePanel::OnClickAddWaypoint(wxCommandEvent& event) {\\n\tif (map) {\\n\t\tmap->waypoints.addWaypoint(newd Waypoint());\\n\t\tlong i = waypoint_list->InsertItem(0, \"\");"
- file_path: wxwidgets/palette_waypoints.h
  description: Header for `WaypointPalettePanel`.
  md5_hash: c2b44aad38859bf826dd18175969feed
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#ifndef RME_PALETTE_WAYPOINTS_H_\\\
    n#define RME_PALETTE_WAYPOINTS_H_\\n\\n#include <wx/listctrl.h>\\n\\n#include \"waypoints.h\"\\n#include \"palette_common.h\"\\n\\nclass WaypointPalettePanel : public PalettePanel {\\npublic:\\n\tWaypointPalettePanel(wxWindow* parent, wxWindowID id = wxID_ANY);\\n\t~WaypointPalettePanel();\\n\\n\twxString GetName() const;\\n\tPaletteType GetType() const;\\n\\n\t// Select the first brush\\n\tvoid SelectFirstBrush();\\n\t// Returns the currently selected brush (first brush if panel is not loaded)\\n\tBrush* GetSelectedBrush() const;\\n\t// Returns the currently selected brush size\\n\tint GetSelectedBrushSize() const;\\n\t// Select the brush in the parameter, this only changes the look of the panel\\n\tbool SelectBrush(const Brush* whatbrush);\\n\\n\t// Called sometimes?\\n\tvoid OnUpdate();\\n\t// Called when this page is about to be displayed\\n\tvoid OnSwitchIn();\\n\t// Called when this page is hidden\\n\tvoid OnSwitchOut();\\n\\npublic:\\n\t// wxWidgets event handling\\n\tvoid OnClickWaypoint(wxListEvent&\
    \ event);\\n\tvoid OnBeginEditWaypointLabel(wxListEvent& event);\\n\tvoid OnEditWaypointLabel(wxListEvent& event);\\n\tvoid OnClickAddWaypoint(wxCommandEvent& event);\\n\tvoid OnClickRemoveWaypoint(wxCommandEvent& event);\\n\\n\tvoid SetMap(Map* map);\\n\\nprotected:\\n\tMap* map;\\n\twxListCtrl* waypoint_list;\\n\twxButton* add_waypoint_button;\\n\twxButton* remove_waypoint_button;\\n\\n\tDECLARE_EVENT_TABLE()\\n};\\n\\n#endif"
documentation_references:
- 'QToolBar: https://doc.qt.io/qt-6/qtoolbar.html'
- 'QAction: https://doc.qt.io/qt-6/qaction.html'
- 'QDockWidget: https://doc.qt.io/qt-6/qdockwidget.html'
- 'QTabWidget: https://doc.qt.io/qt-6/qtabwidget.html'
- 'QListView / QListWidget: https://doc.qt.io/qt-6/qlistview.html'
- 'QAbstractItemModel / QStyledItemDelegate: for custom list/grid views.'
- QSpinBox, QLineEdit, QPushButton, QComboBox for various controls.
current_functionality_summary: |-
  The wxWidgets version has a `MainToolBar` class that creates and manages four dockable `wxAuiToolBar` instances:
  1.  Standard Toolbar: File operations, Undo/Redo, Cut/Copy/Paste.
  2.  Brushes Toolbar: Toggle buttons for specialized brushes like Eraser, Zone brushes, Door types, Window types.
  3.  Position Toolbar: X, Y, Z coordinate inputs and a "Go" button.
  4.  Sizes Toolbar: Toggles for brush shape (circular/square) and predefined brush sizes.
  Toolbars use `wxArtProvider` or PNGs for icons. Their state (enabled/disabled, toggled) is updated based on application context.

  The `PaletteWindow` is a `wxPanel` hosting a `wxChoicebook` to switch between different palette types (Terrain, Doodad, Item, Collection, Creature, House, Waypoint, RAW).
  - `BrushPalettePanel` is a generic base for several palette types, itself containing a `wxChoicebook` for different tilesets/categories. Each page of this inner choicebook is a `BrushPanel`.
  - `BrushPanel` displays brushes using various view modes (list, icon grid, direct draw, seamless grid).
  - Specialized palettes (`CreaturePalettePanel`, `HousePalettePanel`, `WaypointPalettePanel`) have custom UIs for their specific functionalities, including search, settings inputs, and dedicated brush types. Palettes are populated based on loaded XML asset data (`tilesets.xml`, `items.xml`, etc.) or map-specific data (houses, waypoints).
definition_of_done:
- The four main application toolbars (Standard, Brushes, Position, Sizes) are recreated as `QToolBar` objects within the `QMainWindow`.
- Actions on the Standard and Brushes toolbars are implemented using `QAction`s with appropriate icons and tooltips, connected to placeholder slots.
- The Position toolbar includes `QSpinBox` (or validated `QLineEdit`) controls for X, Y, Z coordinates and a `QPushButton` for 'Go'.
- The Sizes toolbar uses `QActionGroup`s or checkable `QAction`s to allow selection of brush shape and size, with visual feedback.
- A `QDockWidget` is created to house the main palette system.
- Inside the dock widget, a `QTabWidget` (`paletteTabWidget`) is used to switch between different palette types (Terrain, Doodad, Item, Creature, House, Waypoint, RAW, Collection).
- 'For generic palette types (Terrain, Doodad, Item, RAW, Collection):'
- '  - Each tab contains a `QComboBox` or another `QTabWidget` to select the specific tileset/category (e.g., ''Forest Grounds'', ''City Items'').'
- '  - Brushes/items from the selected tileset/category are displayed in a `QListView` (with a custom model/delegate for icon+text or grid view) or a `QListWidget`.'
- '  - Basic search/filter functionality using a `QLineEdit` is provided for these palettes.'
- 'Specialized palettes are implemented:'
- '  - `CreaturePalette`: `QComboBox` for creature categories, search field, display area (list or grid), `QSpinBox` for spawn time/radius, toggles for creature/spawn brush.'
- '  - `HousePalette`: `QComboBox` for towns, `QListWidget` for houses, Add/Edit/Remove buttons, toggles for house/exit brush.'
- '  - `WaypointPalette`: `QListWidget` with editable items for waypoint names, Add/Remove buttons.'
- Selecting a brush/item in any palette correctly updates the application's global current brush state.
- Toolbars and palettes are correctly enabled/disabled/updated based on application context (e.g., map open, current tool).
boilerplate_coder_ai_prompt: |-
  Your task is to port the main application toolbars and the comprehensive palette system from wxWidgets to Qt6. This involves recreating multiple toolbars with various controls and a tabbed palette window that displays different types of brushes and game elements.

  **Reference Files:** `wxwidgets/main_toolbar.*`, `wxwidgets/palette_window.*`, `wxwidgets/palette_brushlist.*`, `wxwidgets/palette_creature.*`, `wxwidgets/palette_house.*`, `wxwidgets/palette_waypoints.*`. Palette content is driven by XML asset files.

  **I. Main Toolbars (to be added to `QMainWindow`):**

  1.  **Standard Toolbar (`QToolBar` named `standardToolbar`):**
      - Actions: New, Open, Save, Save As, Undo, Redo, Cut, Copy, Paste.
      - Use `QAction` for each, set icons (e.g., `QIcon::fromTheme("document-new")` or custom PNGs) and tooltips. Connect `triggered()` signals to placeholder slots.

  2.  **Brushes Toolbar (`QToolBar` named `brushesToolbar`):**
      - Checkable `QAction`s for: Eraser, Optional Border, PZ, NoPVP, NoLogout, PvPZone, Zone Brush.
      - Checkable `QAction`s for Door Types: Normal, Locked, Magic, Quest, Normal Alt, Archway.
      - Checkable `QAction`s for Window Types: Hatch, Window.
      - Use a `QActionGroup` if some of these are mutually exclusive. Set icons and tooltips.

  3.  **Position Toolbar (`QToolBar` named `positionToolbar`):**
      - Three `QSpinBox` widgets for X, Y, Z coordinates. Set appropriate ranges (e.g., 0 to map max width/height/depth).
      - A `QPushButton` labeled "Go".
      - Connect `QSpinBox::valueChanged` and `QPushButton::clicked` to slots.

  4.  **Sizes Toolbar (`QToolBar` named `sizesToolbar`):**
      - `QActionGroup` for Brush Shape:
          - `QAction` "Rectangular" (checked by default).
          - `QAction` "Circular".
      - `QActionGroup` for Brush Size (or individual checkable `QAction`s if preferred, ensuring only one is active):
          - Actions for sizes 1x1, 2x2, 3x3, ..., 7x7 (or equivalent radius for circular). Set icons representing the size/shape.
      - Connect `triggered()` signals.

  5.  **Toolbar Management:**
      - Implement `void MainWindow::updateToolbars()` to enable/disable toolbar actions based on application state (map loaded, selection active, etc.).
      - Implement `void MainWindow::updateBrushToolbarStates()` to reflect the currently selected global brush.
      - Implement `void MainWindow::updateBrushSizeToolbar(BrushShape shape, int size)` to update the Sizes toolbar.

  **II. Palette System (within a `QDockWidget`):**

  1.  **Main Palette Container:**
      - Use a `QDockWidget` (e.g., titled "Palettes").
      - Inside, place a `QTabWidget` (`paletteTabWidget`) for different palette categories.

  2.  **Generic Brush Palette (`BrushPalettePanel` equivalent for Terrain, Doodad, Item, RAW, Collection):**
      - For each of these types, create a tab in `paletteTabWidget`.
      - Each such tab will contain:
          - A `QComboBox` (or another `QTabWidget`) to select the specific *tileset category* (e.g., "Forest Grounds," "City Items," loaded from `g_materials.tilesets`).
          - A display area for brushes/items from the selected tileset:
              - Recommended: `QListView` with a custom `QAbstractListModel` and `QStyledItemDelegate` for rendering icons and text.
              - Alternative: `QListWidget` (simpler, less flexible).
              - Consider a toggle for list view vs. icon grid view (`QListView::setViewMode`).
          - A `QLineEdit` for searching/filtering items within the current tileset category.
          - For palettes that use them (Terrain, Doodad, Collection), integrate tool panels (Brush Tools, Thickness, Size) as separate widgets or toolbars within this palette tab. The original `BrushPalettePanel` added these via `AddToolPanel`.

  3.  **Specialized Palettes:**

      - **Creature Palette Tab:**
          - `QComboBox` for creature tilesets (e.g., "All Creatures," "NPCs," "Forest Monsters").
          - `QLineEdit` for search (by name, or "lt:id" for looktype).
          - Display area: `QListView` or a custom grid widget (like `CreatureSeamlessGridPanel`) to show creature sprites/names.
          - `QSpinBox` for "Spawntime" and "Spawn Size/Radius".
          - `QRadioButton` or `QActionGroup` for "Creature Brush" vs. "Spawn Brush" mode.
          - `QPushButton`s: "Load NPCs Folder," "Load Monsters Folder," "Purge Creatures."
          - Toggles for "Sprite View" / "List View", "64x64 Sprites", "Zoom" for sprite view.

      - **House Palette Tab:**
          - `QComboBox` to select `Town`.
          - `QListWidget` to display houses in the selected town (Name, ID, Size).
          - `QPushButton`s: "Add House," "Edit House," "Remove House."
          - `QRadioButton` or `QActionGroup` for "House Tile Brush" vs. "Select Exit Brush."

      - **Waypoint Palette Tab:**
          - `QListWidget` where items are waypoint names. Items should be editable (`Qt::ItemIsEditable`).
          - `QPushButton`s: "Add Waypoint," "Remove Waypoint."

  4.  **Palette Interaction:**
      - When a brush/item/creature/etc. is selected in any palette, a signal should be emitted, which the `MainWindow` or `Editor` class connects to, to set the application's current active brush.
      - Implement logic similar to `PaletteWindow::OnSelectBrush` to switch to the correct palette tab and select the brush if it's activated externally (e.g., hotkey).
      - Palette content should be refreshed when data changes (e.g., after `CORE-02` or `CORE-04` reload assets, or map waypoints/houses change).

  This is a large UI component. Break it down into manageable sub-widgets for each palette type.
  The `analyzed_input_files` section should be populated by reading the first 200 lines of the listed C++ files and calculating their MD5 hashes.
