id: CORE-05
section: Core Migration Tasks
title: Port Selection & Copy/Paste System
original_input_files:
  - wxwidgets/selection.h
  - wxwidgets/selection.cpp
  - wxwidgets/copybuffer.h
  - wxwidgets/copybuffer.cpp
analyzed_input_files:
  - file_path: wxwidgets/selection.h
    description: |
      Defines the `Selection` class and `SelectionThread` class for managing user selections on the map.
      - `Selection`: Manages a `TileSet` (a set of `Tile*`) representing the currently selected tiles. It provides methods like `add()` and `remove()` which operate on tiles or specific objects within tiles (Items, Spawns, Creatures). These methods typically work within a "session" (`start()`, `commit()`, `finish()`) that groups changes into `Action` objects for the undo/redo system. `addInternal()`/`removeInternal()` modify the selection set directly without creating actions. Also includes methods to get selection bounds (`minPosition`, `maxPosition`).
      - `SelectionThread`: A `wxThread` subclass designed to perform selection operations over an area in a background thread, presumably to prevent UI freezes for large selections. The main thread can then merge the result of this background selection.
  - file_path: wxwidgets/selection.cpp
    description: |
      Implements the `Selection` and `SelectionThread` classes.
      - `Selection`: The `add()` and `remove()` methods create deep copies of the affected `Tile` objects, modify the selection state of the target objects within these copies (e.g., `item->select()`), and then add `Change` objects (containing these modified tile copies) to the current `Action` (`subsession`). The `start()`, `commit()`, and `finish()` methods manage the lifecycle of `Action` and `BatchAction` objects that record these selection changes for the `ActionQueue`.
      - `SelectionThread::Entry()`: Implements the logic to iterate over a range of map coordinates, get the tiles, and add them to a local `Selection` object by calling its `add(Tile*)` method within a thread-local session. The resulting action data is then made available to the main thread.
  - file_path: wxwidgets/copybuffer.h
    description: |
      Defines the `CopyBuffer` class, which acts as an internal clipboard for map data.
      It contains a `BaseMap* tiles` to store deep copies of `Tile` objects that have been cut or copied.
      Declares methods `copy(Editor&, int floor)`, `cut(Editor&, int floor)`, `paste(Editor&, const Position& toPosition)`, `canPaste()`, and `clear()`.
      `copyPos` stores the top-left reference position of the copied data.
  - file_path: wxwidgets/copybuffer.cpp
    description: |
      Implements the `CopyBuffer` class.
      - `copy()`: Iterates the current selection from the source `Editor`. For each selected `Tile`, it creates a deep copy containing only the selected elements (items, creatures, spawns) from that tile. These partial or full tile copies are stored in the `CopyBuffer`'s internal `BaseMap`, and `copyPos` is set to the top-leftmost position of the selection.
      - `cut()`: Performs a `copy()` operation and then creates an `Action` (via `editor.actionQueue`) to delete the selected elements from the source map. This involves creating `Change` objects representing the tiles after deletion.
      - `paste()`: Takes a target `Position`. It iterates through the tiles stored in its internal `BaseMap`. For each tile, it creates a deep copy, offsets its position relative to `copyPos` and the `target_paste_position`, and then creates an `Action` to add/merge these tiles into the target `Editor`'s map. It handles merging with existing tiles or placing new tiles based on `Config::MERGE_PASTE` setting. Automagic border updates can also be triggered.
dependencies:
  - BUILD-01  # For CMake project structure
  - CORE-01  # For Position, Item, Tile class definitions
  - CORE-03  # For Map data structure and operations
  - CORE-04  # For Action & History system integration
current_functionality_summary: |
  The current system uses:
  - `Selection` class: Manages a `TileSet` of selected tiles. Operations like adding/removing items or entire tiles from selection are recorded as `Action` objects via a session mechanism (`start`, `commit`, `finish`). This ensures selection changes are undoable. It supports selecting individual items/creatures/spawns on a tile, or entire tiles. A `SelectionThread` is used for potentially long-running area selections.
  - `CopyBuffer` class: Acts as an internal clipboard. It stores deep copies of selected tiles (including only the selected elements on those tiles) in an internal `BaseMap`. `cut()` operations also generate an action to delete the original selection. `paste()` reconstructs the copied tiles at a new location, generating an action for this modification.
qt6_migration_steps: |
  1.  **Design `SelectionManager` Class (in `mapcore/selection/`):**
      -   This class will be responsible for managing the current selection state.
      -   It needs to store selected objects. Consider if selection is primarily tile-based or if individual items/creatures on unselected tiles can be selected. The current system seems to operate on `Tile` granularity for selection storage, with selected sub-elements flagged within those tiles. A `QSet<Tile*>` (pointing to live tiles in the `Map`) along with a mechanism to know which sub-elements are selected might work. Alternatively, a list of `SelectionElement { Tile* tile; Item* item; Creature* creature; Spawn* spawn; }` could be used.
      -   Implement methods:
          -   `void startSelectionChange()`: Begins a logical selection operation (like original `start()`).
          -   `void addToSelection(Tile* tile, Item* item = nullptr, Creature* creature = nullptr, Spawn* spawn = nullptr)`: Modifies the tile state to mark objects as selected.
          -   `void removeFromSelection(Tile* tile, Item* item = nullptr, Creature* creature = nullptr, Spawn* spawn = nullptr)`: Modifies tile state to unmark objects.
          -   `void clear()`: Clears all selection.
          -   `void finishSelectionChange(const QString& commandText)`: Commits the accumulated selection changes as a single `QUndoCommand` to the `QUndoStack`. The command should store the "before" and "after" selection states or the set of tiles whose selection flags changed.
      -   Expose selection data: `const QSet<Tile*>& getSelectedTiles() const;`, `bool isSelected(Tile* tile, Item* item = nullptr) const;`.
      -   Handle bounding box calculation (`minPosition`, `maxPosition`).

  2.  **Design `ClipboardManager` (or integrate into `Map` or `EditorContext`):**
      -   **Clipboard Data Format:** Define a robust format. Serializing deep copies of `Tile` objects (including only selected elements) using `QDataStream` into a `QByteArray` with a custom MIME type is a good approach. This format must store relative positions, item IDs, subtypes, attributes, creature/spawn data, and tile flags.
      -   Implement `void copySelection(const SelectionManager& selectionManager, const Map& map)`:
          -   Gets selected tiles and their relevant contents from `selectionManager` and `map`.
          -   Calculates a reference point (e.g., top-left of selection bounding box).
          -   Serializes deep copies of these selected elements (with relative positions) into the defined format.
          -   Puts the `QByteArray` onto `QApplication::clipboard()` with the custom MIME type.
      -   Implement `void cutSelection(SelectionManager& selectionManager, Map& map, QUndoStack* undoStack)`:
          -   Calls `copySelection()`.
          -   Creates and pushes a `DeleteSelectionCommand` (see `CORE-04`) onto `undoStack` to remove the selected elements from the `map`.
      -   Implement `void paste(Map& map, const Position& targetPosition, QUndoStack* undoStack)`:
          -   Retrieves data from `QApplication::clipboard()`. Checks for the custom MIME type.
          -   Deserializes the data back into a list of `Tile` data (or equivalent structures).
          -   Creates and pushes a `PasteCommand` onto `undoStack`. This command, when executed, will add/merge the pasted tiles and their contents into the `map` at the `targetPosition`, adjusting for relative offsets from the clipboard data.

  3.  **Integrate with `QUndoStack` (from `CORE-04`):**
      -   All operations that change selection state (`addToSelection`, `removeFromSelection`, `clearSelection`) or modify map data (`cutSelection`, `paste`) must be implemented as `QUndoCommand` subclasses and pushed onto the `QUndoStack`.
      -   A `SelectionCommand` would store the set of changes to selection flags on tiles.
      -   A `PasteCommand` would store the data being pasted to allow its removal on undo.

  4.  **Replace `SelectionThread`:**
      -   For large area selections, if performance becomes an issue, use `QtConcurrent::run` or a `QThread` to gather the list of affected tiles/objects, then apply the selection change as a single command on the main thread.

  5.  **Unit Tests:**
      -   Test `SelectionManager`: adding various object types, removing, clearing, checking selection state.
      -   Test clipboard data serialization and deserialization.
      -   Test `copy`, `cut`, `paste` operations with mock map data and `QUndoStack`, ensuring correct data transfer and command creation.
definition_of_done:
  - A `SelectionManager` class is implemented in `mapcore` using Qt/C++ to manage selected map objects (Tiles, and specific Items, Creatures, Spawns within them).
  - `SelectionManager` supports adding objects to selection, removing objects, and clearing the selection.
  - All selection modifications are integrated with the `QUndoStack` (from `CORE-04`) via specific `SelectionCommand` objects, ensuring undo/redo functionality for selection changes.
  - Clipboard operations (`copy`, `cut`, `paste`) are implemented:
    - `copySelection()`: Serializes the currently selected map elements (tiles and their relevant contents) into a well-defined internal format (e.g., using `QDataStream` and `QByteArray`) and places it on `QApplication::clipboard()` with a custom MIME type.
    - `cutSelection()`: Performs a copy, then creates and pushes a command to delete the selected elements from the map.
    - `pasteSelection(Position target_position)`: Deserializes data from the clipboard and creates/pushes a command to add the elements to the map, maintaining relative positions.
  - The clipboard data format correctly captures all necessary information (items, ground, creatures, spawns, tile flags, relative positions).
  - Memory for copied data and command objects is managed correctly (e.g., via `std::unique_ptr` or Qt's ownership).
  - Basic unit tests are created for `SelectionManager` operations and for copy/cut/paste functionality, verifying data integrity and undo/redo integration.
  - The ported code compiles successfully within the `mapcore` library.
boilerplate_coder_ai_prompt: |
  You are to port the selection and copy/paste system from an old C++ codebase (based on `selection.h/cpp` and `copybuffer.h/cpp`) to a modern C++/Qt6 environment within a `mapcore` library. This system should use the `QUndoStack` and `QUndoCommand` (from `CORE-04`) for undo/redo, and interact with `Map`, `Tile`, `Item` classes (from `CORE-01`/`CORE-03`).

  **1. `SelectionManager` Class (`mapcore/selection/SelectionManager.h/cpp`):**
     -   Manages a collection of selected objects. The primary selected unit is `Tile*`, but individual items/creatures/spawns on those tiles can have a selected state.
     -   `void startSelectionChange()`: Prepares for a series of selection modifications that will become one undo command.
     -   `void add(Tile* tile, Item* item = nullptr, Creature* creature = nullptr, Spawn* spawn = nullptr)`: Marks the specified object(s) as selected within the `tile`.
     -   `void remove(Tile* tile, Item* item = nullptr, Creature* creature = nullptr, Spawn* spawn = nullptr)`: Unmarks object(s).
     -   `void clear()`: Clears all selection.
     -   `void finishSelectionChange(const QString& commandText)`: Creates a `SelectionCommand` (see below) encapsulating all changes made since `startSelectionChange()` and pushes it to the `QUndoStack`.
     -   `const QSet<Tile*>& getSelectedTiles() const;` (returns tiles that have any selected element).
     -   `bool isSelected(const Tile* tile, const Item* item = nullptr, ...) const;`.

  **2. `SelectionCommand` (derived from `QUndoCommand`):**
     -   Stores a list of `Tile*` and their selection state *before* and *after* the command.
     -   `redo()`: Applies the "after" selection state to the tiles.
     -   `undo()`: Applies the "before" selection state to the tiles.

  **3. Clipboard Data Format & `ClipboardManager` (or integrated logic):**
     -   Define a format for clipboard data: Use `QDataStream` to serialize a `QList` of lightweight `TileData` objects (containing relative position, items, creatures, spawns, flags of selected elements only) into a `QByteArray`.
     -   `void copySelection(const SelectionManager& selMgr, const Map& map)`:
         -   Gets selected tiles/elements.
         -   Calculates a reference `Position` (e.g., top-left).
         -   Creates `TileData` for each selected tile, storing only selected elements and their data relative to the reference position.
         -   Serializes this `QList<TileData>` to a `QByteArray`.
         -   Puts it on `QApplication::clipboard()->setMimeData()` with a custom MIME type.
     -   `void cutSelection(SelectionManager& selMgr, Map& map, QUndoStack* undoStack)`: Calls `copySelection`, then creates and pushes a `DeleteCommand` for the selection.
     -   `void paste(Map& map, const Position& targetPos, QUndoStack* undoStack)`:
         -   Retrieves `QByteArray` from clipboard, deserializes `QList<TileData>`.
         -   Creates a `PasteCommand`.
             -   `redo()`: Adds/merges the `TileData` into the `map` at `targetPos` (adjusting for relative positions).
             -   `undo()`: Removes the pasted elements.
         -   Pushes the `PasteCommand` to `undoStack`.

  **4. General:**
     -   Replace wxWidgets types. Use smart pointers for temporary `Tile` copies if needed.
     -   Focus on data management and command structure. UI interaction is separate.
     -   Provide necessary headers and source files.
     -   Write basic Qt Test unit tests.
documentation_references:
  - 'QClipboard: https://doc.qt.io/qt-6/qclipboard.html'
  - 'QMimeData: https://doc.qt.io/qt-6/qmimedata.html'
  - 'QDataStream: https://doc.qt.io/qt-6/qdatastream.html'
  - 'QSet: https://doc.qt.io/qt-6/qset.html'
  - 'QUndoStack: https://doc.qt.io/qt-6/qundostack.html'
  - 'QUndoCommand: https://doc.qt.io/qt-6/qundocommand.html'
