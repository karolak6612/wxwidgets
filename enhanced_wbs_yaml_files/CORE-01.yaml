wbs_item_id: CORE-01
name: Port Core Data Structures
description: Migrate fundamental data structures like Tile, Item, Position, and related
  container classes from `mapcore` to Qt6 equivalents or modern C++. This involves
  ensuring data integrity, compatibility, and performance.
dependencies: []
input_files:
- wxwidgets/tile.cpp
- wxwidgets/tile.h
- wxwidgets/item.cpp
- wxwidgets/item.h
- wxwidgets/position.h
analyzed_input_files:
- file_path: wxwidgets/tile.cpp
  description: Implementation of the Tile class, managing items, ground, creatures,
    spawns, and house information for a map location.
- file_path: wxwidgets/tile.h
  description: Header file for the Tile class, defining its structure and interface
    for managing map tile data.
- file_path: wxwidgets/item.cpp
  description: Implementation of the Item class and its derived classes (Container,
    Teleport, Door, Podium), including attribute management and factory methods.
- file_path: wxwidgets/item.h
  description: Header file for the Item class and related enums/structs, defining
    the base item properties and interface.
- file_path: wxwidgets/position.h
  description: Header file for the Position struct, defining 3D coordinates and related
    operators.
documentation_references:
- 'Qt Core Data Types: https://doc.qt.io/qt-6/qtcore-module.html'
- 'QList: https://doc.qt.io/qt-6/qlist.html'
- 'QVector: https://doc.qt.io/qt-6/qvector.html'
- 'QMap: https://doc.qt.io/qt-6/qmap.html'
- 'QString: https://doc.qt.io/qt-6/qstring.html'
- 'QVariant: https://doc.qt.io/qt-6/qvariant.html'
- 'Qt Test Framework: https://doc.qt.io/qt-6/qttest-module.html'
current_functionality_summary: 'The wxWidgets-based `Tile` class manages a ground
  item, a list of other items, an optional creature, an optional spawn object, and
  house ID, along with various flags. It handles item addition logic, selection, and
  property queries (like blocking status).

  The `Item` class, along with `ItemAttributes`, stores item ID, subtype, and custom
  attributes (UID, AID, text, description). It includes a factory `Item::Create` for
  different item types (Container, Teleport, Door, Podium derive from Item).

  The `Position` struct is a simple 3D coordinate (x, y, z) with comparison and arithmetic
  operators.'
definition_of_done:
- Qt6/C++ equivalent classes for `Tile`, `Item`, and `Position` are implemented.
- All significant methods and properties from the original `Tile`, `Item`, and `Position`
  classes (as seen in the provided snippets) are ported or have clear equivalents
  in the new Qt6/C++ classes.
- 'Data integrity for core attributes is maintained:'
- '  - `Tile` correctly manages its list of `Item` objects, `ground` item, `Creature*`,
  `Spawn*`, and `house_id`.'
- '  - `Item` correctly manages its `id`, `subtype`, and attributes (like UID, AID,
  text, description) based on `ItemAttributes`.'
- '  - `Position` accurately stores x, y, z coordinates.'
- Memory management for objects created and managed by these classes (especially items
  within tiles) is handled using modern C++ practices (e.g., smart pointers where
  appropriate).
- The new classes are designed to be largely self-contained or rely on well-defined
  interfaces for external dependencies (e.g., `g_items` for item properties, `TileLocation`).
- 'Basic unit tests are created for the new `Tile`, `Item`, and `Position` classes,
  covering:'
- '  - Object construction and initialization.'
- '  - Correct handling of attributes and data members.'
- '  - Key functionalities like adding/removing items from a tile, item creation,
  position manipulation.'
- The ported code compiles successfully within a Qt6 project structure.
- A brief report is provided detailing the mapping from the old class structures to
  the new ones, highlighting any significant design changes or assumptions made.
boilerplate_coder_ai_prompt: "The user wants to migrate core data structures from\
  \ an old C++/wxWidgets application to Qt6/modern C++.\nAnalyze the provided C++\
  \ header and source file snippets for `Tile` (from `wxwidgets/tile.cpp` and `wxwidgets/tile.h`),\
  \ `Item` (from `wxwidgets/item.cpp` and `wxwidgets/item.h`), and `Position` (from\
  \ `wxwidgets/position.h`).\n\n**1. Position Class/Struct:**\n   - Create a simple\
  \ Qt-idiomatic or modern C++ class/struct for `Position` based on `position.h`.\
  \ It should store `x`, `y`, and `z` coordinates.\n   - Implement comparison operators\
  \ (`<`, `==`, `!=`) and arithmetic operators (`+`, `-`, `+=`) as seen in `position.h`.\n\
  \   - Ensure it's lightweight and efficient.\n\n**2. Item Class:**\n   - Design\
  \ a Qt-idiomatic or modern C++ class for `Item` based on `item.h` and `item.cpp`.\n\
  \   - The class should store the item's `id` and `subtype`.\n   - It should inherit\
  \ from or incorporate a mechanism similar to `ItemAttributes` to manage custom attributes\
  \ (e.g., `uid`, `aid`, `text`, `desc`, `tier`). Consider using a `QVariantMap` or\
  \ a similar structure for attributes if a direct port of `ItemAttributeMap` is too\
  \ complex for this task.\n   - Implement a static factory method `Item::Create(uint16_t\
  \ id, uint16_t subtype)` that constructs an Item. For complex item types (like `Container`,\
  \ `Teleport`, `Door`, `Podium` which are mentioned in `Item::Create` but whose definitions\
  \ are not provided), the factory can return a base `Item` object for now, or you\
  \ can define placeholder derived classes if simple.\n   - Implement a `deepCopy()`\
  \ method.\n   - Port methods like `getID()`, `getSubtype()`, `setSubtype()`, `hasSubtype()`,\
  \ `getWeight()`, `getName()`, `getFullName()`, selection status (`isSelected`, `select`,\
  \ `deselect`).\n   - For item properties (e.g., `isBlocking()`, `isStackable()`,\
  \ `isGroundTile()`), these often depend on a global item metadata store (`g_items`).\
  \ For the ported `Item` class, assume such a store will be available (e.g., via\
  \ a singleton or a passed-in service). You can define an interface for this (e.g.,\
  \ `ItemMetadataService::getItemType(uint16_t id)`).\n   - Address how item attributes\
  \ like UID, AID, text, description, and tier are set and retrieved (e.g., `setUniqueID`,\
  \ `getActionID`, `setText`).\n\n**3. Tile Class:**\n   - Design a Qt-idiomatic or\
  \ modern C++ class for `Tile` based on `tile.h` and `tile.cpp`.\n   - A `Tile` should\
  \ be associated with a `Position` (either by composition or by reference/pointer\
  \ if `TileLocation` is complex).\n   - It must manage:\n     - A `ground` item (pointer\
  \ to `Item`).\n     - A collection of `Item` objects (e.g., `QList<Item*>`).\n \
  \    - A pointer to a `Creature` object (`Creature* creature`).\n     - A pointer\
  \ to a `Spawn` object (`Spawn* spawn`).\n     - A `house_id` (uint32_t).\n     -\
  \ Tile flags (`mapflags`, `statflags`).\n   - Implement constructors, destructor\
  \ (ensure proper cleanup of items, creature, spawn), and a `deepCopy()` method.\n\
  \   - Port methods like `addItem(Item* item)`, `getTopItem()`, `getItemAt(int index)`,\
  \ `popSelectedItems()`, `getSelectedItems()`. Pay close attention to the logic for\
  \ adding items, especially how ground items and items with ground equivalents are\
  \ handled.\n   - Port methods related to selection (`select()`, `deselect()`, `isSelected()`).\n\
  \   - Port methods for accessing `ground`, `creature`, `spawn`, `house_id`.\n  \
  \ - Port methods related to tile properties (`isPZ()`, `isBlocking()`, `hasProperty()`).\n\
  \   - The various `*ize` methods (`borderize`, `wallize`, `tableize`, `carpetize`)\
  \ and `clean*` methods (`cleanBorders`, `cleanWalls`) involve complex logic tied\
  \ to specific brush types and global settings (`g_settings`). For this task, you\
  \ can provide stubs for these methods, noting that their full implementation will\
  \ depend on the porting of brushes and settings systems. Focus on the core data\
  \ management aspects of the `Tile` class.\n\n**General Porting Instructions:**\n\
  \   - Replace wxWidgets types (like `wxNOT_FOUND`) with Qt or C++ STL equivalents\
  \ (e.g., `-1` or a suitable constant, `std::vector` or `QList` for `ItemVector`).\n\
  \   - Handle memory management carefully. Use smart pointers (e.g., `std::unique_ptr`,\
  \ `std::shared_ptr` or Qt's equivalents like `QScopedPointer`, `QSharedPointer`)\
  \ where appropriate, especially for objects owned by `Tile` (like items, creature,\
  \ spawn).\n   - Dependencies like `g_items`, `g_settings`, `BaseMap`, `TileLocation`,\
  \ `Creature`, `Spawn`, `Brush` subclasses are external. For the purpose of these\
  \ data structure classes, you can assume interfaces or stubs for them. The focus\
  \ is on the structure and internal logic of `Tile`, `Item`, and `Position`.\n  \
  \ - Ensure the ported classes are well-encapsulated.\n   - Provide header (.h) and\
  \ source (.cpp) files for each class.\n   - Include basic unit tests (e.g., using\
  \ Qt Test framework) to verify the functionality of the ported classes.\n"
