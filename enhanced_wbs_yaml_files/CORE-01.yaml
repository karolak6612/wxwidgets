wbs_item_id: CORE-01
name: Port Core Data Structures
description: Migrate fundamental data structures like Tile, Item, Position, and related container classes from `mapcore` to Qt6 equivalents or modern C++. This involves ensuring data integrity, compatibility, and performance.
dependencies: []
input_files:
- wxwidgets/tile.cpp
- wxwidgets/tile.h
- wxwidgets/item.cpp
- wxwidgets/item.h
- wxwidgets/position.h
analyzed_input_files:
- file_path: wxwidgets/tile.cpp
  description: Implementation of the Tile class, managing items, ground, creatures, spawns, and house information for a map location.
  md5_hash: dcaeab91c7c67a5bda5d6def40f1154c
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#include \"main.h\"\\n\\n#include \"\
    brush.h\"\\n\\n#include \"tile.h\"\\n#include \"creature.h\"\\n#include \"house.h\"\\n#include \"basemap.h\"\\n#include \"spawn.h\"\\n#include \"ground_brush.h\"\\n#include \"wall_brush.h\"\\n#include \"carpet_brush.h\"\\n#include \"table_brush.h\"\\n#include \"town.h\"\\n#include \"map.h\"\\n\\nTile::Tile(int x, int y, int z) :\\n\tlocation(nullptr),\\n\tground(nullptr),\\n\tcreature(nullptr),\\n\tspawn(nullptr),\\n\thouse_id(0),\\n\tmapflags(0),\\n\tstatflags(0),\\n\tminimapColor(INVALID_MINIMAP_COLOR) {\\n\t////\\n}\\n\\nTile::Tile(TileLocation& loc) :\\n\tlocation(&loc),\\n\tground(nullptr),\\n\tcreature(nullptr),\\n\tspawn(nullptr),\\n\thouse_id(0),\\n\tmapflags(0),\\n\tstatflags(0),\\n\tminimapColor(INVALID_MINIMAP_COLOR) {\\n\t////\\n}\\n\\nTile::~Tile() {\\n\tbool had_items = !items.empty();\\n\tbool had_ground = ground != nullptr;\\n\t\\n#ifdef __WXDEBUG__\\n\tif (had_ground) {\\n\t\t// Store ground info before deleting it\\n\t\tuint16_t ground_id = ground->getID();\\n\t\tvoid*\
    \ ground_ptr = ground;\\n\t\tprintf(\"DEBUG: Tile destructor for %p with ground %p (ID:%d)\\n\", this, ground_ptr, ground_id);\\n\t\t\\n\t\t// Get call stack info by adding a breakpoint variable\\n\t\tint debug_breakpoint_for_ground_deletion = 1;\\n\t}\\n#endif\\n\\n\twhile (!items.empty()) {\\n\t\tdelete items.back();\\n\t\titems.pop_back();\\n\t}\\n\tdelete creature;\\n\tdelete ground;\\n\tdelete spawn;\\n\t\\n#ifdef __WXDEBUG__\\n\tif (had_ground) {\\n\t\tprintf(\"DEBUG: Ground %p deleted\\n\", ground);\\n\t}\\n#endif\\n}\\n\\nTile* Tile::deepCopy(BaseMap& map) {\\n\tTile* copy = map.allocator.allocateTile(location);\\n\tcopy->flags = flags;\\n\tcopy->house_id = house_id;\\n\t\\n#ifdef __WXDEBUG__\\n\tprintf(\"DEBUG: deepCopy - Creating copy of tile %p (with ground %p)\\n\", \\n\t\tthis, ground);\\n#endif\\n\t\\n\tif (spawn) {\\n\t\tcopy->spawn = spawn->deepCopy();\\n\t}\\n\tif (creature) {\\n\t\tcopy->creature = creature->deepCopy();\\n\t}\\n\t// Spawncount & exits are not transferred\
    \ on copy!\\n\tif (ground) {\\n#ifdef __WXDEBUG__\\n\t\tprintf(\"DEBUG: deepCopy - Copying ground %p with ID %d\\n\", \\n\t\t\tground, ground->getID());\\n#endif\\n\t\tcopy->ground = ground->deepCopy();\\n#ifdef __WXDEBUG__\\n\t\tprintf(\"DEBUG: deepCopy - Ground copied to %p with ID %d\\n\", \\n\t\t\tcopy->ground, copy->ground->getID());\\n#endif\\n\t}\\n\\n\tcopy->setZoneIds(this);\\n\\n\tItemVector::iterator it;\\n\\n\tit = items.begin();\\n\twhile (it != items.end()) {\\n\t\tcopy->items.push_back((*it)->deepCopy());\\n\t\t++it;\\n\t}\\n\\n#ifdef __WXDEBUG__\\n\tprintf(\"DEBUG: deepCopy - Created tile copy %p (with ground %p)\\n\", \\n\t\tcopy, copy->ground);\\n#endif\\n\\n\treturn copy;\\n}\\n\\nuint32_t Tile::memsize() const {\\n\tuint32_t mem = sizeof(*this);\\n\tif (ground) {\\n\t\tmem += ground->memsize();\\n\t}\\n\\n\tItemVector::const_iterator it;\\n\\n\tit = items.begin();\\n\twhile (it != items.end()) {\\n\t\tmem += (*it)->memsize();\\n\t\t++it;\\n\t}\\n\\n\tmem += sizeof(Item*)\
    \ * items.capacity();\\n\\n\treturn mem;\\n}\\n\\nint Tile::size() const {\\n\tint sz = 0;\\n\tif (ground) {\\n\t\t++sz;\\n\t}\\n\tsz += items.size();\\n\tif (creature) {\\n\t\t++sz;\\n\t}\\n\tif (spawn) {\\n\t\t++sz;\\n\t}\\n\tif (location) {\\n\t\tif (location->getHouseExits()) {\\n\t\t\t++sz;\\n\t\t}\\n\t\tif (location->getSpawnCount()) {\\n\t\t\t++sz;\\n\t\t}\\n\t\tif (location->getWaypointCount()) {\\n\t\t\t++sz;\\n\t\t}\\n\t}\\n\treturn sz;\\n}\\n\\nvoid Tile::merge(Tile* other) {\\n\tif (other->isPZ()) {\\n\t\tsetPZ(true);\\n\t}\\n\tif (other->house_id) {\\n\t\thouse_id = other->house_id;\\n\t}\\n\\n\tif (other->ground) {\\n\t\tdelete ground;\\n\t\tground = other->ground;\\n\t\tother->ground = nullptr;\\n\t}\\n\\n\tif (other->creature) {\\n\t\tdelete creature;\\n\t\tcreature = other->creature;\\n\t\tother->creature = nullptr;\\n\t}\\n"
- file_path: wxwidgets/tile.h
  description: Header file for the Tile class, defining its structure and interface for managing map tile data.
  md5_hash: 5a95da1228867955cd113db0f16eed85
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#ifndef RME_TILE_H\\n#define RME_TILE_H\\\
    n\\n#include \"position.h\"\\n#include \"item.h\"\\n#include \"map_region.h\"\\n#include <unordered_set>\\n\\nenum {\\n\tTILESTATE_NONE = 0x0000,\\n\tTILESTATE_PROTECTIONZONE = 0x0001,\\n\tTILESTATE_DEPRECATED = 0x0002, // Reserved\\n\tTILESTATE_NOPVP = 0x0004,\\n\tTILESTATE_NOLOGOUT = 0x0008,\\n\tTILESTATE_PVPZONE = 0x0010,\\n\tTILESTATE_REFRESH = 0x0020,\\n\tTILESTATE_ZONE_BRUSH = 0x0040,\\n\t// Internal\\n\tTILESTATE_SELECTED = 0x0001,\\n\tTILESTATE_UNIQUE = 0x0002,\\n\tTILESTATE_BLOCKING = 0x0004,\\n\tTILESTATE_OP_BORDER = 0x0008, // If this is true, gravel will be placed on the tile!\\n\tTILESTATE_HAS_TABLE = 0x0010,\\n\tTILESTATE_HAS_CARPET = 0x0020,\\n\tTILESTATE_MODIFIED = 0x0040,\\n};\\n\\nenum : uint8_t {\\n\tINVALID_MINIMAP_COLOR = 0xFF\\n};\\n\\nclass Tile {\\npublic: // Members\\n\tTileLocation* location;\\n\tItem* ground;\\n\tItemVector items;\\n\tCreature* creature;\\n\tSpawn* spawn;\\n\tuint32_t house_id; // House id for this tile (pointer not safe)\\n\\npublic:\\n\t\
    // ALWAYS use this constructor if the Tile is EVER going to be placed on a map\\n\tTile(TileLocation& location);\\n\t// Use this when the tile is only used internally by the editor (like in certain brushes)\\n\tTile(int x, int y, int z);\\n\\n\t~Tile();\\n\\n\t// Argument is a the map to allocate the tile from\\n\tTile* deepCopy(BaseMap& map);\\n\\n\t// The location of the tile\\n\t// Stores state that remains between the tile being moved (like house exits)\\n\tvoid setLocation(TileLocation* where) {\\n\t\tlocation = where;\\n\t}\\n\tTileLocation* getLocation() {\\n\t\treturn location;\\n\t}\\n\tconst TileLocation* getLocation() const {\\n\t\treturn location;\\n\t}\\n\\n\t// Position of the tile\\n\tPosition getPosition() {\\n\t\treturn location->getPosition();\\n\t}\\n\tconst Position getPosition() const {\\n\t\treturn location->getPosition();\\n\t}\\n\tint getX() const {\\n\t\treturn location->getPosition().x;\\n\t}\\n\tint getY() const {\\n\t\treturn location->getPosition().y;\\n\t\
    }\\n\tint getZ() const {\\n\t\treturn location->getPosition().z;\\n\t}\\n\\npublic: // Functions\\n\t// Absorb the other tile into this tile\\n\tvoid merge(Tile* other);\\n\\n\t// Has tile been modified since the map was loaded/created?\\n\tbool isModified() const {\\n\t\treturn testFlags(statflags, TILESTATE_MODIFIED);\\n\t}\\n\tvoid modify() {\\n\t\tstatflags |= TILESTATE_MODIFIED;\\n\t}\\n\tvoid unmodify() {\\n\t\tstatflags &= ~TILESTATE_MODIFIED;\\n\t}\\n\\n\t// Get memory footprint size\\n\tuint32_t memsize() const;\\n\t// Get number of items on the tile\\n\tbool empty() const {\\n\t\treturn size() == 0;\\n\t}\\n\tint size() const;\\n\\n\t// Blocking?\\n\tbool isBlocking() const {\\n\t\treturn testFlags(statflags, TILESTATE_BLOCKING);\\n\t}\\n\\n\t// PZ\\n\tbool isPZ() const {\\n\t\treturn testFlags(mapflags, TILESTATE_PROTECTIONZONE);\\n\t}\\n\tvoid setPZ(bool pz) {\\n\t\tif (pz) {\\n\t\t\tmapflags |= TILESTATE_PROTECTIONZONE;\\n\t\t} else {\\n\t\t\tmapflags &= ~TILESTATE_PROTECTIONZONE;\\\
    n\t\t}\\n\t}\\n\\n\tbool hasProperty(enum ITEMPROPERTY prop) const;\\n\\n\tint getIndexOf(Item* item) const;\\n\tItem* getTopItem() const; // Returns the topmost item, or nullptr if the tile is empty\\n\tItem* getItemAt(int index) const;\\n\tvoid addItem(Item* item);\\n\\n\tvoid select();\\n\tvoid deselect();\\n\t// This selects borders too\\n\tvoid selectGround();\\n\tvoid deselectGround();\\n\\n\tbool isSelected() const {\\n\t\treturn testFlags(statflags, TILESTATE_SELECTED);\\n\t}\\n\tbool hasUniqueItem() const {\\n\t\treturn testFlags(statflags, TILESTATE_UNIQUE);\\n\t}\\n\\n\tItemVector popSelectedItems(bool ignoreTileSelected = false);\\n\tItemVector getSelectedItems(bool unzoomed = false);\\n\tItem* getTopSelectedItem();\\n\\n\t// Refresh internal flags (such as selected etc.)\\n\tvoid update();\\n\\n\tuint8_t getMiniMapColor() const;\\n\\n\t// Does this tile have ground?\\n\tbool hasGround() const {\\n\t\treturn ground != nullptr;\\n\t}\\n\tbool hasBorders() const {\\n\t\treturn\
    \ items.size() && items[0]->isBorder();\\n\t}\\n\\n\t// Get the border brush of this tile\\n\tGroundBrush* getGroundBrush() const;\\n\\n\t// Remove all borders (for autoborder)\\n\tvoid cleanBorders();\\n\\n\t// Add a border item (added at the bottom of all items)\\n\tvoid addBorderItem(Item* item);\\n\\n\t// Borderize this tile\\n\tvoid borderize(BaseMap* parent);\\n\\n\tbool hasTable() const {\\n\t\treturn testFlags(statflags, TILESTATE_HAS_TABLE);\\n\t}\\n\tItem* getTable() const;\\n\\n\tbool hasCarpet() const {\\n\t\treturn testFlags(statflags, TILESTATE_HAS_CARPET);\\n\t}\\n\tItem* getCarpet() const;\\n\\n\tbool hasOptionalBorder() const {\\n\t\treturn testFlags(statflags, TILESTATE_OP_BORDER);\\n\t}\\n\tvoid setOptionalBorder(bool b) {"
- file_path: wxwidgets/item.cpp
  description: Implementation of the Item class and its derived classes (Container, Teleport, Door, Podium), including attribute management and factory methods.
  md5_hash: 75367a50323b6ce32506183869b0bf07
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#include \"main.h\"\\n\\n#include \"\
    brush.h\"\\n#include \"graphics.h\"\\n#include \"gui.h\"\\n#include \"tile.h\"\\n#include \"complexitem.h\"\\n#include \"iomap.h\"\\n#include \"item.h\"\\n\\n#include \"ground_brush.h\"\\n#include \"carpet_brush.h\"\\n#include \"table_brush.h\"\\n#include \"wall_brush.h\"\\n\\nItem* Item::Create(uint16_t _type, uint16_t _subtype /*= 0xFFFF*/) {\\n\tif (_type == 0) {\\n\t\treturn nullptr;\\n\t}\\n\tItem* newItem = nullptr;\\n\\n\tconst ItemType& it = g_items[_type];\\n\\n\tif (it.id != 0) {\\n\t\tif (it.isDepot()) {\\n\t\t\tnewItem = newd Depot(_type);\\n\t\t} else if (it.isContainer()) {\\n\t\t\tnewItem = newd Container(_type);\\n\t\t} else if (it.isTeleport()) {\\n\t\t\tnewItem = newd Teleport(_type);\\n\t\t} else if (it.isDoor()) {\\n\t\t\tnewItem = newd Door(_type);\\n\t\t} else if (it.isPodium()) {\\n\t\t\tnewItem = newd Podium(_type);\\n\t\t} else if (_subtype == 0xFFFF) {\\n\t\t\tif (it.isFluidContainer()) {\\n\t\t\t\tnewItem = newd Item(_type, LIQUID_NONE);\\n\t\t\t} else if (it.isSplash())\
    \ {\\n\t\t\t\tnewItem = newd Item(_type, LIQUID_WATER);\\n\t\t\t} else if (it.charges > 0) {\\n\t\t\t\tnewItem = newd Item(_type, it.charges);\\n\t\t\t} else {\\n\t\t\t\tnewItem = newd Item(_type, 1);\\n\t\t\t}\\n\t\t} else {\\n\t\t\tnewItem = newd Item(_type, _subtype);\\n\t\t}\\n\t} else {\\n\t\tnewItem = newd Item(_type, _subtype);\\n\t}\\n\\n\treturn newItem;\\n}\\n\\nItem::Item(unsigned short _type, unsigned short _count) :\\n\tid(_type),\\n\tsubtype(1),\\n\tselected(false),\\n\tframe(0) {\\n\tif (hasSubtype()) {\\n\t\tsubtype = _count;\\n\t}\\n}\\n\\nItem::~Item() {\\n\t////\\n}\\n\\nItem* Item::deepCopy() const {\\n\tItem* copy = Create(id, subtype);\\n\tif (copy) {\\n\t\tcopy->selected = selected;\\n\t\tif (attributes) {\\n\t\t\tcopy->attributes = newd ItemAttributeMap(*attributes);\\n\t\t}\\n\t}\\n\treturn copy;\\n}\\n\\nItem* transformItem(Item* old_item, uint16_t new_id, Tile* parent) {\\n\tif (old_item == nullptr) {\\n\t\treturn nullptr;\\n\t}\\n\\n\told_item->setID(new_id);\\\
    n\t// Through the magic of deepCopy, this will now be a pointer to an item of the correct type.\\n\tItem* new_item = old_item->deepCopy();\\n\tif (parent) {\\n\t\t// Find the old item and remove it from the tile, insert this one instead!\\n\t\tif (old_item == parent->ground) {\\n\t\t\tdelete old_item;\\n\t\t\tparent->ground = new_item;\\n\t\t\treturn new_item;\\n\t\t}\\n\\n\t\tstd::queue<Container*> containers;\\n\t\tfor (ItemVector::iterator item_iter = parent->items.begin(); item_iter != parent->items.end(); ++item_iter) {\\n\t\t\tif (*item_iter == old_item) {\\n\t\t\t\tdelete old_item;\\n\t\t\t\titem_iter = parent->items.erase(item_iter);\\n\t\t\t\tparent->items.insert(item_iter, new_item);\\n\t\t\t\treturn new_item;\\n\t\t\t}\\n\\n\t\t\tContainer* c = dynamic_cast<Container*>(*item_iter);\\n\t\t\tif (c) {\\n\t\t\t\tcontainers.push(c);\\n\t\t\t}\\n\t\t}\\n\\n\t\twhile (containers.size() != 0) {\\n\t\t\tContainer* container = containers.front();\\n\t\t\tItemVector& v = container->getVector();\\\
    n\t\t\tfor (ItemVector::iterator item_iter = v.begin(); item_iter != v.end(); ++item_iter) {\\n\t\t\t\tItem* i = *item_iter;\\n\t\t\t\tContainer* c = dynamic_cast<Container*>(i);\\n\t\t\t\tif (c) {\\n\t\t\t\t\tcontainers.push(c);\\n\t\t\t\t}\\n\\n\t\t\t\tif (i == old_item) {\\n\t\t\t\t\t// Found it!\\n\t\t\t\t\titem_iter = v.erase(item_iter);\\n\t\t\t\t\tv.insert(item_iter, new_item);\\n\t\t\t\t\treturn new_item;\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tcontainers.pop();\\n\t\t}\\n\t}\\n\\n\tdelete new_item;\\n\treturn nullptr;\\n}\\n\\nuint32_t Item::memsize() const {\\n\tuint32_t mem = sizeof(*this);\\n\treturn mem;\\n}\\n\\nvoid Item::setID(uint16_t newid) {\\n\tid = newid;\\n}\\n\\nvoid Item::setSubtype(uint16_t n) {\\n\tsubtype = n;\\n}\\n\\nbool Item::hasSubtype() const {\\n\tconst ItemType& it = g_items[id];\\n\treturn (it.isFluidContainer() || it.isSplash() || isCharged() || it.stackable || it.charges != 0);\\n}\\n\\nuint16_t Item::getSubtype() const {\\n\tif (hasSubtype()) {\\n\t\treturn\
    \ subtype;\\n\t}\\n\treturn 0;\\n}\\n\\nbool Item::hasProperty(enum ITEMPROPERTY prop) const {\\n\tconst ItemType& it = g_items[id];\\n\tswitch (prop) {\\n\t\tcase BLOCKSOLID:\\n\t\t\tif (it.unpassable) {\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t\tbreak;\\n\\n\t\tcase MOVEABLE:\\n\t\t\tif (it.moveable && getUniqueID() == 0) {\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t\tbreak;\\n\t\t\t/*\\n\t\t\t\t\tcase HASHEIGHT:\\n\t\t\t\t\t\tif(it.height != 0 )\\n\t\t\t\t\t\t\treturn true;\\n\t\t\t\t\t\tbreak;\\n\t\t\t*/\\n\t\tcase BLOCKPROJECTILE:\\n\t\t\tif (it.blockMissiles) {\\n\t\t\t\treturn true;"
- file_path: wxwidgets/item.h
  description: Header file for the Item class and related enums/structs, defining the base item properties and interface.
  md5_hash: 73714a92363845f12e0ed7dd71e34328
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#ifndef RME_ITEM_H_\\n#define RME_ITEM_H_\\\
    n\\n#include \"items.h\"\\n#include \"iomap_otbm.h\"\\n// #include \"iomap_otmm.h\"\\n#include \"item_attributes.h\"\\n#include \"doodad_brush.h\"\\n#include \"raw_brush.h\"\\n\\nclass Creature;\\nclass Border;\\nclass Tile;\\n\\nstruct SpriteLight;\\n\\nenum ITEMPROPERTY {\\n\tBLOCKSOLID,\\n\tHASHEIGHT,\\n\tBLOCKPROJECTILE,\\n\tBLOCKPATHFIND,\\n\tPROTECTIONZONE,\\n\tHOOK_SOUTH,\\n\tHOOK_EAST,\\n\tMOVEABLE,\\n\tBLOCKINGANDNOTMOVEABLE,\\n\tHASLIGHT\\n};\\n\\nenum SplashType {\\n\tLIQUID_NONE = 0,\\n\tLIQUID_WATER = 1,\\n\tLIQUID_BLOOD = 2,\\n\tLIQUID_BEER = 3,\\n\tLIQUID_SLIME = 4,\\n\tLIQUID_LEMONADE = 5,\\n\tLIQUID_MILK = 6,\\n\tLIQUID_MANAFLUID = 7,\\n\tLIQUID_INK = 8,\\n\tLIQUID_WATER2 = 9,\\n\tLIQUID_LIFEFLUID = 10,\\n\tLIQUID_OIL = 11,\\n\tLIQUID_SLIME2 = 12,\\n\tLIQUID_URINE = 13,\\n\tLIQUID_COCONUT_MILK = 14,\\n\tLIQUID_WINE = 15,\\n\tLIQUID_MUD = 19,\\n\tLIQUID_FRUIT_JUICE = 21,\\n\tLIQUID_LAVA = 26,\\n\tLIQUID_RUM = 27,\\n\tLIQUID_SWAMP = 28,\\n\tLIQUID_TEA = 35,\\n\tLIQUID_MEAD\
    \ = 43,\\n\\n\tLIQUID_FIRST = LIQUID_WATER,\\n\tLIQUID_LAST = LIQUID_MEAD\\n};\\n\\nIMPLEMENT_INCREMENT_OP(SplashType)\\n\\nclass Item : public ItemAttributes {\\npublic:\\n\t// Factory member to create item of right type based on type\\n\tstatic Item* Create(uint16_t _type, uint16_t _subtype = 0xFFFF);\\n\tstatic Item* Create(pugi::xml_node);\\n\tstatic Item* Create_OTBM(const IOMap& maphandle, BinaryNode* stream);\\n\t// static Item* Create_OTMM(const IOMap& maphandle, BinaryNode* stream);\\n\\nprotected:\\n\t// Constructor for items\\n\tItem(unsigned short _type, unsigned short _count);\\n\\npublic:\\n\tvirtual ~Item();\\n\\n\t// Deep copy thingy\\n\tvirtual Item* deepCopy() const;\\n\\n\t// Get memory footprint size\\n\tuint32_t memsize() const;\\n\t/*\\n\tvirtual Container* getContainer() {return nullptr;}\\n\tvirtual const Container* getContainer() const {return nullptr;}\\n\tvirtual Teleport* getTeleport() {return nullptr;}\\n\tvirtual const Teleport* getTeleport() const {return\
    \ nullptr;}\\n\tvirtual TrashHolder* getTrashHolder() {return nullptr;}\\n\tvirtual const TrashHolder* getTrashHolder() const {return nullptr;}\\n\tvirtual Mailbox* getMailbox() {return nullptr;}\\n\tvirtual const Mailbox* getMailbox() const {return nullptr;}\\n\tvirtual Door* getDoor() {return nullptr;}\\n\tvirtual const Door* getDoor() const {return nullptr;}\\n\tvirtual MagicField* getMagicField() {return nullptr;}\\n\tvirtual const MagicField* getMagicField() const {return nullptr;}\\n\t*/\\n\\n\t// OTBM map interface\\n\t// Serialize and unserialize (for save/load)\\n\t// Used internally\\n\tvirtual bool readItemAttribute_OTBM(const IOMap& maphandle, OTBM_ItemAttribute attr, BinaryNode* stream);\\n\tvirtual bool unserializeAttributes_OTBM(const IOMap& maphandle, BinaryNode* stream);\\n\tvirtual bool unserializeItemNode_OTBM(const IOMap& maphandle, BinaryNode* node);\\n\\n\t// Will return a node containing this item\\n\tvirtual bool serializeItemNode_OTBM(const IOMap& maphandle,\
    \ NodeFileWriteHandle& f) const;\\n\t// Will write this item to the stream supplied in the argument\\n\tvirtual void serializeItemCompact_OTBM(const IOMap& maphandle, NodeFileWriteHandle& f) const;\\n\tvirtual void serializeItemAttributes_OTBM(const IOMap& maphandle, NodeFileWriteHandle& f) const;\\n\\n\t// OTMM map interface\\n\t/*\\n\t// Serialize and unserialize (for save/load)\\n\t// Used internally\\n\tvirtual bool readItemAttribute_OTMM(const IOMap& maphandle, OTMM_ItemAttribute attr, BinaryNode* stream);\\n\tvirtual bool unserializeAttributes_OTMM(const IOMap& maphandle, BinaryNode* stream);\\n\tvirtual bool unserializeItemNode_OTMM(const IOMap& maphandle, BinaryNode* node);\\n\\n\t// Will return a node containing this item\\n\tvirtual bool serializeItemNode_OTMM(const IOMap& maphandle, NodeFileWriteHandle& f) const;\\n\t// Will write this item to the stream supplied in the argument\\n\tvirtual void serializeItemCompact_OTMM(const IOMap& maphandle, NodeFileWriteHandle& f) const;\\\
    n\tvirtual void serializeItemAttributes_OTMM(const IOMap& maphandle, NodeFileWriteHandle& f) const;\\n\t*/\\n\\n\t// Static conversions\\n\tstatic std::string LiquidID2Name(uint16_t id);\\n\tstatic uint16_t LiquidName2ID(std::string id);\\n\\n\t// IDs\\n\tuint16_t getID() const {\\n\t\treturn id;\\n\t}\\n\tuint16_t getClientID() const {\\n\t\treturn g_items[id].clientID;\\n\t}\\n\t// NOTE: This is very volatile, do NOT use this unless you know exactly what you're doing\\n\t// which you probably don't so avoid it like the plague!\\n\tvoid setID(uint16_t id);\\n\\n\tbool typeExists() const {\\n\t\treturn g_items.typeExists(id);\\n\t}\\n\\n\t// Usual attributes\\n\tvirtual double getWeight() const;\\n\tint getAttack() const {\\n\t\treturn g_items[id].attack;\\n\t}\\n\tint getArmor() const {\\n\t\treturn g_items[id].armor;\\n\t}\\n\tint getDefense() const {\\n\t\treturn g_items[id].defense;\\n\t}\\n\tuint16_t getSlotPosition() const {\\n\t\treturn g_items[id].slot_position;\\n\t}\\n\tuint8_t\
    \ getWeaponType() const {\\n\t\treturn g_items[id].weapon_type;\\n\t}\\n\tuint8_t getClassification() const {\\n\t\treturn g_items[id].classification;\\n\t} // 12.81\\n\\n\t// Item g_settings\\n\tbool canHoldText() const;\\n\tbool canHoldDescription() const;\\n\tbool isReadable() const {\\n\t\treturn g_items[id].canReadText;\\n\t}\\n\tbool canWriteText() const {\\n\t\treturn g_items[id].canWriteText;\\n\t}\\n\tuint32_t getMaxWriteLength() const {\\n\t\treturn g_items[id].maxTextLen;\\n\t}\\n\tBrush* getBrush() const {\\n\t\treturn g_items[id].brush;\\n\t}\\n\tGroundBrush* getGroundBrush() const;\\n\tWallBrush* getWallBrush() const;\\n\tDoorBrush* getDoorBrush() const;\\n\tTableBrush* getTableBrush() const;\\n\tCarpetBrush* getCarpetBrush() const;"
- file_path: wxwidgets/position.h
  description: Header file for the Position struct, defining 3D coordinates and related operators.
  md5_hash: a761a633c10ed09df233692b7f04ef2d
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#ifndef __POSITION_HPP__\\n#define\
    \ __POSITION_HPP__\\n\\n#include <ostream>\\n#include <cstdint>\\n#include <vector>\\n#include <list>\\n\\nclass SmallPosition;\\n\\nclass Position {\\npublic:\\n\t// We use int since it's the native machine type and can be several times faster than\\n\t// the other integer types in most cases, also, the position may be negative in some\\n\t// cases\\n\tint x, y, z;\\n\\n\tPosition() :\\n\t\tx(0), y(0), z(0) { }\\n\tPosition(int _x, int _y, int _z) :\\n\t\tx(_x), y(_y), z(_z) { }\\n\\n\tbool operator<(const Position& p) const {\\n\t\tif (z < p.z) {\\n\t\t\treturn true;\\n\t\t}\\n\t\tif (z > p.z) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tif (y < p.y) {\\n\t\t\treturn true;\\n\t\t}\\n\t\tif (y > p.y) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tif (x < p.x) {\\n\t\t\treturn true;\\n\t\t}\\n\t\t// if(x > p.x)\\n\t\t//\treturn false;\\n\\n\t\treturn false;\\n\t}\\n\\n\tbool operator>(const Position& p) const {\\n\t\treturn !(*this < p);\\n\t}\\n\\n\tPosition operator-(const Position& p) const\
    \ {\\n\t\tPosition newpos;\\n\t\tnewpos.x = x - p.x;\\n\t\tnewpos.y = y - p.y;\\n\t\tnewpos.z = z - p.z;\\n\t\treturn newpos;\\n\t}\\n\\n\tPosition operator+(const Position& p) const {\\n\t\tPosition newpos;\\n\t\tnewpos.x = x + p.x;\\n\t\tnewpos.y = y + p.y;\\n\t\tnewpos.z = z + p.z;\\n\t\treturn newpos;\\n\t}\\n\\n\tPosition& operator+=(const Position& p) {\\n\t\t*this = *this + p;\\n\t\treturn *this;\\n\t}\\n\\n\tbool operator==(const Position& p) const {\\n\t\treturn p.x == x && p.y == y && p.z == z;\\n\t}\\n\\n\tbool operator!=(const Position& p) const {\\n\t\treturn !(*this == p);\\n\t}\\n\\n\tbool isValid() const;\\n};\\n\\ninline std::ostream& operator<<(std::ostream& os, const Position& pos) {\\n\tos << pos.x << ':' << pos.y << ':' << pos.z;\\n\treturn os;\\n}\\n\\ninline std::istream& operator>>(std::istream& is, Position& pos) {\\n\tchar a, b;\\n\tint x, y, z;\\n\tis >> x;\\n\tif (!is) {\\n\t\treturn is;\\n\t}\\n\tis >> a;\\n\tif (!is || a != ':') {\\n\t\treturn is;\\n\t}\\\
    n\tis >> y;\\n\tif (!is) {\\n\t\treturn is;\\n\t}\\n\tis >> b;\\n\tif (!is || b != ':') {\\n\t\treturn is;\\n\t}\\n\tis >> z;\\n\tif (!is) {\\n\t\treturn is;\\n\t}\\n\\n\tpos.x = x;\\n\tpos.y = y;\\n\tpos.z = z;\\n\\n\treturn is;\\n}\\n\\ninline bool Position::isValid() const {\\n\treturn x >= 0 && x <= MAP_MAX_WIDTH && y >= 0 && y <= MAP_MAX_HEIGHT && z >= 0 && z <= MAP_MAX_LAYER;\\n}\\n\\ninline Position abs(const Position& position) {\\n\treturn Position(\\n\t\tstd::abs(position.x),\\n\t\tstd::abs(position.y),\\n\t\tstd::abs(position.z)\\n\t);\\n}\\n\\ntypedef std::vector<Position> PositionVector;\\ntypedef std::list<Position> PositionList;\\n\\n#endif"
documentation_references:
- 'Qt Core Data Types: https://doc.qt.io/qt-6/qtcore-module.html'
- 'QList: https://doc.qt.io/qt-6/qlist.html'
- 'QVector: https://doc.qt.io/qt-6/qvector.html'
- 'QMap: https://doc.qt.io/qt-6/qmap.html'
- 'QString: https://doc.qt.io/qt-6/qstring.html'
- 'QVariant: https://doc.qt.io/qt-6/qvariant.html'
- 'Qt Test Framework: https://doc.qt.io/qt-6/qttest-module.html'
current_functionality_summary: |-
  The wxWidgets-based `Tile` class manages a ground item, a list of other items, an optional creature, an optional spawn object, and house ID, along with various flags. It handles item addition logic, selection, and property queries (like blocking status).
  The `Item` class, along with `ItemAttributes`, stores item ID, subtype, and custom attributes (UID, AID, text, description). It includes a factory `Item::Create` for different item types (Container, Teleport, Door, Podium derive from Item).
  The `Position` struct is a simple 3D coordinate (x, y, z) with comparison and arithmetic operators.
definition_of_done:
- Qt6/C++ equivalent classes for `Tile`, `Item`, and `Position` are implemented.
- All significant methods and properties from the original `Tile`, `Item`, and `Position` classes (as seen in the provided snippets) are ported or have clear equivalents in the new Qt6/C++ classes.
- 'Data integrity for core attributes is maintained:'
- '  - `Tile` correctly manages its list of `Item` objects, `ground` item, `Creature*`, `Spawn*`, and `house_id`.'
- '  - `Item` correctly manages its `id`, `subtype`, and attributes (like UID, AID, text, description) based on `ItemAttributes`.'
- '  - `Position` accurately stores x, y, z coordinates.'
- Memory management for objects created and managed by these classes (especially items within tiles) is handled using modern C++ practices (e.g., smart pointers where appropriate).
- The new classes are designed to be largely self-contained or rely on well-defined interfaces for external dependencies (e.g., `g_items` for item properties, `TileLocation`).
- 'Basic unit tests are created for the new `Tile`, `Item`, and `Position` classes, covering:'
- '  - Object construction and initialization.'
- '  - Correct handling of attributes and data members.'
- '  - Key functionalities like adding/removing items from a tile, item creation, position manipulation.'
- The ported code compiles successfully within a Qt6 project structure.
- A brief report is provided detailing the mapping from the old class structures to the new ones, highlighting any significant design changes or assumptions made.
boilerplate_coder_ai_prompt: |
  The user wants to migrate core data structures from an old C++/wxWidgets application to Qt6/modern C++.
  Analyze the provided C++ header and source file snippets for `Tile` (from `wxwidgets/tile.cpp` and `wxwidgets/tile.h`), `Item` (from `wxwidgets/item.cpp` and `wxwidgets/item.h`), and `Position` (from `wxwidgets/position.h`).

  **1. Position Class/Struct:**
     - Create a simple Qt-idiomatic or modern C++ class/struct for `Position` based on `position.h`. It should store `x`, `y`, and `z` coordinates.
     - Implement comparison operators (`<`, `==`, `!=`) and arithmetic operators (`+`, `-`, `+=`) as seen in `position.h`.
     - Ensure it's lightweight and efficient.

  **2. Item Class:**
     - Design a Qt-idiomatic or modern C++ class for `Item` based on `item.h` and `item.cpp`.
     - The class should store the item's `id` and `subtype`.
     - It should inherit from or incorporate a mechanism similar to `ItemAttributes` to manage custom attributes (e.g., `uid`, `aid`, `text`, `desc`, `tier`). Consider using a `QVariantMap` or a similar structure for attributes if a direct port of `ItemAttributeMap` is too complex for this task.
     - Implement a static factory method `Item::Create(uint16_t id, uint16_t subtype)` that constructs an Item. For complex item types (like `Container`, `Teleport`, `Door`, `Podium` which are mentioned in `Item::Create` but whose definitions are not provided), the factory can return a base `Item` object for now, or you can define placeholder derived classes if simple.
     - Implement a `deepCopy()` method.
     - Port methods like `getID()`, `getSubtype()`, `setSubtype()`, `hasSubtype()`, `getWeight()`, `getName()`, `getFullName()`, selection status (`isSelected`, `select`, `deselect`).
     - For item properties (e.g., `isBlocking()`, `isStackable()`, `isGroundTile()`), these often depend on a global item metadata store (`g_items`). For the ported `Item` class, assume such a store will be available (e.g., via a singleton or a passed-in service). You can define an interface for this (e.g., `ItemMetadataService::getItemType(uint16_t id)`).
     - Address how item attributes like UID, AID, text, description, and tier are set and retrieved (e.g., `setUniqueID`, `getActionID`, `setText`).

  **3. Tile Class:**
     - Design a Qt-idiomatic or modern C++ class for `Tile` based on `tile.h` and `tile.cpp`.
     - A `Tile` should be associated with a `Position` (either by composition or by reference/pointer if `TileLocation` is complex).
     - It must manage:
       - A `ground` item (pointer to `Item`).
       - A collection of `Item` objects (e.g., `QList<Item*>`).
       - A pointer to a `Creature` object (`Creature* creature`).
       - A pointer to a `Spawn` object (`Spawn* spawn`).
       - A `house_id` (uint32_t).
       - Tile flags (`mapflags`, `statflags`).
     - Implement constructors, destructor (ensure proper cleanup of items, creature, spawn), and a `deepCopy()` method.
     - Port methods like `addItem(Item* item)`, `getTopItem()`, `getItemAt(int index)`, `popSelectedItems()`, `getSelectedItems()`. Pay close attention to the logic for adding items, especially how ground items and items with ground equivalents are handled.
     - Port methods related to selection (`select()`, `deselect()`, `isSelected()`).
     - Port methods for accessing `ground`, `creature`, `spawn`, `house_id`.
     - Port methods related to tile properties (`isPZ()`, `isBlocking()`, `hasProperty()`).
     - The various `*ize` methods (`borderize`, `wallize`, `tableize`, `carpetize`) and `clean*` methods (`cleanBorders`, `cleanWalls`) involve complex logic tied to specific brush types and global settings (`g_settings`). For this task, you can provide stubs for these methods, noting that their full implementation will depend on the porting of brushes and settings systems. Focus on the core data management aspects of the `Tile` class.

  **General Porting Instructions:**
     - Replace wxWidgets types (like `wxNOT_FOUND`) with Qt or C++ STL equivalents (e.g., `-1` or a suitable constant, `std::vector` or `QList` for `ItemVector`).
     - Handle memory management carefully. Use smart pointers (e.g., `std::unique_ptr`, `std::shared_ptr` or Qt's equivalents like `QScopedPointer`, `QSharedPointer`) where appropriate, especially for objects owned by `Tile` (like items, creature, spawn).
     - Dependencies like `g_items`, `g_settings`, `BaseMap`, `TileLocation`, `Creature`, `Spawn`, `Brush` subclasses are external. For the purpose of these data structure classes, you can assume interfaces or stubs for them. The focus is on the structure and internal logic of `Tile`, `Item`, and `Position`.
     - Ensure the ported classes are well-encapsulated.
     - Provide header (.h) and source (.cpp) files for each class.
     - Include basic unit tests (e.g., using Qt Test framework) to verify the functionality of the ported classes.
