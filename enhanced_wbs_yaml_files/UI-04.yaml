wbs_item_id: UI-04
name: Port Item Properties & Editors
description: Recreate UI dialogs for viewing and editing properties of map items (general, container contents, custom attributes), creatures (spawn time, direction), and spawns (radius) using Qt6.
dependencies:
- 'CORE-02 # For ItemDatabase to get item type information and attributes.'
- 'UI-06   # Item finder dialog might be used by container editor.# Implicitly depends on Map, Tile, Item, Creature, Spawn data structures.'
input_files:
- wxwidgets/properties_window.cpp
- wxwidgets/properties_window.h
- wxwidgets/old_properties_window.cpp
- wxwidgets/old_properties_window.h
- wxwidgets/container_properties_window.cpp
- wxwidgets/container_properties_window.h
analyzed_input_files:
- file_path: wxwidgets/properties_window.cpp
  description: Implements PropertiesWindow, a wxDialog with a wxNotebook for editing item properties (General, Contents for containers, Advanced custom attributes using wxGrid).
  md5_hash: 44ada4137bebb1d39cfe1193d043bff7
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#include \"main.h\"\\n\\n#include \"\
    properties_window.h\"\\n\\n#include \"gui_ids.h\"\\n#include \"complexitem.h\"\\n#include \"container_properties_window.h\"\\n\\n#include <wx/grid.h>\\n\\nBEGIN_EVENT_TABLE(PropertiesWindow, wxDialog)\\nEVT_BUTTON(wxID_OK, PropertiesWindow::OnClickOK)\\nEVT_BUTTON(wxID_CANCEL, PropertiesWindow::OnClickCancel)\\n\\nEVT_BUTTON(ITEM_PROPERTIES_ADD_ATTRIBUTE, PropertiesWindow::OnClickAddAttribute)\\nEVT_BUTTON(ITEM_PROPERTIES_REMOVE_ATTRIBUTE, PropertiesWindow::OnClickRemoveAttribute)\\n\\nEVT_NOTEBOOK_PAGE_CHANGED(wxID_ANY, PropertiesWindow::OnNotebookPageChanged)\\n\\nEVT_GRID_CELL_CHANGED(PropertiesWindow::OnGridValueChanged)\\nEND_EVENT_TABLE()\\n\\nPropertiesWindow::PropertiesWindow(wxWindow* parent, const Map* map, const Tile* tile_parent, Item* item, wxPoint pos) :\\n\tObjectPropertiesWindowBase(parent, \"Item Properties\", map, tile_parent, item, pos),\\n\tcurrentPanel(nullptr) {\\n\tASSERT(edit_item);\\n\tnotebook = newd wxNotebook(this, wxID_ANY, wxDefaultPosition, wxSize(600,\
    \ 300));\\n\\n\tnotebook->AddPage(createGeneralPanel(notebook), \"Simple\", true);\\n\tif (dynamic_cast<Container*>(item)) {\\n\t\tnotebook->AddPage(createContainerPanel(notebook), \"Contents\");\\n\t}\\n\tnotebook->AddPage(createAttributesPanel(notebook), \"Advanced\");\\n\\n\twxSizer* topSizer = newd wxBoxSizer(wxVERTICAL);\\n\ttopSizer->Add(notebook, wxSizerFlags(1).DoubleBorder());\\n\\n\twxSizer* optSizer = newd wxBoxSizer(wxHORIZONTAL);\\n\toptSizer->Add(newd wxButton(this, wxID_OK, \"OK\"), wxSizerFlags(0).Center());\\n\toptSizer->Add(newd wxButton(this, wxID_CANCEL, \"Cancel\"), wxSizerFlags(0).Center());\\n\ttopSizer->Add(optSizer, wxSizerFlags(0).Center().DoubleBorder());\\n\\n\tSetSizerAndFit(topSizer);\\n\tCentre(wxBOTH);\\n}\\n\\nPropertiesWindow::~PropertiesWindow() {\\n\t;\\n}\\n\\nvoid PropertiesWindow::Update() {\\n\tContainer* container = dynamic_cast<Container*>(edit_item);\\n\tif (container) {\\n\t\tfor (uint32_t i = 0; i < container->getVolume(); ++i) {\\n\t\t\t\
    container_items[i]->setItem(container->getItem(i));\\n\t\t}\\n\t}\\n\twxDialog::Update();\\n}\\n\\nwxWindow* PropertiesWindow::createGeneralPanel(wxWindow* parent) {\\n\twxPanel* panel = newd wxPanel(parent, ITEM_PROPERTIES_GENERAL_TAB);\\n\twxFlexGridSizer* gridsizer = newd wxFlexGridSizer(2, 10, 10);\\n\tgridsizer->AddGrowableCol(1);\\n\\n\tgridsizer->Add(newd wxStaticText(panel, wxID_ANY, \"ID \" + i2ws(edit_item->getID())));\\n\tgridsizer->Add(newd wxStaticText(panel, wxID_ANY, \"\"\" + wxstr(edit_item->getName()) + \"\"\"));\\n\\n\tgridsizer->Add(newd wxStaticText(panel, wxID_ANY, \"Action ID\"));\\n\twxSpinCtrl* action_id_field = newd wxSpinCtrl(panel, wxID_ANY, i2ws(edit_item->getActionID()), wxDefaultPosition, wxDefaultSize, wxSP_ARROW_KEYS, 0, 0xFFFF, edit_item->getActionID());\\n\tgridsizer->Add(action_id_field, wxSizerFlags(1).Expand());\\n\\n\tgridsizer->Add(newd wxStaticText(panel, wxID_ANY, \"Unique ID\"));\\n\twxSpinCtrl* unique_id_field = newd wxSpinCtrl(panel, wxID_ANY,\
    \ i2ws(edit_item->getUniqueID()), wxDefaultPosition, wxSize(-1, 20), wxSP_ARROW_KEYS, 0, 0xFFFF, edit_item->getUniqueID());\\n\tgridsizer->Add(unique_id_field, wxSizerFlags(1).Expand());\\n\\n\tpanel->SetSizerAndFit(gridsizer);\\n\\n\treturn panel;\\n}\\n\\nwxWindow* PropertiesWindow::createContainerPanel(wxWindow* parent) {\\n\tContainer* container = (Container*)edit_item;\\n\twxPanel* panel = newd wxPanel(parent, ITEM_PROPERTIES_CONTAINER_TAB);\\n\twxSizer* topSizer = newd wxBoxSizer(wxVERTICAL);\\n\\n\twxSizer* gridSizer = newd wxGridSizer(6, 5, 5);\\n\\n\tbool use_large_sprites = g_settings.getBoolean(Config::USE_LARGE_CONTAINER_ICONS);\\n\tfor (uint32_t i = 0; i < container->getVolume(); ++i) {\\n\t\tItem* item = container->getItem(i);\\n\t\tContainerItemButton* containerItemButton = newd ContainerItemButton(panel, use_large_sprites, i, edit_map, item);\\n\\n\t\tcontainer_items.push_back(containerItemButton);\\n\t\tgridSizer->Add(containerItemButton, wxSizerFlags(0));\\n\t}\\n\\\
    n\ttopSizer->Add(gridSizer, wxSizerFlags(1).Expand());\\n\\n\t/*\\n\twxSizer* optSizer = newd wxBoxSizer(wxHORIZONTAL);\\n\toptSizer->Add(newd wxButton(panel, ITEM_PROPERTIES_ADD_ATTRIBUTE, \"Add Item\"), wxSizerFlags(0).Center());\\n\t// optSizer->Add(newd wxButton(panel, ITEM_PROPERTIES_REMOVE_ATTRIBUTE, \"Remove Attribute\"), wxSizerFlags(0).Center());\\n\ttopSizer->Add(optSizer, wxSizerFlags(0).Center().DoubleBorder());\\n\t*/\\n\\n\tpanel->SetSizer(topSizer);\\n\treturn panel;\\n}\\n\\nwxWindow* PropertiesWindow::createAttributesPanel(wxWindow* parent) {\\n\twxPanel* panel = newd wxPanel(parent, wxID_ANY);\\n\twxSizer* topSizer = newd wxBoxSizer(wxVERTICAL);\\n\\n\tattributesGrid = newd wxGrid(panel, ITEM_PROPERTIES_ADVANCED_TAB, wxDefaultPosition, wxSize(-1, 160));\\n\ttopSizer->Add(attributesGrid, wxSizerFlags(1).Expand());\\n\\n\twxFont time_font(*wxSWISS_FONT);\\n\tattributesGrid->SetDefaultCellFont(time_font);\\n\tattributesGrid->CreateGrid(0, 3);\\n\tattributesGrid->DisableDragRowSize();\\\
    n\tattributesGrid->DisableDragColSize();\\n\tattributesGrid->SetSelectionMode(wxGrid::wxGridSelectRows);\\n\tattributesGrid->SetRowLabelSize(0);\\n\t// log->SetColLabelSize(0);\\n\t// log->EnableGridLines(false);\\n\tattributesGrid->EnableEditing(true);\\n\\n\tattributesGrid->SetColLabelValue(0, \"Key\");\\n\tattributesGrid->SetColSize(0, 100);\\n\tattributesGrid->SetColLabelValue(1, \"Type\");\\n\tattributesGrid->SetColSize(1, 80);\\n\tattributesGrid->SetColLabelValue(2, \"Value\");\\n\tattributesGrid->SetColSize(2, 410);\\n\\n\t// contents\\n\tItemAttributeMap attrs = edit_item->getAttributes();\\n\tattributesGrid->AppendRows(attrs.size());\\n\tint i = 0;\\n\tfor (ItemAttributeMap::iterator aiter = attrs.begin(); aiter != attrs.end(); ++aiter, ++i) {\\n\t\tSetGridValue(attributesGrid, i, aiter->first, aiter->second);\\n\t}\\n\\n\twxSizer* optSizer = newd wxBoxSizer(wxHORIZONTAL);\\n\toptSizer->Add(newd wxButton(panel, ITEM_PROPERTIES_ADD_ATTRIBUTE, \"Add Attribute\"), wxSizerFlags(0).Center());\\\
    n\toptSizer->Add(newd wxButton(panel, ITEM_PROPERTIES_REMOVE_ATTRIBUTE, \"Remove Attribute\"), wxSizerFlags(0).Center());\\n\ttopSizer->Add(optSizer, wxSizerFlags(0).Center().DoubleBorder());\\n\\n\tpanel->SetSizer(topSizer);\\n\\n\treturn panel;\\n}\\n\\nvoid PropertiesWindow::SetGridValue(wxGrid* grid, int rowIndex, std::string label, const ItemAttribute& attr) {\\n\twxArrayString types;\\n\ttypes.Add(\"Number\");\\n\ttypes.Add(\"Float\");\\n\ttypes.Add(\"Boolean\");\\n\ttypes.Add(\"String\");\\n\\n\tgrid->SetCellValue(rowIndex, 0, label);\\n\tswitch (attr.type) {\\n\t\tcase ItemAttribute::STRING: {\\n\t\t\tgrid->SetCellValue(rowIndex, 1, \"String\");\\n\t\t\tgrid->SetCellValue(rowIndex, 2, wxstr(*attr.getString()));\\n\t\t\tbreak;\\n\t\t}\\n\t\tcase ItemAttribute::INTEGER: {\\n\t\t\tgrid->SetCellValue(rowIndex, 1, \"Number\");\\n\t\t\tgrid->SetCellValue(rowIndex, 2, i2ws(*attr.getInteger()));\\n\t\t\tgrid->SetCellEditor(rowIndex, 2, new wxGridCellNumberEditor);\\n\t\t\tbreak;\\n\t\
    \t}\\n\t\tcase ItemAttribute::DOUBLE:\\n\t\tcase ItemAttribute::FLOAT: {\\n\t\t\tgrid->SetCellValue(rowIndex, 1, \"Float\");\\n\t\t\twxString f;\\n\t\t\tf << *attr.getFloat();\\n\t\t\tgrid->SetCellValue(rowIndex, 2, f);\\n\t\t\tgrid->SetCellEditor(rowIndex, 2, new wxGridCellFloatEditor);\\n\t\t\tbreak;\\n\t\t}\\n\t\tcase ItemAttribute::BOOLEAN: {"
- file_path: wxwidgets/properties_window.h
  description: Header for PropertiesWindow.
  md5_hash: d6e49b4443e128d89ca022c470b0c876
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#ifndef RME_PROPERTIES_WINDOW_H_\\\
    n#define RME_PROPERTIES_WINDOW_H_\\n\\n#include \"main.h\"\\n\\n#include \"common_windows.h\"\\n\\nclass ContainerItemButton;\\nclass ContainerItemPopupMenu;\\nclass ItemAttribute;\\n\\nclass PropertiesWindow : public ObjectPropertiesWindowBase {\\npublic:\\n\tPropertiesWindow(wxWindow* parent, const Map* map, const Tile* tile, Item* item, wxPoint position = wxDefaultPosition);\\n\t~PropertiesWindow();\\n\\n\tvoid OnClickOK(wxCommandEvent&);\\n\tvoid OnClickCancel(wxCommandEvent&);\\n\tvoid OnClickAddAttribute(wxCommandEvent&);\\n\tvoid OnClickRemoveAttribute(wxCommandEvent&);\\n\\n\tvoid OnResize(wxSizeEvent&);\\n\tvoid OnNotebookPageChanged(wxNotebookEvent&);\\n\tvoid OnGridValueChanged(wxGridEvent&);\\n\\n\tvoid Update();\\n\\nprotected:\\n\t// Simple pane\\n\twxWindow* createGeneralPanel(wxWindow* parent);\\n\tvoid saveGeneralPanel();\\n\\n\t// Container pane\\n\tstd::vector<ContainerItemButton*> container_items;\\n\twxWindow* createContainerPanel(wxWindow* parent);\\n\tvoid saveContainerPanel();\\\
    n\\n\t// Advanced pane\\n\twxGrid* attributesGrid;\\n\twxWindow* createAttributesPanel(wxWindow* parent);\\n\tvoid saveAttributesPanel();\\n\tvoid SetGridValue(wxGrid* grid, int rowIndex, std::string name, const ItemAttribute& attr);\\n\\nprotected:\\n\twxNotebook* notebook;\\n\twxWindow* currentPanel;\\n\\n\tDECLARE_EVENT_TABLE()\\n};\\n\\n#endif"
- file_path: wxwidgets/old_properties_window.cpp
  description: Implements PropertiesWindow, a wxDialog with a wxNotebook for editing item properties (General, Contents for containers, Advanced custom attributes using wxGrid).
  md5_hash: 3e2f22edd5786afe2eacfc71472e5b63
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#include \"main.h\"\\n\\n#include <wx/grid.h>\\\
    n\\n#include \"tile.h\"\\n#include \"item.h\"\\n#include \"complexitem.h\"\\n#include \"town.h\"\\n#include \"house.h\"\\n#include \"map.h\"\\n#include \"editor.h\"\\n#include \"creature.h\"\\n\\n#include \"gui.h\"\\n#include \"application.h\"\\n#include \"old_properties_window.h\"\\n#include \"container_properties_window.h\"\\n\\n// ============================================================================\\n// Old Properties Window\\n\\n\\n/*\\nCurrent Task - Old Properties Window Improvements:\\n\\n1. Main Goal:\\n- Make the properties window non-blocking like replace_items_window.cpp\\n- Allow brush selection while properties window is open\\n- Fix crashes related to container and item handling (when we achieve it as a non main window)\\n\\n2. Issues Being Addressed:\\n- Access violation when checking canHoldText() on null items\\n- Container handling crashes\\n- Creature direction field not updating properly\\n- Modal dialog blocking brush selection\\n\\n3. Required Changes:\\\
    n- Add proper null checks for item/creature/spawn pointers\\n- Improve container handling safety\\n- Fix creature direction field updates\\n- Make window non-modal while maintaining functionality all the bugs above are when we try to implement a non modal window\\n- Ensure proper cleanup of resources\\n\\n4. Implementation Strategy:\\n- Add comprehensive null checks before accessing properties\\n- Improve error handling for container operations\\n- Fix creature direction field saving mechanism\\n- Modify window behavior to allow background interaction\\n- Maintain data integrity during property updates\\n\\n5. Note:\\nNEVER REMOVE ANY PREVIOUS FUNCTIONALITY UNLESS SPECIFICALLY REQUESTED!\\nKeep all existing features while adding improvements.\\n*/\\n\\nBEGIN_EVENT_TABLE(OldPropertiesWindow, wxDialog)\\nEVT_SET_FOCUS(OldPropertiesWindow::OnFocusChange)\\nEVT_BUTTON(wxID_OK, OldPropertiesWindow::OnClickOK)\\nEVT_BUTTON(wxID_CANCEL, OldPropertiesWindow::OnClickCancel)\\nEND_EVENT_TABLE()\\\
    n\\nstatic constexpr int OUTFIT_COLOR_MAX = 133;\\n\\nOldPropertiesWindow::OldPropertiesWindow(wxWindow* win_parent, const Map* map, const Tile* tile_parent, Item* item, wxPoint pos) :\\n\tObjectPropertiesWindowBase(win_parent, \"Item Properties\", map, tile_parent, item, pos),\\n\tcount_field(nullptr),\\n\tdirection_field(nullptr),\\n\taction_id_field(nullptr),\\n\tunique_id_field(nullptr),\\n\tdoor_id_field(nullptr),\\n\ttier_field(nullptr),\\n\tdepot_id_field(nullptr),\\n\tsplash_type_field(nullptr),\\n\ttext_field(nullptr),\\n\tdescription_field(nullptr) {\\n\tASSERT(edit_item);\\n\\n\twxSizer* topsizer = newd wxBoxSizer(wxVERTICAL);\\n\tif (Container* container = dynamic_cast<Container*>(edit_item)) {\\n\t\t// Container\\n\t\twxSizer* boxsizer = newd wxStaticBoxSizer(wxVERTICAL, this, \"Container Properties\");\\n\\n\t\twxFlexGridSizer* subsizer = newd wxFlexGridSizer(2, 10, 10);\\n\t\tsubsizer->AddGrowableCol(1);\\n\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"ID \"\
    \ + i2ws(item->getID())));\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"\"\" + wxstr(item->getName()) + \"\"\"));\\n\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"Action ID\"));\\n\t\taction_id_field = newd wxSpinCtrl(this, wxID_ANY, i2ws(edit_item->getActionID()), wxDefaultPosition, wxDefaultSize, wxSP_ARROW_KEYS, 0, 0xFFFF, edit_item->getActionID());\\n\t\tsubsizer->Add(action_id_field, wxSizerFlags(1).Expand());\\n\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"Unique ID\"));\\n\t\tunique_id_field = newd wxSpinCtrl(this, wxID_ANY, i2ws(edit_item->getUniqueID()), wxDefaultPosition, wxSize(-1, 20), wxSP_ARROW_KEYS, 0, 0xFFFF, edit_item->getUniqueID());\\n\t\tsubsizer->Add(unique_id_field, wxSizerFlags(1).Expand());\\n\\n\t\tboxsizer->Add(subsizer, wxSizerFlags(0).Expand());\\n\\n\t\t// Now we add the subitems!\\n\t\twxSizer* contents_sizer = newd wxStaticBoxSizer(wxVERTICAL, this, \"Contents\");\\n\\n\t\tbool use_large_sprites = g_settings.getBoolean(Config::USE_LARGE_CONTAINER_ICONS);\\\
    n\t\twxSizer* horizontal_sizer = nullptr;\\n\t\tconst int additional_height_increment = (use_large_sprites ? 40 : 24);\\n\t\tint additional_height = 0;\\n\\n\t\tint32_t maxColumns;\\n\t\tif (use_large_sprites) {\\n\t\t\tmaxColumns = 6;\\n\t\t} else {\\n\t\t\tmaxColumns = 12;\\n\t\t}\\n\\n\t\tfor (uint32_t index = 0; index < container->getVolume(); ++index) {\\n\t\t\tif (!horizontal_sizer) {\\n\t\t\t\thorizontal_sizer = newd wxBoxSizer(wxHORIZONTAL);\\n\t\t\t}\\n\\n\t\t\tItem* item = container->getItem(index);\\n\t\t\tContainerItemButton* containerItemButton = newd ContainerItemButton(this, use_large_sprites, index, map, item);\\n\\n\t\t\tcontainer_items.push_back(containerItemButton);\\n\t\t\thorizontal_sizer->Add(containerItemButton);\\n\\n\t\t\tif (((index + 1) % maxColumns) == 0) {\\n\t\t\t\tcontents_sizer->Add(horizontal_sizer);\\n\t\t\t\thorizontal_sizer = nullptr;\\n\t\t\t\tadditional_height += additional_height_increment;\\n\t\t\t}\\n\t\t}\\n\\n\t\tif (horizontal_sizer != nullptr)\
    \ {\\n\t\t\tcontents_sizer->Add(horizontal_sizer);\\n\t\t\tadditional_height += additional_height_increment;\\n\t\t}\\n\\n\t\tboxsizer->Add(contents_sizer, wxSizerFlags(2).Expand());\\n\\n\t\ttopsizer->Add(boxsizer, wxSizerFlags(0).Expand().Border(wxALL, 20));\\n\\n\t\t// SetSize(260, 150 + additional_height);\\n\t} else if (edit_item->canHoldText() || edit_item->canHoldDescription()) {\\n\t\t// Book\\n\t\twxSizer* boxsizer = newd wxStaticBoxSizer(wxVERTICAL, this, \"Writeable Properties\");\\n\\n\t\twxFlexGridSizer* subsizer = newd wxFlexGridSizer(2, 10, 10);\\n\t\tsubsizer->AddGrowableCol(1);\\n\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"ID \" + i2ws(item->getID())));\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"\"\" + wxstr(item->getName()) + \"\"\"));\\n\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"Action ID\"));\\n\t\taction_id_field = newd wxSpinCtrl(this, wxID_ANY, i2ws(edit_item->getActionID()), wxDefaultPosition, wxDefaultSize, wxSP_ARROW_KEYS,\
    \ 0, 0xFFFF, edit_item->getActionID());\\n\t\taction_id_field->SetSelection(-1, -1);\\n\t\tsubsizer->Add(action_id_field, wxSizerFlags(1).Expand());\\n\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"Unique ID\"));\\n\t\tunique_id_field = newd wxSpinCtrl(this, wxID_ANY, i2ws(edit_item->getUniqueID()), wxDefaultPosition, wxSize(-1, 20), wxSP_ARROW_KEYS, 0, 0xFFFF, edit_item->getUniqueID());\\n\t\tsubsizer->Add(unique_id_field, wxSizerFlags(1).Expand());\\n\\n\t\tboxsizer->Add(subsizer, wxSizerFlags(1).Expand());\\n\\n\t\twxSizer* textsizer = newd wxBoxSizer(wxVERTICAL);\\n\t\ttextsizer->Add(newd wxStaticText(this, wxID_ANY, \"Text\"), wxSizerFlags(1).Center());\\n\t\ttext_field = newd wxTextCtrl(this, wxID_ANY, wxstr(item->getText()), wxDefaultPosition, wxDefaultSize, wxTE_MULTILINE);\\n\t\ttextsizer->Add(text_field, wxSizerFlags(7).Expand());\\n\\n\t\tboxsizer->Add(textsizer, wxSizerFlags(2).Expand());\\n\\n\t\ttopsizer->Add(boxsizer, wxSizerFlags(0).Expand().Border(wxALL, 20));\\\
    n\\n\t\t// SetSize(220, 310);\\n\t} else if (edit_item->isSplash() || edit_item->isFluidContainer()) {\\n\t\t// Splash\\n\t\twxSizer* boxsizer = newd wxStaticBoxSizer(wxVERTICAL, this, \"Splash Properties\");\\n\\n\t\twxFlexGridSizer* subsizer = newd wxFlexGridSizer(2, 10, 10);\\n\t\tsubsizer->AddGrowableCol(1);\\n\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"ID \" + i2ws(item->getID())));\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"\"\" + wxstr(item->getName()) + \"\"\"));\\n\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"Type\"));"
- file_path: wxwidgets/old_properties_window.h
  description: Header for PropertiesWindow.
  md5_hash: 17d7f50be73b0facdc2faddc051ae845
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#ifndef RME_OLD_PROPERTIES_WINDOW_H_\\\
    n#define RME_OLD_PROPERTIES_WINDOW_H_\\n\\n#include \"main.h\"\\n\\n#include \"common_windows.h\"\\n\\nclass ContainerItemButton;\\nclass ContainerItemPopupMenu;\\nclass MapWindow;\\n\\nclass OldPropertiesWindow : public ObjectPropertiesWindowBase {\\npublic:\\n\tOldPropertiesWindow(wxWindow* parent, const Map* map, const Tile* tile, Item* item, wxPoint = wxDefaultPosition);\\n\tOldPropertiesWindow(wxWindow* parent, const Map* map, const Tile* tile, Creature* creature, wxPoint = wxDefaultPosition);\\n\tOldPropertiesWindow(wxWindow* parent, const Map* map, const Tile* tile, Spawn* spawn, wxPoint = wxDefaultPosition);\\n\tvirtual ~OldPropertiesWindow();\\n\\n\tvoid OnFocusChange(wxFocusEvent&);\\n\tvoid OnChar(wxKeyEvent& evt);\\n\tvoid OnKeyDown(wxKeyEvent& evt);\\n\tvoid OnTextEnter(wxCommandEvent& evt);\\n\\n\tvoid OnClickOK(wxCommandEvent&);\\n\tvoid OnClickCancel(wxCommandEvent&);\\n\tvoid OnClose(wxCloseEvent& evt);\\n\\n\tvoid Update();\\n\t\\n\t// Non-modal methods\\n\tstatic OldPropertiesWindow*\
    \ getInstance() { return instance; }\\n\tstatic void destroyInstance() { \\n\t\tif (instance) {\\n\t\t\tinstance->Destroy();\\n\t\t\tinstance = nullptr;\\n\t\t}\\n\t}\\n\tstatic bool isActive() { return instance != nullptr; }\\n\t\\n\tvoid CommitChanges();\\n\\nprotected:\\n\t// Singleton instance for non-modal use\\n\tstatic OldPropertiesWindow* instance;\\n\\n\t// item\\n\twxSpinCtrl* count_field;\\n\twxSpinCtrl* action_id_field;\\n\twxSpinCtrl* unique_id_field;\\n\twxSpinCtrl* door_id_field;\\n\twxSpinCtrl* tier_field;\\n\twxChoice* depot_id_field;\\n\twxChoice* splash_type_field;\\n\twxTextCtrl* text_field;\\n\twxTextCtrl* description_field;\\n\\n\t// teleport\\n\twxSpinCtrl* x_field;\\n\twxSpinCtrl* y_field;\\n\twxSpinCtrl* z_field;\\n\\n\t// podium\\n\twxCheckBox* show_outfit;\\n\twxCheckBox* show_mount;\\n\twxCheckBox* show_platform;\\n\twxSpinCtrl* look_type;\\n\twxSpinCtrl* look_head;\\n\twxSpinCtrl* look_body;\\n\twxSpinCtrl* look_legs;\\n\twxSpinCtrl* look_feet;\\n\twxSpinCtrl*\
    \ look_addon;\\n\twxSpinCtrl* look_mount;\\n\twxSpinCtrl* look_mounthead;\\n\twxSpinCtrl* look_mountbody;\\n\twxSpinCtrl* look_mountlegs;\\n\twxSpinCtrl* look_mountfeet;\\n\\n\t// podium and creature\\n\twxChoice* direction_field;\\n\\n\t// container\\n\tstd::vector<ContainerItemButton*> container_items;\\n\\n\tfriend class ContainerItemButton;\\n\tfriend class ContainerItemPopupMenu;\\n\\n\tDECLARE_EVENT_TABLE();\\n};\\n\\n#endif"
- file_path: wxwidgets/container_properties_window.cpp
  description: Implements PropertiesWindow, a wxDialog with a wxNotebook for editing item properties (General, Contents for containers, Advanced custom attributes using wxGrid).
  md5_hash: 7a82e9f15468746c7d631733679976de
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#include \"main.h\"\\n\\n#include \"\
    container_properties_window.h\"\\n\\n#include \"old_properties_window.h\"\\n#include \"properties_window.h\"\\n#include \"find_item_window.h\"\\n#include \"gui.h\"\\n#include \"complexitem.h\"\\n#include \"map.h\"\\n\\n// ============================================================================\\n// Container Item Button\\n// Displayed in the container object properties menu, needs some\\n// custom event handling for the right-click menu etcetera so we\\n// need to define a custom class for it.\\n\\nstd::unique_ptr<ContainerItemPopupMenu> ContainerItemButton::popup_menu;\\n\\nBEGIN_EVENT_TABLE(ContainerItemButton, ItemButton)\\nEVT_LEFT_DOWN(ContainerItemButton::OnMouseDoubleLeftClick)\\nEVT_RIGHT_UP(ContainerItemButton::OnMouseRightRelease)\\n\\nEVT_MENU(CONTAINER_POPUP_MENU_ADD, ContainerItemButton::OnAddItem)\\nEVT_MENU(CONTAINER_POPUP_MENU_EDIT, ContainerItemButton::OnEditItem)\\nEVT_MENU(CONTAINER_POPUP_MENU_REMOVE, ContainerItemButton::OnRemoveItem)\\nEND_EVENT_TABLE()\\n\\\
    nContainerItemButton::ContainerItemButton(wxWindow* parent, bool large, int _index, const Map* map, Item* item) :\\n\tItemButton(parent, (large ? RENDER_SIZE_32x32 : RENDER_SIZE_16x16), (item ? item->getClientID() : 0)),\\n\tedit_map(map),\\n\tedit_item(item),\\n\tindex(_index) {\\n\t////\\n}\\n\\nContainerItemButton::~ContainerItemButton() {\\n\t////\\n}\\n\\nvoid ContainerItemButton::OnMouseDoubleLeftClick(wxMouseEvent& WXUNUSED(event)) {\\n\twxCommandEvent dummy;\\n\\n\tif (edit_item) {\\n\t\tOnEditItem(dummy);\\n\t\treturn;\\n\t}\\n\\n\tContainer* container = getParentContainer();\\n\tif (container->getVolume() > container->getItemCount()) {\\n\t\tOnAddItem(dummy);\\n\t}\\n}\\n\\nvoid ContainerItemButton::OnMouseRightRelease(wxMouseEvent& WXUNUSED(event)) {\\n\tif (!popup_menu) {\\n\t\tpopup_menu.reset(newd ContainerItemPopupMenu);\\n\t}\\n\\n\tpopup_menu->Update(this);\\n\tPopupMenu(popup_menu.get());\\n}\\n\\nvoid ContainerItemButton::OnAddItem(wxCommandEvent& WXUNUSED(event))\
    \ {\\n\tFindItemDialog dialog(GetParent(), \"Choose Item to add\", true);\\n\\n\tif (dialog.ShowModal() == wxID_OK) {\\n\t\tContainer* container = getParentContainer();\\n\t\tItemVector& itemVector = container->getVector();\\n\\n\t\tItem* item = Item::Create(dialog.getResultID());\\n\t\tif (index < itemVector.size()) {\\n\t\t\titemVector.insert(itemVector.begin() + index, item);\\n\t\t} else {\\n\t\t\titemVector.push_back(item);\\n\t\t}\\n\\n\t\tObjectPropertiesWindowBase* propertyWindow = getParentContainerWindow();\\n\t\tif (propertyWindow) {\\n\t\t\tpropertyWindow->Update();\\n\t\t}\\n\t}\\n\tdialog.Destroy();\\n}\\n\\nvoid ContainerItemButton::OnEditItem(wxCommandEvent& WXUNUSED(event)) {\\n\tASSERT(edit_item);\\n\\n\twxPoint newDialogAt;\\n\twxWindow* w = this;\\n\twhile ((w = w->GetParent())) {\\n\t\tif (ObjectPropertiesWindowBase* o = dynamic_cast<ObjectPropertiesWindowBase*>(w)) {\\n\t\t\tnewDialogAt = o->GetPosition();\\n\t\t\tbreak;\\n\t\t}\\n\t}\\n\\n\tnewDialogAt += wxPoint(20,\
    \ 20);\\n\\n\twxDialog* d;\\n\\n\tif (edit_map->getVersion().otbm >= MAP_OTBM_4) {\\n\t\td = newd PropertiesWindow(this, edit_map, nullptr, edit_item, newDialogAt);\\n\t} else {\\n\t\td = newd OldPropertiesWindow(this, edit_map, nullptr, edit_item, newDialogAt);\\n\t}\\n\\n\td->ShowModal();\\n\td->Destroy();\\n}\\n\\nvoid ContainerItemButton::OnRemoveItem(wxCommandEvent& WXUNUSED(event)) {\\n\tASSERT(edit_item);\\n\tint32_t ret = g_gui.PopupDialog(GetParent(), \"Remove Item\", \"Are you sure you want to remove this item from the container?\", wxYES | wxNO);\\n\\n\tif (ret != wxID_YES) {\\n\t\treturn;\\n\t}\\n\\n\tContainer* container = getParentContainer();\\n\tItemVector& itemVector = container->getVector();\\n\\n\tauto it = itemVector.begin();\\n\tfor (; it != itemVector.end(); ++it) {\\n\t\tif (*it == edit_item) {\\n\t\t\tbreak;\\n\t\t}\\n\t}\\n\\n\tASSERT(it != itemVector.end());\\n\\n\titemVector.erase(it);\\n\tdelete edit_item;\\n\\n\tObjectPropertiesWindowBase* propertyWindow\
    \ = getParentContainerWindow();\\n\tif (propertyWindow) {\\n\t\tpropertyWindow->Update();\\n\t}\\n}\\n\\nvoid ContainerItemButton::setItem(Item* item) {\\n\tedit_item = item;\\n\tif (edit_item) {\\n\t\tSetSprite(edit_item->getClientID());\\n\t} else {\\n\t\tSetSprite(0);\\n\t}\\n}\\n\\nObjectPropertiesWindowBase* ContainerItemButton::getParentContainerWindow() {\\n\tfor (wxWindow* window = GetParent(); window != nullptr; window = window->GetParent()) {\\n\t\tObjectPropertiesWindowBase* propertyWindow = dynamic_cast<ObjectPropertiesWindowBase*>(window);\\n\t\tif (propertyWindow) {\\n\t\t\treturn propertyWindow;\\n\t\t}\\n\t}\\n\treturn nullptr;\\n}\\n\\nContainer* ContainerItemButton::getParentContainer() {\\n\tObjectPropertiesWindowBase* propertyWindow = getParentContainerWindow();\\n\tif (propertyWindow) {\\n\t\treturn dynamic_cast<Container*>(propertyWindow->getItemBeingEdited());\\n\t}\\n\treturn nullptr;\\n}\\n\\n// ContainerItemPopupMenu\\nContainerItemPopupMenu::ContainerItemPopupMenu()\
    \ :\\n\twxMenu(\"\") {\\n\t////\\n}\\n\\nContainerItemPopupMenu::~ContainerItemPopupMenu() {\\n\t////\\n}\\n\\nvoid ContainerItemPopupMenu::Update(ContainerItemButton* btn) {\\n\t// Clear the menu of all items\\n\twhile (GetMenuItemCount() != 0) {\\n\t\twxMenuItem* m_item = FindItemByPosition(0);\\n\t\t// If you add a submenu, this won't delete it.\\n\t\tDelete(m_item);"
- file_path: wxwidgets/container_properties_window.h
  description: Header for PropertiesWindow.
  md5_hash: 119dfa9ff3ff13e535a3d90c4b3f7eef
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#ifndef _RME_CONTAINER_PROPS_H_\\n#define\
    \ _RME_CONTAINER_PROPS_H_\\n\\n#include \"common_windows.h\"\\n\\nclass Container;\\nclass ContainerItemButton;\\n\\n// Right-click popup menu\\nclass ContainerItemPopupMenu : public wxMenu {\\npublic:\\n\tContainerItemPopupMenu();\\n\tvirtual ~ContainerItemPopupMenu();\\n\\n\tvoid Update(ContainerItemButton* what);\\n};\\n\\n// Container Item Button\\nclass ContainerItemButton : public ItemButton {\\n\tDECLARE_EVENT_TABLE()\\npublic:\\n\tContainerItemButton(wxWindow* parent, bool large, int index, const Map* map, Item* item);\\n\t~ContainerItemButton();\\n\\n\tvoid OnMouseDoubleLeftClick(wxMouseEvent& event);\\n\tvoid OnMouseRightRelease(wxMouseEvent& event);\\n\\n\tvoid OnAddItem(wxCommandEvent& event);\\n\tvoid OnEditItem(wxCommandEvent& event);\\n\tvoid OnRemoveItem(wxCommandEvent& event);\\n\\n\tObjectPropertiesWindowBase* getParentContainerWindow();\\n\tContainer* getParentContainer();\\n\\n\tvoid setItem(Item* item);\\n\\nprivate:\\n\tstatic std::unique_ptr<ContainerItemPopupMenu>\
    \ popup_menu;\\n\\n\tconst Map* edit_map;\\n\tItem* edit_item;\\n\\n\tsize_t index;\\n\\n\tfriend class ContainerItemPopupMenu;\\n};\\n\\n#endif"
documentation_references:
- 'QDialog: https://doc.qt.io/qt-6/qdialog.html'
- 'QTabWidget: https://doc.qt.io/qt-6/qtabwidget.html'
- QSpinBox, QLineEdit, QTextEdit, QComboBox, QCheckBox for input fields.
- 'QTableWidget (for custom attributes): https://doc.qt.io/qt-6/qtablewidget.html'
- 'QStyledItemDelegate (for custom editors in QTableWidget/QTreeView): https://doc.qt.io/qt-6/qstyleditemdelegate.html'
- 'QListView with IconMode: https://doc.qt.io/qt-6/qlistview.html#viewMode-prop'
current_functionality_summary: |-
  The wxWidgets version provides two main item properties dialogs:
  1.  `PropertiesWindow` (newer): Uses a notebook with tabs for "Simple" (ID, Name, ActionID, UniqueID), "Contents" (for containers, displays items in a grid of `ContainerItemButton`s with context menus), and "Advanced" (a `wxGrid` for arbitrary key-type-value attributes).
  2.  `OldPropertiesWindow`: A more direct dialog that customizes its layout based on the item type (generic, container, writeable, splash, depot, door, teleport, podium) or if editing a Creature or Spawn. It uses various `wxSpinCtrl`, `wxTextCtrl`, and `wxChoice` controls.
  Both dialogs allow modification of common attributes like ActionID and UniqueID, and specialized attributes based on type. Container editing involves adding, removing, or editing items within the container.
definition_of_done:
- A Qt6 `ItemPropertiesDialog` (subclass of `QDialog`) is implemented, using a `QTabWidget` for 'General', 'Contents', and 'Advanced Attributes' sections.
- '**General Tab:**'
- '  - Displays read-only Item ID and Name.'
- '  - Provides `QSpinBox` controls for Action ID and Unique ID.'
- '  - Dynamically displays and allows editing of type-specific attributes based on the item being edited (e.g., count/subtype for stackables/fluids, text for writeables, destination for teleports, depot ID for depots, door ID, podium outfit details) using appropriate Qt widgets (`QSpinBox`, `QLineEdit`, `QTextEdit`, `QComboBox`, `QCheckBox`).'
- '**Contents Tab (for Container Items):**'
- '  - This tab is only visible if the edited item is a container.'
- '  - Displays contained items in a grid view (e.g., `QListView` in `IconMode` or a custom grid of `QPushButton`-like widgets displaying item sprites).'
- '  - A context menu on container slots/items allows ''Add Item'' (opens item finder from UI-06), ''Edit Item Properties'' (opens a new `ItemPropertiesDialog`), and ''Remove Item''.'
- '**Advanced Attributes Tab:**'
- '  - A `QTableWidget` (or `QTreeView` with a model) allows viewing, adding, removing, and editing custom key-value attributes.'
- '  - The ''Key'' is a string. The ''Type'' is selectable from a `QComboBox` (String, Integer, Float, Boolean). The ''Value'' cell uses an appropriate editor based on the selected type.'
- 'Separate, simpler `QDialog` subclasses are created for:'
- '  - `CreaturePropertiesDialog`: Edits spawn interval (`QSpinBox`) and direction (`QComboBox`).'
- '  - `SpawnPropertiesDialog`: Edits spawn radius (`QSpinBox`).'
- All dialogs correctly load properties from the passed object (Item, Creature, Spawn) on showing and apply validated changes back to a *copy* of the object when 'OK' is clicked. The calling code handles the actual map modification and undo action.
- Input validation is performed for relevant fields (e.g., numeric ranges, string lengths).
boilerplate_coder_ai_prompt: |-
  Your task is to port the item, creature, and spawn properties editing dialogs from wxWidgets to Qt6. The main item properties dialog will be tabbed for general properties, container contents, and custom key-value attributes.

  **Reference Files:** `wxwidgets/properties_window.*`, `wxwidgets/old_properties_window.*`, `wxwidgets/container_properties_window.*`.

  **1. `ItemPropertiesDialog` (Main Dialog, inherits `QDialog`):**
     - Use a `QTabWidget` for the main sections.

     **a. 'General' Tab:**
        - `QLabel` for Item ID (read-only).
        - `QLabel` for Item Name (read-only).
        - `QSpinBox` for Action ID (range 0-65535).
        - `QSpinBox` for Unique ID (range 0-65535, typically 1000-65535 if not 0).
        - **Dynamic Section (based on ItemType):**
            - If stackable/charged: `QSpinBox` for Count/Charges. Max value depends on item type.
            - If writeable: `QTextEdit` for Text.
            - If splash/fluid: `QComboBox` for Liquid Type (populate with known types).
            - If depot: `QComboBox` for Depot Town ID (populate with towns from map).
            - If door: `QSpinBox` for Door ID (relevant if on a house tile).
            - If teleport: `QSpinBox`es for Dest X, Y, Z.
            - If podium: `QComboBox` for Direction; `QCheckBox`es for Show Outfit, Mount, Platform; `QSpinBox`es for LookType, Head, Body, Legs, Feet, Addons, LookMount, and mount colors.
            - If tiered item (version >= 12.81): `QSpinBox` for Tier (0-255).

     **b. 'Contents' Tab (Visible only for Containers):**
        - Use a `QListView` in `QListView::IconMode` with a custom model, or a `QGridLayout` of custom `ItemButtonWidget` (subclass `QPushButton` or `QToolButton`) to display items in the container. Each button shows item sprite. Store the slot index.
        - Implement `customContextMenuRequested` on the view/buttons to show a `QMenu` with "Add Item...", "Edit Item...", "Remove Item".
        - "Add Item...": Opens an item finder dialog (from `UI-06`). Places selected item in an empty slot or appends.
        - "Edit Item...": Opens a new `ItemPropertiesDialog` for the item in that slot.
        - "Remove Item": Clears the item from that slot.

     **c. 'Advanced Attributes' Tab:**
        - Use `QTableWidget` with columns: "Key" (QString), "Type" (QComboBox: String, Integer, Float, Boolean), "Value".
        - Buttons: "Add Attribute", "Remove Selected Attribute".
        - When "Type" `QComboBox` changes, set an appropriate editor for the "Value" cell (e.g., `QLineEdit` for String, `QSpinBox` for Integer, `QDoubleSpinBox` for Float, `QCheckBox` for Boolean). Use `QTableWidget::setCellWidget` or a `QStyledItemDelegate`.

     **Dialog Logic:**
        - Constructor takes `(QWidget* parent, const Map* map, const Tile* tile, Item* itemToEditCopy)`.
        - Populate fields from `itemToEditCopy` when shown.
        - On "OK" click: Validate inputs. Update `itemToEditCopy` with new values. `accept()` the dialog. The caller is responsible for creating an undo action with this modified copy.

  **2. `CreaturePropertiesDialog` (inherits `QDialog`):**
     - `QLabel` for Creature Name (read-only).
     - `QSpinBox` for Spawn Interval (seconds, e.g., 10-3600).
     - `QComboBox` for Direction (North, East, South, West, etc.).
     - Populate from `Creature*` copy, save back to copy on OK.

  **3. `SpawnPropertiesDialog` (inherits `QDialog`):**
     - `QSpinBox` for Spawn Radius (e.g., 1-15).
     - Populate from `Spawn*` (or `SpawnProperties*`) copy, save back to copy on OK.
