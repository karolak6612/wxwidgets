wbs_item_id: UI-07
name: Port House & Waypoint Tools
description: Recreate UI components for managing houses (palette, editor dialog) and waypoints (palette).
dependencies:
- 'UI-02   # House and Waypoint palettes are tabs in the main palette system.'
- 'CORE-03 # For map saving/loading which includes house and waypoint data.'
- 'LOGIC-04 # For Waypoint and WaypointManager data structures.'
- 'LOGIC-05 # For House and Town data structures and management.'
input_files:
- wxwidgets/palette_house.cpp
- wxwidgets/palette_house.h
- wxwidgets/palette_waypoints.cpp
- wxwidgets/palette_waypoints.h
analyzed_input_files:
- file_path: wxwidgets/palette_house.cpp
  description: Implements `HousePalettePanel` using wxChoice for towns, SortableListBox for houses, buttons for Add/Edit/Remove, and toggles for House/Exit brushes. Defines `EditHouseDialog` for house properties.
  md5_hash: 83c0a96cee859acbc8c1f9e43973a459
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#include \"main.h\"\\n\\n#include \"\
    palette_house.h\"\\n\\n#include \"settings.h\"\\n\\n#include \"brush.h\"\\n#include \"editor.h\"\\n#include \"map.h\"\\n\\n#include \"application.h\"\\n#include \"map_display.h\"\\n\\n#include \"house_brush.h\"\\n#include \"house_exit_brush.h\"\\n#include \"spawn_brush.h\"\\n\\n// ============================================================================\\n// House palette\\n\\nBEGIN_EVENT_TABLE(HousePalettePanel, PalettePanel)\\nEVT_TIMER(PALETTE_LAYOUT_FIX_TIMER, HousePalettePanel::OnLayoutFixTimer)\\n\\nEVT_CHOICE(PALETTE_HOUSE_TOWN_CHOICE, HousePalettePanel::OnTownChange)\\n\\nEVT_LISTBOX(PALETTE_HOUSE_LISTBOX, HousePalettePanel::OnListBoxChange)\\nEVT_LISTBOX_DCLICK(PALETTE_HOUSE_LISTBOX, HousePalettePanel::OnListBoxDoubleClick)\\nEVT_CONTEXT_MENU(HousePalettePanel::OnListBoxContextMenu)\\n\\nEVT_BUTTON(PALETTE_HOUSE_ADD_HOUSE, HousePalettePanel::OnClickAddHouse)\\nEVT_BUTTON(PALETTE_HOUSE_EDIT_HOUSE, HousePalettePanel::OnClickEditHouse)\\nEVT_BUTTON(PALETTE_HOUSE_REMOVE_HOUSE,\
    \ HousePalettePanel::OnClickRemoveHouse)\\n\\nEVT_TOGGLEBUTTON(PALETTE_HOUSE_BRUSH_BUTTON, HousePalettePanel::OnClickHouseBrushButton)\\nEVT_TOGGLEBUTTON(PALETTE_HOUSE_SELECT_EXIT_BUTTON, HousePalettePanel::OnClickSelectExitButton)\\n\\nEVT_MENU(PALETTE_HOUSE_CONTEXT_MOVE_TO_TOWN, HousePalettePanel::OnMoveHouseToTown)\\nEND_EVENT_TABLE()\\n\\nHousePalettePanel::HousePalettePanel(wxWindow* parent, wxWindowID id) :\\n\tPalettePanel(parent, id),\\n\tmap(nullptr),\\n\tdo_resize_on_display(true),\\n\tfix_size_timer(this, PALETTE_LAYOUT_FIX_TIMER) {\\n\twxSizer* topsizer = newd wxBoxSizer(wxVERTICAL);\\n\twxSizer* tmpsizer;\\n\\n\twxSizer* sidesizer = newd wxStaticBoxSizer(wxVERTICAL, this, \"Houses\");\\n\ttown_choice = newd wxChoice(this, PALETTE_HOUSE_TOWN_CHOICE, wxDefaultPosition, wxDefaultSize, (int)0, (const wxString*)nullptr);\\n\tsidesizer->Add(town_choice, 0, wxEXPAND);\\n\\n\thouse_list = newd SortableListBox(this, PALETTE_HOUSE_LISTBOX, wxDefaultPosition, wxDefaultSize, 0, nullptr,\
    \ wxLB_EXTENDED);\\n#ifdef __APPLE__\\n\t// Used for detecting a deselect\\n\thouse_list->Bind(wxEVT_LEFT_UP, &HousePalettePanel::OnListBoxClick, this);\\n#endif\\n\t// Bind context menu event to the list box\\n\thouse_list->Bind(wxEVT_CONTEXT_MENU, &HousePalettePanel::OnListBoxContextMenu, this);\\n\tsidesizer->Add(house_list, 1, wxEXPAND);\\n\\n\ttmpsizer = newd wxBoxSizer(wxHORIZONTAL);\\n\twxSizerFlags sizerFlags(1);\\n\ttmpsizer->Add(add_house_button = newd wxButton(this, PALETTE_HOUSE_ADD_HOUSE, \"Add\", wxDefaultPosition, wxSize(50, -1)), sizerFlags);\\n\ttmpsizer->Add(edit_house_button = newd wxButton(this, PALETTE_HOUSE_EDIT_HOUSE, \"Edit\", wxDefaultPosition, wxSize(50, -1)), sizerFlags);\\n\ttmpsizer->Add(remove_house_button = newd wxButton(this, PALETTE_HOUSE_REMOVE_HOUSE, \"Remove\", wxDefaultPosition, wxSize(70, -1)), sizerFlags);\\n\tsidesizer->Add(tmpsizer, wxSizerFlags(0).Right());\\n\\n\ttopsizer->Add(sidesizer, 1, wxEXPAND);\\n\\n\t// Temple position\\n\tsidesizer\
    \ = newd wxStaticBoxSizer(newd wxStaticBox(this, wxID_ANY, \"Brushes\", wxDefaultPosition, wxSize(150, 200)), wxVERTICAL);\\n\\n\t// sidesizer->Add(180, 1, wxEXPAND);\\n\\n\ttmpsizer = newd wxBoxSizer(wxHORIZONTAL);\\n\thouse_brush_button = newd wxToggleButton(this, PALETTE_HOUSE_BRUSH_BUTTON, \"House tiles\");\\n\ttmpsizer->Add(house_brush_button);\\n\tsidesizer->Add(tmpsizer, wxSizerFlags(1).Center());\\n\\n\ttmpsizer = newd wxBoxSizer(wxHORIZONTAL);\\n\tselect_position_button = newd wxToggleButton(this, PALETTE_HOUSE_SELECT_EXIT_BUTTON, \"Select Exit\");\\n\ttmpsizer->Add(select_position_button);\\n\tsidesizer->Add(tmpsizer, wxSizerFlags(1).Center());\\n\\n\ttopsizer->Add(sidesizer, 0, wxEXPAND);\\n\\n\tSetSizerAndFit(topsizer);\\n\\n\t// Create context menu\\n\tcontext_menu = newd wxMenu();\\n\tcontext_menu->Append(PALETTE_HOUSE_CONTEXT_MOVE_TO_TOWN, \"Move to Town...\");\\n}\\n\\nHousePalettePanel::~HousePalettePanel() {\\n\t////\\n}\\n\\nvoid HousePalettePanel::SetMap(Map* m) {\\\
    n\tg_gui.house_brush->setHouse(nullptr);\\n\tmap = m;\\n\tOnUpdate();\\n}\\n\\nvoid HousePalettePanel::OnSwitchIn() {\\n\tPalettePanel::OnSwitchIn();\\n\t// Extremely ugly hack to fix layout issue\\n\tif (do_resize_on_display) {\\n\t\tfix_size_timer.Start(100, true);\\n\t\tdo_resize_on_display = false;\\n\t}\\n}\\n\\nvoid HousePalettePanel::OnLayoutFixTimer(wxTimerEvent& WXUNUSED(event)) {\\n\twxWindow* w = this;\\n\twhile ((w = w->GetParent()) && dynamic_cast<PaletteWindow*>(w) == nullptr)\\n\t\t;\\n\\n\tif (w) {\\n\t\tw->SetSize(w->GetSize().GetWidth(), w->GetSize().GetHeight() + 1);\\n\t\tw->SetSize(w->GetSize().GetWidth(), w->GetSize().GetHeight() - 1);\\n\t}\\n}\\n\\nvoid HousePalettePanel::SelectFirstBrush() {\\n\tSelectHouseBrush();\\n}\\n\\nBrush* HousePalettePanel::GetSelectedBrush() const {\\n\tif (select_position_button->GetValue()) {\\n\t\tHouse* house = GetCurrentlySelectedHouse();\\n\t\tif (house) {\\n\t\t\tg_gui.house_exit_brush->setHouse(house);\\n\t\t}\\n\t\treturn (g_gui.house_exit_brush->getHouseID()\
    \ != 0 ? g_gui.house_exit_brush : nullptr);\\n\t} else if (house_brush_button->GetValue()) {\\n\t\tg_gui.house_brush->setHouse(GetCurrentlySelectedHouse());\\n\t\treturn (g_gui.house_brush->getHouseID() != 0 ? g_gui.house_brush : nullptr);\\n\t}\\n\treturn nullptr;\\n}\\n\\nbool HousePalettePanel::SelectBrush(const Brush* whatbrush) {\\n\tif (!whatbrush) {\\n\t\treturn false;\\n\t}\\n\\n\tif (whatbrush->isHouse() && map) {\\n\t\tconst HouseBrush* house_brush = static_cast<const HouseBrush*>(whatbrush);\\n\t\tfor (HouseMap::iterator house_iter = map->houses.begin(); house_iter != map->houses.end(); ++house_iter) {\\n\t\t\tif (house_iter->second->getID() == house_brush->getHouseID()) {\\n\t\t\t\tfor (uint32_t i = 0; i < town_choice->GetCount(); ++i) {\\n\t\t\t\t\tTown* town = reinterpret_cast<Town*>(town_choice->GetClientData(i));\\n\t\t\t\t\t// If it's \"No Town\" (nullptr) select it, or if it has the same town ID as the house\\n\t\t\t\t\tif (town == nullptr || town->getID() == house_iter->second->townid)\
    \ {\\n\t\t\t\t\t\tSelectTown(i);\\n\t\t\t\t\t\tfor (uint32_t j = 0; j < house_list->GetCount(); ++j) {\\n\t\t\t\t\t\t\tif (house_iter->second->getID() == reinterpret_cast<House*>(house_list->GetClientData(j))->getID()) {\\n\t\t\t\t\t\t\t\tSelectHouse(j);\\n\t\t\t\t\t\t\t\treturn true;\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t}\\n\t\t\t\t\t\treturn true;\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t} else if (whatbrush->isSpawn()) {\\n\t\tSelectExitBrush();\\n\t}\\n\treturn false;\\n}\\n\\nint HousePalettePanel::GetSelectedBrushSize() const {\\n\treturn 0;\\n}\\n\\nPaletteType HousePalettePanel::GetType() const {\\n\treturn TILESET_HOUSE;\\n}\\n\\nvoid HousePalettePanel::SelectTown(size_t index) {\\n\tASSERT(town_choice->GetCount() >= index);\\n"
- file_path: wxwidgets/palette_house.h
  description: Header for `HousePalettePanel` and `EditHouseDialog`.
  md5_hash: e357090cbc8ad19806d8439f682b5d78
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#ifndef RME_PALETTE_HOUSE_H_\\n#define\
    \ RME_PALETTE_HOUSE_H_\\n\\n#include \"palette_common.h\"\\n\\nclass House;\\n\\nclass HousePalettePanel : public PalettePanel {\\npublic:\\n\tHousePalettePanel(wxWindow* parent, wxWindowID id = wxID_ANY);\\n\t~HousePalettePanel();\\n\\n\tPaletteType GetType() const;\\n\\n\t// Select the first brush\\n\tvoid SelectFirstBrush();\\n\t// Returns the currently selected brush (first brush if panel is not loaded)\\n\tBrush* GetSelectedBrush() const;\\n\t// Returns the currently selected brush size\\n\tint GetSelectedBrushSize() const;\\n\t// Select the brush in the parameter, this only changes the look of the panel\\n\tbool SelectBrush(const Brush* whatbrush);\\n\\n\t// Called sometimes?\\n\tvoid OnUpdate();\\n\t// Called when this page is about to be displayed\\n\tvoid OnSwitchIn();\\n\\n\tvoid OnLayoutFixTimer(wxTimerEvent& event);\\n\\n\tvoid SetMap(Map* map);\\n\\nprotected:\\n\t// Internal use\\n\tvoid SaveHouse();\\n\tvoid SelectTown(size_t index);\\n\tvoid SelectHouse(size_t index);\\\
    n\\n\tHouse* GetCurrentlySelectedHouse() const;\\n\\n\tvoid SelectHouseBrush();\\n\tvoid SelectExitBrush();\\n\tvoid RefreshHouseList();\\n\\npublic:\\n\t// wxWidgets event handling\\n\tvoid OnTownChange(wxCommandEvent& event);\\n\tvoid OnListBoxChange(wxCommandEvent& event);\\n\tvoid OnListBoxDoubleClick(wxCommandEvent& event);\\n\tvoid OnClickHouseBrushButton(wxCommandEvent& event);\\n\tvoid OnClickSelectExitButton(wxCommandEvent& event);\\n\tvoid OnClickAddHouse(wxCommandEvent& event);\\n\tvoid OnClickEditHouse(wxCommandEvent& event);\\n\tvoid OnClickRemoveHouse(wxCommandEvent& event);\\n\tvoid OnListBoxContextMenu(wxContextMenuEvent& event);\\n\tvoid OnMoveHouseToTown(wxCommandEvent& event);\\n\\n#ifdef __APPLE__\\n\t// Used for detecting a deselect\\n\tvoid OnListBoxClick(wxMouseEvent& event);\\n#endif\\n\\nprotected:\\n\tMap* map;\\n\twxChoice* town_choice;\\n\tSortableListBox* house_list;\\n\twxToggleButton* house_brush_button;\\n\twxToggleButton* select_position_button;\\n\t\
    wxButton* add_house_button;\\n\twxButton* edit_house_button;\\n\twxButton* remove_house_button;\\n\twxMenu* context_menu;\\n\\n\t// Used for ugly hack\\n\tbool do_resize_on_display;\\n\twxTimer fix_size_timer;\\n\\n\tDECLARE_EVENT_TABLE()\\n};\\n\\nclass EditHouseDialog : public wxDialog {\\npublic:\\n\tEditHouseDialog(wxWindow* parent, Map* map, House* house);\\n\tvirtual ~EditHouseDialog();\\n\\n\tvoid OnFocusChange(wxFocusEvent&);\\n\\n\tvoid OnClickOK(wxCommandEvent&);\\n\tvoid OnClickCancel(wxCommandEvent&);\\n\\nprotected:\\n\tMap* map;\\n\tHouse* what_house;\\n\\n\twxString house_name, house_id, house_rent;\\n\\n\twxTextCtrl* name_field;\\n\twxChoice* town_id_field;\\n\twxSpinCtrl* id_field;\\n\twxTextCtrl* rent_field;\\n\twxCheckBox* guildhall_field;\\n\\n\tDECLARE_EVENT_TABLE();\\n};\\n\\n#endif"
- file_path: wxwidgets/palette_waypoints.cpp
  description: Implements `WaypointPalettePanel` using wxListCtrl for displaying and editing waypoint names, with Add/Remove buttons.
  md5_hash: e90f5c9b31ee6a819e8a50131bcec282
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n// ============================================================================\\\
    n// Waypoint palette\\n\\n#include \"main.h\"\\n\\n#include \"gui.h\"\\n#include \"palette_waypoints.h\"\\n#include \"waypoint_brush.h\"\\n#include \"map.h\"\\n\\nBEGIN_EVENT_TABLE(WaypointPalettePanel, PalettePanel)\\nEVT_BUTTON(PALETTE_WAYPOINT_ADD_WAYPOINT, WaypointPalettePanel::OnClickAddWaypoint)\\nEVT_BUTTON(PALETTE_WAYPOINT_REMOVE_WAYPOINT, WaypointPalettePanel::OnClickRemoveWaypoint)\\n\\nEVT_LIST_BEGIN_LABEL_EDIT(PALETTE_WAYPOINT_LISTBOX, WaypointPalettePanel::OnBeginEditWaypointLabel)\\nEVT_LIST_END_LABEL_EDIT(PALETTE_WAYPOINT_LISTBOX, WaypointPalettePanel::OnEditWaypointLabel)\\nEVT_LIST_ITEM_SELECTED(PALETTE_WAYPOINT_LISTBOX, WaypointPalettePanel::OnClickWaypoint)\\nEND_EVENT_TABLE()\\n\\nWaypointPalettePanel::WaypointPalettePanel(wxWindow* parent, wxWindowID id) :\\n\tPalettePanel(parent, id),\\n\tmap(nullptr) {\\n\twxSizer* sidesizer = newd wxStaticBoxSizer(wxVERTICAL, this, \"Waypoints\");\\n\\n\twaypoint_list = newd wxListCtrl(this, PALETTE_WAYPOINT_LISTBOX, wxDefaultPosition,\
    \ wxDefaultSize, wxLC_REPORT | wxLC_SINGLE_SEL | wxLC_EDIT_LABELS | wxLC_NO_HEADER);\\n\twaypoint_list->InsertColumn(0, \"UNNAMED\", wxLIST_FORMAT_LEFT, 200);\\n\tsidesizer->Add(waypoint_list, 1, wxEXPAND);\\n\\n\twxSizer* tmpsizer = newd wxBoxSizer(wxHORIZONTAL);\\n\ttmpsizer->Add(add_waypoint_button = newd wxButton(this, PALETTE_WAYPOINT_ADD_WAYPOINT, \"Add\", wxDefaultPosition, wxSize(50, -1)), 1, wxEXPAND);\\n\ttmpsizer->Add(remove_waypoint_button = newd wxButton(this, PALETTE_WAYPOINT_REMOVE_WAYPOINT, \"Remove\", wxDefaultPosition, wxSize(70, -1)), 1, wxEXPAND);\\n\tsidesizer->Add(tmpsizer, 0, wxEXPAND);\\n\\n\tSetSizerAndFit(sidesizer);\\n}\\n\\nWaypointPalettePanel::~WaypointPalettePanel() {\\n\t////\\n}\\n\\nvoid WaypointPalettePanel::OnSwitchIn() {\\n\tPalettePanel::OnSwitchIn();\\n}\\n\\nvoid WaypointPalettePanel::OnSwitchOut() {\\n\tPalettePanel::OnSwitchOut();\\n}\\n\\nvoid WaypointPalettePanel::SetMap(Map* m) {\\n\tmap = m;\\n\tthis->Enable(m);\\n}\\n\\nvoid WaypointPalettePanel::SelectFirstBrush()\
    \ {\\n\t// SelectWaypointBrush();\\n}\\n\\nBrush* WaypointPalettePanel::GetSelectedBrush() const {\\n\tlong item = waypoint_list->GetNextItem(-1, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);\\n\tg_gui.waypoint_brush->setWaypoint(\\n\t\titem == -1 ? nullptr : map->waypoints.getWaypoint(nstr(waypoint_list->GetItemText(item)))\\n\t);\\n\treturn g_gui.waypoint_brush;\\n}\\n\\nbool WaypointPalettePanel::SelectBrush(const Brush* whatbrush) {\\n\tASSERT(whatbrush == g_gui.waypoint_brush);\\n\treturn false;\\n}\\n\\nint WaypointPalettePanel::GetSelectedBrushSize() const {\\n\treturn 0;\\n}\\n\\nPaletteType WaypointPalettePanel::GetType() const {\\n\treturn TILESET_WAYPOINT;\\n}\\n\\nwxString WaypointPalettePanel::GetName() const {\\n\treturn \"Waypoint Palette\";\\n}\\n\\nvoid WaypointPalettePanel::OnUpdate() {\\n\tif (wxTextCtrl* tc = waypoint_list->GetEditControl()) {\\n\t\tWaypoint* wp = map->waypoints.getWaypoint(nstr(tc->GetValue()));\\n\t\tif (wp && wp->pos == Position()) {\\n\t\t\tif (map->getTile(wp->pos))\
    \ {\\n\t\t\t\tmap->getTileL(wp->pos)->decreaseWaypointCount();\\n\t\t\t}\\n\t\t\tmap->waypoints.removeWaypoint(wp->name);\\n\t\t}\\n\t}\\n\twaypoint_list->DeleteAllItems();\\n\\n\tif (!map) {\\n\t\twaypoint_list->Enable(false);\\n\t\tadd_waypoint_button->Enable(false);\\n\t\tremove_waypoint_button->Enable(false);\\n\t} else {\\n\t\twaypoint_list->Enable(true);\\n\t\tadd_waypoint_button->Enable(true);\\n\t\tremove_waypoint_button->Enable(true);\\n\\n\t\tWaypoints& waypoints = map->waypoints;\\n\\n\t\tfor (WaypointMap::const_iterator iter = waypoints.begin(); iter != waypoints.end(); ++iter) {\\n\t\t\twaypoint_list->InsertItem(0, wxstr(iter->second->name));\\n\t\t}\\n\t}\\n}\\n\\nvoid WaypointPalettePanel::OnClickWaypoint(wxListEvent& event) {\\n\tif (!map) {\\n\t\treturn;\\n\t}\\n\\n\tstd::string wpname = nstr(event.GetText());\\n\tWaypoint* wp = map->waypoints.getWaypoint(wpname);\\n\tif (wp) {\\n\t\tg_gui.SetScreenCenterPosition(wp->pos);\\n\t\tg_gui.waypoint_brush->setWaypoint(wp);\\\
    n\t}\\n}\\n\\nvoid WaypointPalettePanel::OnBeginEditWaypointLabel(wxListEvent& event) {\\n\t// We need to disable all hotkeys, so we can type properly\\n\tg_gui.DisableHotkeys();\\n}\\n\\nvoid WaypointPalettePanel::OnEditWaypointLabel(wxListEvent& event) {\\n\tstd::string wpname = nstr(event.GetLabel());\\n\tstd::string oldwpname = nstr(waypoint_list->GetItemText(event.GetIndex()));\\n\tWaypoint* wp = map->waypoints.getWaypoint(oldwpname);\\n\\n\tif (event.IsEditCancelled()) {\\n\t\treturn;\\n\t}\\n\\n\tif (wpname == \"\") {\\n\t\tmap->waypoints.removeWaypoint(oldwpname);\\n\t\tg_gui.RefreshPalettes();\\n\t} else if (wp) {\\n\t\tif (wpname == oldwpname) {\\n\t\t\t; // do nothing\\n\t\t} else {\\n\t\t\tif (map->waypoints.getWaypoint(wpname)) {\\n\t\t\t\t// Already exists a waypoint with this name!\\n\t\t\t\tg_gui.SetStatusText(\"There already is a waypoint with this name.\");\\n\t\t\t\tevent.Veto();\\n\t\t\t\tif (oldwpname == \"\") {\\n\t\t\t\t\tmap->waypoints.removeWaypoint(oldwpname);\\\
    n\t\t\t\t\tg_gui.RefreshPalettes();\\n\t\t\t\t}\\n\t\t\t} else {\\n\t\t\t\tWaypoint* nwp = newd Waypoint(*wp);\\n\t\t\t\tnwp->name = wpname;\\n\\n\t\t\t\tWaypoint* rwp = map->waypoints.getWaypoint(oldwpname);\\n\t\t\t\tif (rwp) {\\n\t\t\t\t\tif (map->getTile(rwp->pos)) {\\n\t\t\t\t\t\tmap->getTileL(rwp->pos)->decreaseWaypointCount();\\n\t\t\t\t\t}\\n\t\t\t\t\tmap->waypoints.removeWaypoint(rwp->name);\\n\t\t\t\t}\\n\\n\t\t\t\tmap->waypoints.addWaypoint(nwp);\\n\t\t\t\tg_gui.waypoint_brush->setWaypoint(nwp);\\n\\n\t\t\t\t// Refresh other palettes\\n\t\t\t\trefresh_timer.Start(300, true);\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tif (event.IsAllowed()) {\\n\t\tg_gui.EnableHotkeys();\\n\t}\\n}\\n\\nvoid WaypointPalettePanel::OnClickAddWaypoint(wxCommandEvent& event) {\\n\tif (map) {\\n\t\tmap->waypoints.addWaypoint(newd Waypoint());\\n\t\tlong i = waypoint_list->InsertItem(0, \"\");"
- file_path: wxwidgets/palette_waypoints.h
  description: Header for `WaypointPalettePanel`.
  md5_hash: c2b44aad38859bf826dd18175969feed
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#ifndef RME_PALETTE_WAYPOINTS_H_\\\
    n#define RME_PALETTE_WAYPOINTS_H_\\n\\n#include <wx/listctrl.h>\\n\\n#include \"waypoints.h\"\\n#include \"palette_common.h\"\\n\\nclass WaypointPalettePanel : public PalettePanel {\\npublic:\\n\tWaypointPalettePanel(wxWindow* parent, wxWindowID id = wxID_ANY);\\n\t~WaypointPalettePanel();\\n\\n\twxString GetName() const;\\n\tPaletteType GetType() const;\\n\\n\t// Select the first brush\\n\tvoid SelectFirstBrush();\\n\t// Returns the currently selected brush (first brush if panel is not loaded)\\n\tBrush* GetSelectedBrush() const;\\n\t// Returns the currently selected brush size\\n\tint GetSelectedBrushSize() const;\\n\t// Select the brush in the parameter, this only changes the look of the panel\\n\tbool SelectBrush(const Brush* whatbrush);\\n\\n\t// Called sometimes?\\n\tvoid OnUpdate();\\n\t// Called when this page is about to be displayed\\n\tvoid OnSwitchIn();\\n\t// Called when this page is hidden\\n\tvoid OnSwitchOut();\\n\\npublic:\\n\t// wxWidgets event handling\\n\tvoid OnClickWaypoint(wxListEvent&\
    \ event);\\n\tvoid OnBeginEditWaypointLabel(wxListEvent& event);\\n\tvoid OnEditWaypointLabel(wxListEvent& event);\\n\tvoid OnClickAddWaypoint(wxCommandEvent& event);\\n\tvoid OnClickRemoveWaypoint(wxCommandEvent& event);\\n\\n\tvoid SetMap(Map* map);\\n\\nprotected:\\n\tMap* map;\\n\twxListCtrl* waypoint_list;\\n\twxButton* add_waypoint_button;\\n\twxButton* remove_waypoint_button;\\n\\n\tDECLARE_EVENT_TABLE()\\n};\\n\\n#endif"
documentation_references:
- 'QComboBox: https://doc.qt.io/qt-6/qcombobox.html'
- 'QListWidget: https://doc.qt.io/qt-6/qlistwidget.html'
- 'QDialog: https://doc.qt.io/qt-6/qdialog.html'
- QRadioButton / QActionGroup for brush mode selection.
current_functionality_summary: |-
  The `HousePalettePanel` provides a UI to:
  - Select a town using a `wxChoice` control.
  - List houses within that town in a `SortableListBox`.
  - Add, Edit (via `EditHouseDialog`), and Remove houses.
  - Implement a context menu for moving houses to different towns.
  - Toggle between a "House Tile Brush" and a "Set House Exit" brush mode, configuring a global house brush with the selected house.
  The `EditHouseDialog` allows editing a house's name, town, rent, ID, and guildhall status.

  The `WaypointPalettePanel` provides a UI to:
  - List all waypoints in a `wxListCtrl` (names are editable).
  - Add new waypoints (name becomes editable).
  - Remove selected waypoints.
  - Selecting a waypoint sets a global waypoint brush.
definition_of_done:
- 'The ''House'' tab in the main palette system (`UI-02`) is fully implemented:'
- '  - A `QComboBox` lists towns from the current map (plus a ''(No Town)'' option). Selecting a town filters the `QListWidget` of houses.'
- '  - The `QListWidget` displays houses for the selected town, showing house name, ID, and size. It supports multi-selection for removal or moving.'
- '  - An ''Add House'' `QPushButton` opens the `EditHouseDialogQt` for defining a new house.'
- '  - An ''Edit House'' `QPushButton` opens the `EditHouseDialogQt` for the single selected house.'
- '  - A ''Remove House'' `QPushButton` removes all selected house(s) after confirmation.'
- '  - A context menu on the house list offers ''Move to Town...'', which opens a dialog to select a new town for the selected house(s).'
- '  - `QRadioButton`s or a `QActionGroup` allows switching between ''Draw House Tiles'' and ''Set House Exit'' brush modes, configuring the global house brush accordingly.'
- 'The `EditHouseDialogQt` (subclass of `QDialog`) is implemented:'
- '  - Allows editing/setting house name (`QLineEdit`), town (`QComboBox`), rent (`QSpinBox`), ID (`QSpinBox` with warnings for changes/duplicates), and guildhall status (`QCheckBox`).'
- '  - Loads data from a `House` object copy and applies validated changes back to the copy on ''OK''.'
- 'The ''Waypoint'' tab in the main palette system (`UI-02`) is fully implemented:'
- '  - A `QListWidget` displays all waypoints from the map. Waypoint names are editable in-place (`Qt::ItemIsEditable`).'
- '  - An ''Add Waypoint'' `QPushButton` creates a new waypoint with a default unique name in the map data and list, then initiates editing of the new item''s name.'
- '  - A ''Remove Waypoint'' `QPushButton` removes the selected waypoint(s) from the map data and list after confirmation.'
- Selecting a house (and brush mode) or a waypoint in their respective palettes correctly configures and activates the corresponding global brush (`HouseBrush`, `HouseExitBrush`, `WaypointBrush`) for use on the map canvas.
- All palette lists and controls are updated when the underlying map data (houses, towns, waypoints) changes.
boilerplate_coder_ai_prompt: |
  Your task is to implement the Qt6 UI components for managing Houses and Waypoints, specifically their palette tabs and the House editing dialog.

  **Reference Files:** `wxwidgets/palette_house.cpp`, `wxwidgets/palette_house.h`, `wxwidgets/palette_waypoints.cpp`, `wxwidgets/palette_waypoints.h`.

  **1. House Palette Tab (within main `paletteTabWidget` from `UI-02`):**
     - **Controls:**
       - `QComboBox* townCombo;`
       - `QListWidget* houseList;` (Set `SelectionMode` to `ExtendedSelection` for multi-delete/move)
       - `QPushButton* addHouseButton;`
       - `QPushButton* editHouseButton;`
       - `QPushButton* removeHouseButton;`
       - `QRadioButton* drawHouseTilesRadio;` (Text: "Draw House Tiles")
       - `QRadioButton* setHouseExitRadio;` (Text: "Set House Exit")
       - (Group the radio buttons)
     - **Functionality:**
       - Populate `townCombo` from `g_map.towns`. Add a "(No Town)" item.
       - When `townCombo` changes, filter `houseList` to show houses matching `selectedTownId`. Display "Name (ID: X, Size: Y sqm)". Store `House*` or ID with `QListWidgetItem::setData`.
       - `addHouseButton`: Create a new `House` object, open `EditHouseDialogQt` (pass it the new house object and map). If dialog accepted, add house to `g_map.houses`, refresh `houseList`.
       - `editHouseButton`: For selected house in `houseList`, create a copy, open `EditHouseDialogQt`. If accepted, apply changes to original house (create Undo action), refresh `houseList`. Disable if no selection or multiple selections.
       - `removeHouseButton`: Confirm and remove selected house(s) from `g_map.houses`. Refresh `houseList`. Create Undo action.
       - `houseList` Context Menu: Action "Move to Town...". Opens a `QInputDialog::getItem` to select a new town from `g_map.towns`. Update `townid` for all selected houses. Refresh `houseList`. Create Undo action.
       - Radio buttons/selection in `houseList` update the global house brush:
         - If `drawHouseTilesRadio` checked: `g_houseBrush->setHouse(selectedHouse); g_gui->setActiveBrush(g_houseBrush);`
         - If `setHouseExitRadio` checked: `g_houseExitBrush->setHouse(selectedHouse); g_gui->setActiveBrush(g_houseExitBrush);`

  **2. `EditHouseDialogQt` (inherits `QDialog`):**
     - Constructor: `EditHouseDialogQt(QWidget* parent, Map* map, House* houseToEditCopy)`.
     - Controls:
       - `QLineEdit* nameEdit;`
       - `QComboBox* townCombo;` (Populate with `map->towns`, set current based on `houseToEditCopy->townid`).
       - `QSpinBox* rentSpinBox;`
       - `QSpinBox* idSpinBox;` (Range 1-65535).
       - `QCheckBox* guildhallCheck;`
     - Load initial values from `houseToEditCopy`.
     - On "OK" (`accept()`): Validate data (name not empty, ID unique if changed, rent >= 0). Update `houseToEditCopy` fields.

  **3. Waypoint Palette Tab (within main `paletteTabWidget` from `UI-02`):**
     - **Controls:**
       - `QListWidget* waypointList;` (Set `Qt::ItemIsEditable` for in-place renaming).
       - `QPushButton* addWaypointButton;`
       - `QPushButton* removeWaypointButton;`
     - **Functionality:**
       - Populate `waypointList` from `g_map.waypoints`. Store `Waypoint*` or name with `QListWidgetItem::setData`.
       - `addWaypointButton`: Create new `Waypoint` (e.g., "New Waypoint 1") in `g_map.waypoints`. Add to `waypointList`. Call `waypointList->editItem()` on the new item.
       - `removeWaypointButton`: Confirm and remove selected waypoint(s) from `g_map.waypoints` and `waypointList`. Create Undo action.
       - `waypointList::itemChanged(QListWidgetItem* item)` signal:
         - Get old name (stored in item data before edit) and new name (item->text()).
         - Validate new name (not empty, unique among waypoints). If invalid, revert or show error.
         - Update the `Waypoint` object in `g_map.waypoints`. Create Undo action.
       - `waypointList::currentItemChanged`: Sets `g_waypointBrush->setWaypoint(selectedWaypoint); g_gui->setActiveBrush(g_waypointBrush);`.

  **General:**
  - Ensure all list/combo boxes are updated if the underlying map data (towns, houses, waypoints) changes due to other operations or file loading.
  - Connect signals from UI elements to appropriate slots to implement the described functionality.
