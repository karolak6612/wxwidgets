<?xml version="1.0" ?>
<TEST-06>
  <id>TEST-06</id>
  <section>Testing</section>
  <title>Develop Unit Tests for Network Protocol Message Handling</title>
  <original_task_id>TEST-06</original_task_id>
  <description>Develop unit tests for network protocol message creation, serialization, and deserialization. This covers various message types defined in 'mapcore::network' (from NET-01), including different data fields and error conditions during parsing.</description>
  <dependencies>
    <dependencie>NET-01</dependencie>
    <dependencie>TEST-01</dependencie>
    <dependencie>CORE-01</dependencie>
    <dependencie>BUILD-01</dependencie>
  </dependencies>
  <input_files/>
  <analyzed_input_files/>
  <documentation_references>
    <documentation_reference>Qt Test Framework: https://doc.qt.io/qt-6/qttest-index.html</documentation_reference>
    <documentation_reference>QByteArray: https://doc.qt.io/qt-6/qbytearray.html</documentation_reference>
    <documentation_reference>QDataStream: https://doc.qt.io/qt-6/qdatastream.html (Relevant if NetworkMessage uses it, though NET-01 implies a custom std::vector based approach)</documentation_reference>
    <documentation_reference>Google Protocol Buffers (protobuf) - For ideas on robust serialization, though not directly used: https://developers.google.com/protocol-buffers</documentation_reference>
  </documentation_references>
  <current_functionality_summary>This task is dedicated to creating new unit tests for the Qt6 network protocol implementation, specifically the message serialization and deserialization logic developed as part of 'NET-01' (Isolate and Port Network Protocol). The 'mapcore::network' module from 'NET-01' provides the 'NetworkMessage' class for buffer manipulation and the 'MapProtocolCodec' (or equivalent) for handling the serialization/deserialization of complex map data structures and various 'LivePacketType' messages. These tests will ensure that all defined network messages can be correctly encoded into a byte stream and decoded back into their structured object forms, maintaining data integrity across the network layer.
</current_functionality_summary>
  <definition_of_done>
    <element>Unit tests using the Qt Test framework are created for each distinct network message type handled by 'mapcore::network::NetworkMessage' and 'mapcore::network::MapProtocolCodec' (or equivalent serialization/deserialization utilities).</element>
    <element>Message Types to Test (based on 'LivePacketType' and 'LiveSocket' helpers from 'NET-01' analysis): Client Hello ('PACKET_HELLO_FROM_CLIENT'), Server Hello ('PACKET_HELLO_FROM_SERVER' - including map name, dimensions), Kick ('PACKET_KICK' - with reason string), Client Accepted ('PACKET_ACCEPTED_CLIENT'), Change Client Version ('PACKET_CHANGE_CLIENT_VERSION'), Server Talk ('PACKET_SERVER_TALK' - speaker, message), Client Talk ('PACKET_CLIENT_TALK' - message), Node Data ('PACKET_NODE' - including node coordinates, floor mask, and serialized floor/tile data using 'MapProtocolCodec'), Cursor Update ('PACKET_CLIENT_UPDATE_CURSOR', 'PACKET_CURSOR_UPDATE' - including cursor ID, color, position), Color Update ('PACKET_CLIENT_COLOR_UPDATE', 'PACKET_COLOR_UPDATE' - client ID, color), Request Nodes ('PACKET_REQUEST_NODES' - list of node coordinates/IDs), Change List ('PACKET_CHANGE_LIST' - serialized tile changes using 'MapProtocolCodec'), Start/Update Operation ('PACKET_START_OPERATION', 'PACKET_UPDATE_OPERATION'), and any other specific messages like those for house edits if their payload structure is defined by 'MapProtocolCodec'.</element>
    <element>Round-Trip Serialization/Deserialization Tests for Each Message Type: A message object/data structure is instantiated and populated with representative test data for all its fields. The message is serialized into a 'mapcore::NetworkMessage' buffer using the appropriate 'MapProtocolCodec' methods or 'NetworkMessage::write&lt;T&gt;' calls. The 'mapcore::NetworkMessage' buffer content is then deserialized back into a new message object/data structure of the expected type using 'MapProtocolCodec' or 'NetworkMessage::read&lt;T&gt;'. A field-by-field comparison is performed between the original and deserialized message data to ensure all values are identical.</element>
    <element>
      <Tests_cover_messages_containing_various_data_types>primitive types (integers of various sizes, booleans), 'std::string' (empty, typical, long), 'mapcore::Position', 'mapcore::NetworkColor', and lists/vectors of these where applicable (e.g., list of node IDs in 'PACKET_REQUEST_NODES').</Tests_cover_messages_containing_various_data_types>
    </element>
    <element>For messages containing complex serialized data (like 'PACKET_NODE' or 'PACKET_CHANGE_LIST'), tests verify the integrity of the nested serialized map structures by deserializing them and comparing key attributes.</element>
    <element>Error Handling in Deserialization Tests: Attempting to deserialize from an incomplete/truncated 'NetworkMessage' buffer (e.g., too few bytes for all declared fields). Attempting to deserialize a 'NetworkMessage' buffer containing corrupted data (e.g., string length longer than remaining buffer, invalid enum values if applicable). The deserialization logic should robustly handle these errors (e.g., throw an exception, return an error indicator) without crashing.</element>
    <element>All created unit tests pass successfully.</element>
    <element>Tests are integrated into the CMake build system for automated execution via 'ctest'.</element>
  </definition_of_done>
  <estimation_effort>
    <element>High (15-25 developer days). While 'NetworkMessage' itself is relatively simple, testing the serialization/deserialization of each packet type, especially those involving complex nested data structures (like 'PACKET_NODE' with its tile data, or 'PACKET_CHANGE_LIST'), requires careful setup of test data and comprehensive verification. Error handling tests also add significant effort.</element>
  </estimation_effort>
  <known_missing_files/>
  <boilerplate_coder_ai_prompt>Your task is to write unit tests for the network protocol message handling within the 'mapcore::network' module, specifically testing 'NetworkMessage' and the serialization/deserialization logic provided by 'MapProtocolCodec' (developed in 'NET-01'). Use the Qt Test framework. Tests should be located in 'tests/mapcore/network/'.
General Test Strategy: Round-Trip Testing for Each Message Type 1. Test Class Setup: Create a test class (e.g., 'TestNetworkProtocol') inheriting 'QObject'. 2. Instantiate &amp; Populate: For each 'LivePacketType': Create the data that would constitute the message (e.g., for 'PACKET_HELLO_FROM_CLIENT': RME version, net version, client version, name string, password string). 3. Serialize into 'NetworkMessage': 'mapcore::NetworkMessage outMsg;' 'outMsg.write&lt;uint8_t&gt;(PACKET_ID);' Use 'outMsg.write&lt;T&gt;()' for primitive fields. For complex data like tiles in 'PACKET_NODE' or 'PACKET_CHANGE_LIST', use the (mocked or real) 'MapProtocolCodec::serializeTile/Node' into the 'outMsg'. 4. Deserialize from 'NetworkMessage': 'mapcore::NetworkMessage inMsg; inMsg.buffer = outMsg.buffer; inMsg.size = outMsg.size; inMsg.position = 0;' 'LivePacketType type = static_cast&lt;LivePacketType&gt;(inMsg.read&lt;uint8_t&gt;()); QCOMPARE(type, PACKET_ID);' Use 'inMsg.read&lt;T&gt;()' for primitive fields. For complex data, use 'MapProtocolCodec::deserializeTile/Node' from 'inMsg'. 5. Verify: Compare all original populated data with the deserialized data using 'QCOMPARE' and 'QVERIFY'.
Key 'LivePacketType' Messages and Data to Test:
'PACKET_HELLO_FROM_CLIENT' / 'PACKET_HELLO_FROM_SERVER': Versions, map name (string), map dimensions (uint16_t). 'PACKET_KICK': Reason (string). 'PACKET_SERVER_TALK' / 'PACKET_CLIENT_TALK': Speaker (string, for server), message (string). Test empty and long strings. 'PACKET_CURSOR_UPDATE' (and 'PACKET_CLIENT_UPDATE_CURSOR'): 'LiveCursor' data: 'id' (uint32_t), 'NetworkColor' (r,g,b,a uint8_t), 'Position' (x,y,z). 'PACKET_COLOR_UPDATE' (and 'PACKET_CLIENT_COLOR_UPDATE'): 'clientId' (uint32_t), 'NetworkColor'. 'PACKET_REQUEST_NODES': 'count' (uint32_t), then 'count' * node identifiers (uint32_t). Test with 0, 1, and multiple nodes. 'PACKET_NODE': Node identifier (uint32_t: ndx, ndy, underground flag). Floor mask (uint16_t). For each floor in mask: Tile mask (uint16_t). Serialized tile data (string-like blob from 'MapProtocolCodec::serializeFloor/Tile'). This part needs careful setup with 'mapcore::Tile' objects having various items, flags, etc., then serializing them, and comparing key attributes after deserialization. 'PACKET_CHANGE_LIST': Serialized tile changes (string-like blob from 'MapProtocolCodec'). Similar to 'PACKET_NODE', requires setting up 'mapcore::Tile' objects, serializing, then deserializing and comparing critical attributes. 'PACKET_START_OPERATION' / 'PACKET_UPDATE_OPERATION': Operation message (string), percentage (uint32_t).
Error Handling Tests for 'NetworkMessage::read&lt;T&gt;()' and 'MapProtocolCodec' Deserialization: 'testReadPastEndOfBuffer()': Try to read more data than available. 'testReadStringTooLong()': String length prefix indicates more bytes than available in buffer. 'testCorruptedNodeData()': Feed malformed serialized tile/node data to 'MapProtocolCodec::deserializeNode/Tile' (this might be harder to unit test without specific error paths in the codec, but test with truncated data).
Test Structure Example ('TestNetworkMessages.cpp'): ```cpp #include &lt;QtTest&gt; #include &quot;mapcore/network/network_message.h&quot; #include &quot;mapcore/network/live_packets.h&quot; #include &quot;mapcore/network/map_protocol_codec.h&quot; // Assuming this exists #include &quot;mapcore/position.h&quot; // Include mapcore::Tile, mapcore::Map etc. if needed for MapProtocolCodec tests
class TestNetworkMessages : public QObject {
    Q_OBJECT
private slots:
    void: testHelloClientServer() {
        // Client -&gt; Server
        mapcore::NetworkMessage outMsgC;
        outMsgC.write&lt;uint8_t&gt;(PACKET_HELLO_FROM_CLIENT);
        outMsgC.write&lt;uint32_t&gt;(123); // rme version
        outMsgC.write&lt;uint32_t&gt;(1);   // net version
        outMsgC.write&lt;uint32_t&gt;(1280); // client version
        outMsgC.write&lt;std::string&gt;(&quot;TestUser&quot;);
        outMsgC.write&lt;std::string&gt;(&quot;TestPass&quot;);

        mapcore::NetworkMessage inMsgC;
        inMsgC.buffer = outMsgC.buffer; inMsgC.size = outMsgC.size; inMsgC.position = 0;
        QCOMPARE(static_cast&lt;LivePacketType&gt;(inMsgC.read&lt;uint8_t&gt;()), PACKET_HELLO_FROM_CLIENT);
        QCOMPARE(inMsgC.read&lt;uint32_t&gt;(), 123u);
        QCOMPARE(inMsgC.read&lt;uint32_t&gt;(), 1u);
        QCOMPARE(inMsgC.read&lt;uint32_t&gt;(), 1280u);
        QCOMPARE(inMsgC.read&lt;std::string&gt;(), &quot;TestUser&quot;);
        QCOMPARE(inMsgC.read&lt;std::string&gt;(), &quot;TestPass&quot;);
        QVERIFY(inMsgC.position == inMsgC.size); // Ensure all data was read
    }

    void: testCursorUpdate() {
        mapcore::NetworkMessage outMsg;
        outMsg.write&lt;uint8_t&gt;(PACKET_CURSOR_UPDATE);
        mapcore::NetworkColor color = {10, 20, 30, 255};
        mapcore::Position pos(100, 200, 7);
        // Assume MapProtocolCodec::writeLiveCursor exists
        mapcore::MapProtocolCodec::writeLiveCursor(outMsg, 5u, color, pos);

        mapcore::NetworkMessage inMsg;
        inMsg.buffer = outMsg.buffer; inMsg.size = outMsg.size; inMsg.position = 0;
        QCOMPARE(static_cast&lt;LivePacketType&gt;(inMsg.read&lt;uint8_t&gt;()), PACKET_CURSOR_UPDATE);
        uint32_t id; mapcore::NetworkColor c; mapcore::Position p;
        mapcore::MapProtocolCodec::readLiveCursor(inMsg, id, c, p);
        QCOMPARE(id, 5u);
        QCOMPARE(c.r, 10); QCOMPARE(c.g, 20); QCOMPARE(c.b, 30); QCOMPARE(c.a, 255);
        QCOMPARE(p, pos);
        QVERIFY(inMsg.position == inMsg.size);
    }

    // ... more tests for other packet types and error conditions ...
}; ``` Focus: on verifying that each defined packet type can be serialized and deserialized correctly, including all its fields and data types.
</boilerplate_coder_ai_prompt>
</TEST-06>
