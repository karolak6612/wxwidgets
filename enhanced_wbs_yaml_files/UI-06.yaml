wbs_item_id: UI-06
name: Port Creature Editor & Tools
description: Recreate UI for creature palette (selection, spawn settings, search, loading) and a dialog for editing properties of creatures placed on the map.
dependencies:
- 'UI-02 # Creature palette is a tab in the main palette system'
- 'CORE-02 # For CreatureDatabase and CreatureType information'
- '# XML files like creatures.xml, creature_palette.xml, tilesets.xml are data sources.'
input_files:
- wxwidgets/palette_creature.cpp
- wxwidgets/palette_creature.h
- wxwidgets/old_properties_window.cpp
- wxwidgets/old_properties_window.h
analyzed_input_files:
- file_path: wxwidgets/palette_creature.cpp
  description: Implements `CreaturePalettePanel`, which includes a wxChoice for creature tilesets, a SortableListBox or CreatureSpritePanel for display, search functionality, spawn time/size controls, creature/spawn brush toggles, and buttons for loading NPC/Monster XML folders.
  md5_hash: f6814cf0dd67c3af33c5d235fbfde7a7
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#include \"main.h\"\\n\\n#include \"\
    settings.h\"\\n#include \"brush.h\"\\n#include \"gui.h\"\\n#include \"palette_creature.h\"\\n#include \"creature_brush.h\"\\n#include \"spawn_brush.h\"\\n#include \"materials.h\"\\n#include <wx/dir.h>\\n#include <wx/filefn.h>\\n#include <wx/textdlg.h>\\n#include \"creature_sprite_manager.h\"\\n\\n// Define the new event ID for the Load NPCs button\\n#define PALETTE_LOAD_NPCS_BUTTON 1952\\n#define PALETTE_LOAD_MONSTERS_BUTTON 1953\\n#define PALETTE_PURGE_CREATURES_BUTTON 1954\\n#define PALETTE_SEARCH_BUTTON 1955\\n#define PALETTE_SEARCH_FIELD 1956\\n#define PALETTE_VIEW_TOGGLE_BUTTON 1957\\n#define PALETTE_CREATURE_LARGE_SPRITES_TOGGLE 1958\\n#define PALETTE_CREATURE_ZOOM_BUTTON 1959\\n\\n// ============================================================================\\n// Creature palette\\n\\nBEGIN_EVENT_TABLE(CreaturePalettePanel, PalettePanel)\\nEVT_CHOICE(PALETTE_CREATURE_TILESET_CHOICE, CreaturePalettePanel::OnTilesetChange)\\nEVT_LISTBOX(PALETTE_CREATURE_LISTBOX, CreaturePalettePanel::OnListBoxChange)\\\
    nEVT_COMMAND(wxID_ANY, wxEVT_COMMAND_LISTBOX_SELECTED, CreaturePalettePanel::OnSpriteSelected)\\nEVT_TOGGLEBUTTON(PALETTE_CREATURE_BRUSH_BUTTON, CreaturePalettePanel::OnClickCreatureBrushButton)\\nEVT_TOGGLEBUTTON(PALETTE_SPAWN_BRUSH_BUTTON, CreaturePalettePanel::OnClickSpawnBrushButton)\\nEVT_TOGGLEBUTTON(PALETTE_VIEW_TOGGLE_BUTTON, CreaturePalettePanel::OnClickViewToggle)\\nEVT_TOGGLEBUTTON(PALETTE_CREATURE_VIEW_STYLE_TOGGLE, CreaturePalettePanel::OnClickViewStyleToggle)\\nEVT_TOGGLEBUTTON(PALETTE_CREATURE_LARGE_SPRITES_TOGGLE, CreaturePalettePanel::OnClickLargeSpritesToggle)\\nEVT_BUTTON(PALETTE_CREATURE_ZOOM_BUTTON, CreaturePalettePanel::OnClickZoomButton)\\nEVT_BUTTON(PALETTE_LOAD_NPCS_BUTTON, CreaturePalettePanel::OnClickLoadNPCsButton)\\nEVT_BUTTON(PALETTE_LOAD_MONSTERS_BUTTON, CreaturePalettePanel::OnClickLoadMonstersButton)\\nEVT_BUTTON(PALETTE_PURGE_CREATURES_BUTTON, CreaturePalettePanel::OnClickPurgeCreaturesButton)\\nEVT_BUTTON(PALETTE_SEARCH_BUTTON, CreaturePalettePanel::OnClickSearchButton)\\\
    nEVT_TEXT(PALETTE_SEARCH_FIELD, CreaturePalettePanel::OnSearchFieldText)\\nEVT_SPINCTRL(PALETTE_CREATURE_SPAWN_TIME, CreaturePalettePanel::OnChangeSpawnTime)\\nEVT_SPINCTRL(PALETTE_CREATURE_SPAWN_SIZE, CreaturePalettePanel::OnChangeSpawnSize)\\nEND_EVENT_TABLE()\\n\\nCreaturePalettePanel::CreaturePalettePanel(wxWindow* parent, wxWindowID id) :\\n\tPalettePanel(parent, id),\\n\ttileset_choice(nullptr),\\n\tcreature_list(nullptr),\\n\tsprite_panel(nullptr),\\n\tseamless_panel(nullptr),\\n\tview_toggle(nullptr),\\n\tview_style_toggle(nullptr),\\n\tlarge_sprites_toggle(nullptr),\\n\tzoom_button(nullptr),\\n\tview_sizer(nullptr),\\n\tuse_sprite_view(false),\\n\tuse_seamless_view(true), // Seamless is now the default\\n\tuse_large_sprites(false),\\n\tzoom_factor(1),\\n\thandling_event(false),\\n\tsearch_field(nullptr),\\n\tsearch_button(nullptr),\\n\tload_npcs_button(nullptr),\\n\tload_monsters_button(nullptr),\\n\tpurge_creatures_button(nullptr),\\n\tcreature_spawntime_spin(nullptr),\\n\t\
    spawn_size_spin(nullptr),\\n\tcreature_brush_button(nullptr),\\n\tspawn_brush_button(nullptr) {\\n\t\\n\t// Create the controls\\n\twxSizer* topsizer = newd wxBoxSizer(wxVERTICAL);\\n\t\\n\twxSizer* sidesizer = newd wxStaticBoxSizer(wxVERTICAL, this, \"Creatures\");\\n\t\\n\t// Tileset choice\\n\ttileset_choice = newd wxChoice(this, PALETTE_CREATURE_TILESET_CHOICE, wxDefaultPosition, wxDefaultSize, 0, nullptr, wxCB_READONLY);\\n\tsidesizer->Add(tileset_choice, 0, wxEXPAND | wxALL, 5);\\n\t\\n\t// Search field\\n\twxBoxSizer* searchSizer = newd wxBoxSizer(wxHORIZONTAL);\\n\tsearchSizer->Add(newd wxStaticText(this, wxID_ANY, \"Search:\"), 0, wxCENTER | wxLEFT, 5);\\n\tsearch_field = newd wxTextCtrl(this, wxID_ANY, \"\", wxDefaultPosition, wxDefaultSize, wxTE_PROCESS_ENTER);\\n\tsearchSizer->Add(search_field, 1, wxCENTER | wxLEFT, 5);\\n\tsearch_button = newd wxButton(this, PALETTE_SEARCH_BUTTON, \"Go\", wxDefaultPosition, wxDefaultSize, wxBU_EXACTFIT);\\n\tsearchSizer->Add(search_button,\
    \ 0, wxLEFT, 5);\\n\tsidesizer->Add(searchSizer, 0, wxEXPAND | wxTOP, 5);\\n\t\\n\t// Connect the focus events to disable hotkeys during typing\\n\tsearch_field->Connect(wxEVT_SET_FOCUS, wxFocusEventHandler(CreaturePalettePanel::OnSearchFieldFocus), nullptr, this);\\n\tsearch_field->Connect(wxEVT_KILL_FOCUS, wxFocusEventHandler(CreaturePalettePanel::OnSearchFieldKillFocus), nullptr, this);\\n\t// Connect key down event to handle key presses in the search field\\n\tsearch_field->Connect(wxEVT_KEY_DOWN, wxKeyEventHandler(CreaturePalettePanel::OnSearchFieldKeyDown), nullptr, this);\\n\\n\t// Create view container that will hold both list and sprite views\\n\tview_sizer = newd wxBoxSizer(wxVERTICAL);\\n\t\\n\t// Create both views\\n\tcreature_list = newd SortableListBox(this, PALETTE_CREATURE_LISTBOX);\\n\tsprite_panel = newd CreatureSpritePanel(this);\\n\tseamless_panel = newd CreatureSeamlessGridPanel(this);\\n\t\\n\t// Add views to sizer (only one will be shown at a time)\\n\tview_sizer->Add(creature_list,\
    \ 1, wxEXPAND);\\n\tview_sizer->Add(sprite_panel, 1, wxEXPAND);\\n\tview_sizer->Add(seamless_panel, 1, wxEXPAND);\\n\tsprite_panel->Hide(); // Initially hide the sprite view\\n\tseamless_panel->Hide(); // Initially hide the seamless view\\n\t\\n\tsidesizer->Add(view_sizer, 1, wxEXPAND | wxTOP, 5);\\n\t\\n\t// Add buttons for loading NPCs, monsters, and purging creatures\\n\twxSizer* buttonSizer = newd wxBoxSizer(wxHORIZONTAL);\\n\t\\n\tload_npcs_button = newd wxButton(this, PALETTE_LOAD_NPCS_BUTTON, \"Load NPCs Folder\");\\n\tbuttonSizer->Add(load_npcs_button, 1, wxEXPAND | wxRIGHT, 5);\\n\t\\n\tload_monsters_button = newd wxButton(this, PALETTE_LOAD_MONSTERS_BUTTON, \"Load Monsters Folder\");\\n\tbuttonSizer->Add(load_monsters_button, 1, wxEXPAND | wxLEFT, 5);\\n\t\\n\tsidesizer->Add(buttonSizer, 0, wxEXPAND | wxTOP, 5);\\n\t\\n\tpurge_creatures_button = newd wxButton(this, PALETTE_PURGE_CREATURES_BUTTON, \"Purge Creatures\");\\n\tsidesizer->Add(purge_creatures_button, 0, wxEXPAND |\
    \ wxTOP, 5);\\n\t\\n\t// View mode toggle\\n\twxBoxSizer* viewModeSizer = newd wxBoxSizer(wxHORIZONTAL);\\n\tview_toggle = newd wxToggleButton(this, PALETTE_VIEW_TOGGLE_BUTTON, \"Sprite View\");\\n\tviewModeSizer->Add(view_toggle, 1, wxEXPAND);\\n\t\\n\t// Large sprites toggle\\n\tlarge_sprites_toggle = newd wxToggleButton(this, PALETTE_CREATURE_LARGE_SPRITES_TOGGLE, \"64x64\");\\n\tlarge_sprites_toggle->Enable(false); // Only enabled in sprite view\\n\tviewModeSizer->Add(large_sprites_toggle, 1, wxEXPAND | wxLEFT, 5);\\n\t\\n\t// Zoom button\\n\tzoom_button = newd wxButton(this, PALETTE_CREATURE_ZOOM_BUTTON, \"Zoom 2x\");\\n\tzoom_button->Enable(false); // Only enabled in sprite view with large sprites\\n\tviewModeSizer->Add(zoom_button, 1, wxEXPAND | wxLEFT, 5);\\n\t\\n\tsidesizer->Add(viewModeSizer, 0, wxEXPAND | wxTOP, 5);\\n\t\\n\t// Add brush radio buttons\\n\twxToggleButton* creature_radio = newd wxToggleButton(this, PALETTE_CREATURE_BRUSH_BUTTON, \"Creature\");\\n\twxToggleButton*\
    \ spawn_radio = newd wxToggleButton(this, PALETTE_SPAWN_BRUSH_BUTTON, \"Spawn\");\\n\t\\n\twxBoxSizer* radiosizer = newd wxBoxSizer(wxHORIZONTAL);\\n\tradiosizer->Add(creature_radio, 1, wxEXPAND);\\n\tradiosizer->Add(spawn_radio, 1, wxEXPAND);\\n\t\\n\tsidesizer->Add(radiosizer, 0, wxEXPAND | wxTOP, 5);\\n\t\\n\t// Store references to the radio buttons\\n\tcreature_brush_button = creature_radio;\\n\tspawn_brush_button = spawn_radio;\\n\t\\n\t// Add spawn settings\\n\twxFlexGridSizer* settings_sizer = newd wxFlexGridSizer(2, 5, 5);\\n\tsettings_sizer->AddGrowableCol(1);\\n\tsettings_sizer->Add(newd wxStaticText(this, wxID_ANY, \"Spawntime\"));\\n\t\\n\tcreature_spawntime_spin = newd wxSpinCtrl(this, PALETTE_CREATURE_SPAWN_TIME, i2ws(g_settings.getInteger(Config::DEFAULT_SPAWNTIME)), \\n\t\t\t\t\t\t\t\t\t\t\twxDefaultPosition, wxDefaultSize, wxSP_ARROW_KEYS, 0, 3600, g_settings.getInteger(Config::DEFAULT_SPAWNTIME));\\n\t\\n\tsettings_sizer->Add(creature_spawntime_spin, 0, wxEXPAND);\\\
    n\tsettings_sizer->Add(newd wxStaticText(this, wxID_ANY, \"Size\"));\\n\t\\n\tspawn_size_spin = newd wxSpinCtrl(this, PALETTE_CREATURE_SPAWN_SIZE, i2ws(5), \\n\t\t\t\t\t\t\t\t\t  wxDefaultPosition, wxDefaultSize, wxSP_ARROW_KEYS, 1, 10, 5);\\n\t\\n\tsettings_sizer->Add(spawn_size_spin, 0, wxEXPAND);\\n\t\\n\tsidesizer->Add(settings_sizer, 0, wxEXPAND | wxTOP, 5);\\n\ttopsizer->Add(sidesizer, 1, wxEXPAND | wxALL, 5);\\n\t\\n\tSetSizerAndFit(topsizer);\\n\t\\n\t// Load all creatures\\n\tTilesetContainer tilesets;\\n\t\\n\t// Create a list of all creature tilesets"
- file_path: wxwidgets/palette_creature.h
  description: Header for `CreaturePalettePanel` and its helper classes `CreatureSpritePanel` and `CreatureSeamlessGridPanel`.
  md5_hash: 04254faeff1d7d286e2b754d8b871920
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#ifndef RME_TILESET_CREATURE_H_\\n#define\
    \ RME_TILESET_CREATURE_H_\\n\\n#include \"palette_common.h\"\\n\\n// New class for seamless grid view of creature sprites with direct rendering\\nclass CreatureSeamlessGridPanel : public wxScrolledWindow {\\npublic:\\n\tCreatureSeamlessGridPanel(wxWindow* parent);\\n\tvirtual ~CreatureSeamlessGridPanel();\\n\\n\tvoid Clear();\\n\tvoid LoadCreatures(const BrushVector& brushlist);\\n\tBrush* GetSelectedBrush() const;\\n\tbool SelectBrush(const Brush* brush);\\n\tvoid EnsureVisible(const Brush* brush);\\n\tvoid SelectIndex(int index);\\n\t\\n\t// Getter for sprite size\\n\tint GetSpriteSize() const { return sprite_size; }\\n\t\\n\t// Drawing handlers\\n\tvoid OnPaint(wxPaintEvent& event);\\n\tvoid OnSize(wxSizeEvent& event);\\n\tvoid OnScroll(wxScrollWinEvent& event);\\n\tvoid OnMouseClick(wxMouseEvent& event);\\n\tvoid OnMouseMove(wxMouseEvent& event);\\n\tvoid OnTimer(wxTimerEvent& event);\\n\\n\t// Creature brushes in this panel\\n\tBrushVector creatures;\\n\\n\t// Friend class declaration\
    \ to allow access to protected members\\n\tfriend class CreaturePalettePanel;\\n\\nprotected:\\n\tvoid RecalculateGrid();\\n\tint GetSpriteIndexAt(int x, int y) const;\\n\tint GetCreatureNaturalSize(CreatureType* ctype) const;\\n\tvoid DrawCreature(wxDC& dc, int x, int y, CreatureType* ctype, bool selected = false);\\n\tvoid DrawItemsToPanel(wxDC& dc);\\n\tvoid UpdateViewableItems();\\n\tvoid StartProgressiveLoading();\\n\\n\tint columns;\\n\tint sprite_size;\\n\tint selected_index;\\n\tint hover_index;\\n\twxBitmap* buffer;\\n\tstd::map<size_t, int> sprite_dimensions; // Maps creature index to natural size\\n\t\\n\t// Viewport and loading management\\n\tint first_visible_row;\\n\tint last_visible_row;\\n\tint visible_rows_margin;\\n\tint total_rows;\\n\tbool need_full_redraw;\\n\t\\n\t// Progressive loading properties\\n\tbool use_progressive_loading;\\n\tbool is_large_tileset;\\n\tint loading_step;\\n\tint max_loading_steps;\\n\twxTimer* loading_timer;\\n\tstatic const int LARGE_TILESET_THRESHOLD\
    \ = 200;\\n\\n\tDECLARE_EVENT_TABLE();\\n};\\n\\n// Original class for grid view of creature sprites with padding\\nclass CreatureSpritePanel : public wxScrolledWindow {\\npublic:\\n\tCreatureSpritePanel(wxWindow* parent);\\n\tvirtual ~CreatureSpritePanel();\\n\\n\tvoid Clear();\\n\tvoid LoadCreatures(const BrushVector& brushlist);\\n\tBrush* GetSelectedBrush() const;\\n\tbool SelectBrush(const Brush* brush);\\n\tvoid EnsureVisible(const Brush* brush);\\n\tvoid SelectIndex(int index);\\n\t\\n\t// Getter for sprite size\\n\tint GetSpriteSize() const;\\n\t\\n\t// Drawing handlers\\n\tvoid OnPaint(wxPaintEvent& event);\\n\tvoid OnSize(wxSizeEvent& event);\\n\tvoid OnScroll(wxScrollWinEvent& event);\\n\tvoid OnMouseClick(wxMouseEvent& event);\\n\tvoid OnMouseMove(wxMouseEvent& event);\\n\\n\t// Creature brushes in this panel\\n\tBrushVector creatures;\\n\\n\t// Friend class declaration to allow access to protected members\\n\tfriend class CreaturePalettePanel;\\n\\nprotected:\\n\tvoid RecalculateGrid();\\\
    n\tint GetSpriteIndexAt(int x, int y) const;\\n\tvoid DrawSprite(wxDC& dc, int x, int y, CreatureType* ctype, bool selected = false);\\n\\n\tint columns;\\n\tint sprite_size;\\n\tint padding;\\n\tint selected_index;\\n\tint hover_index;\\n\twxBitmap* buffer;\\n\\n\tDECLARE_EVENT_TABLE();\\n};\\n\\nclass CreaturePalettePanel : public PalettePanel {\\npublic:\\n\tCreaturePalettePanel(wxWindow* parent, wxWindowID id = wxID_ANY);\\n\tvirtual ~CreaturePalettePanel();\\n\\n\tPaletteType GetType() const;\\n\\n\t// Select the first brush\\n\tvoid SelectFirstBrush();\\n\t// Returns the currently selected brush (first brush if panel is not loaded)\\n\tBrush* GetSelectedBrush() const;\\n\t// Returns the currently selected brush size\\n\tint GetSelectedBrushSize() const;\\n\t// Select the brush in the parameter, this only changes the look of the panel\\n\tbool SelectBrush(const Brush* whatbrush);\\n\\n\t// Updates the palette window to use the current brush size\\n\tvoid OnUpdateBrushSize(BrushShape\
    \ shape, int size);\\n\t// Called when this page is displayed\\n\tvoid OnSwitchIn();\\n\t// Called sometimes?\\n\tvoid OnUpdate();\\n\\nprotected:\\n\tvoid SelectTileset(size_t index);\\n\tvoid SelectCreature(size_t index);\\n\tvoid SelectCreature(std::string name);\\n\t// Switch between list view and sprite view modes\\n\tvoid SetViewMode(bool use_sprites);\\n\t// Set view style (regular grid vs seamless grid)\\n\tvoid SetViewStyle(bool use_seamless);\\n\t// Set large sprite mode (64x64 vs 32x32)\\n\tvoid SetLargeSpriteMode(bool use_large);\\n\t// Set zoom level for sprites\\n\tvoid SetZoomLevel(int zoom_factor);\\n\\npublic:\\n\t// Event handling\\n\tvoid OnChangeSpawnTime(wxSpinEvent& event);\\n\tvoid OnChangeSpawnSize(wxSpinEvent& event);\\n\\n\tvoid OnTilesetChange(wxCommandEvent& event);\\n\tvoid OnListBoxChange(wxCommandEvent& event);\\n\tvoid OnClickCreatureBrushButton(wxCommandEvent& event);\\n\tvoid OnClickSpawnBrushButton(wxCommandEvent& event);\\n\tvoid OnClickLoadNPCsButton(wxCommandEvent&\
    \ event);\\n\tvoid OnClickLoadMonstersButton(wxCommandEvent& event);\\n\tvoid OnClickPurgeCreaturesButton(wxCommandEvent& event);\\n\tvoid OnClickSearchButton(wxCommandEvent& event);\\n\tvoid OnSearchFieldText(wxCommandEvent& event);\\n\tvoid OnSearchFieldFocus(wxFocusEvent& event);\\n\tvoid OnSearchFieldKillFocus(wxFocusEvent& event);\\n\tvoid OnSearchFieldKeyDown(wxKeyEvent& event);\\n\tvoid OnClickViewToggle(wxCommandEvent& event);\\n\tvoid OnClickViewStyleToggle(wxCommandEvent& event);\\n\tvoid OnClickLargeSpritesToggle(wxCommandEvent& event);\\n\tvoid OnClickZoomButton(wxCommandEvent& event);\\n\tvoid OnSpriteSelected(wxCommandEvent& event);\\n\\nprotected:\\n\tvoid SelectCreatureBrush();\\n\tvoid SelectSpawnBrush();\\n\tbool LoadNPCsFromFolder(const wxString& folder);\\n\tbool LoadMonstersFromFolder(const wxString& folder);\\n\tbool PurgeCreaturePalettes();\\n\tvoid FilterCreatures(const wxString& search_text);\\n\\n\twxChoice* tileset_choice;\\n\tSortableListBox* creature_list;\\\
    n\tCreatureSpritePanel* sprite_panel;"
- file_path: wxwidgets/old_properties_window.cpp
  description: (Partially relevant) Contains a constructor variant for `OldPropertiesWindow(Creature* creature)` allowing editing of creature's spawn interval and direction. Does not provide full outfit editing for map creatures directly.
  md5_hash: 3e2f22edd5786afe2eacfc71472e5b63
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#include \"main.h\"\\n\\n#include <wx/grid.h>\\\
    n\\n#include \"tile.h\"\\n#include \"item.h\"\\n#include \"complexitem.h\"\\n#include \"town.h\"\\n#include \"house.h\"\\n#include \"map.h\"\\n#include \"editor.h\"\\n#include \"creature.h\"\\n\\n#include \"gui.h\"\\n#include \"application.h\"\\n#include \"old_properties_window.h\"\\n#include \"container_properties_window.h\"\\n\\n// ============================================================================\\n// Old Properties Window\\n\\n\\n/*\\nCurrent Task - Old Properties Window Improvements:\\n\\n1. Main Goal:\\n- Make the properties window non-blocking like replace_items_window.cpp\\n- Allow brush selection while properties window is open\\n- Fix crashes related to container and item handling (when we achieve it as a non main window)\\n\\n2. Issues Being Addressed:\\n- Access violation when checking canHoldText() on null items\\n- Container handling crashes\\n- Creature direction field not updating properly\\n- Modal dialog blocking brush selection\\n\\n3. Required Changes:\\\
    n- Add proper null checks for item/creature/spawn pointers\\n- Improve container handling safety\\n- Fix creature direction field updates\\n- Make window non-modal while maintaining functionality all the bugs above are when we try to implement a non modal window\\n- Ensure proper cleanup of resources\\n\\n4. Implementation Strategy:\\n- Add comprehensive null checks before accessing properties\\n- Improve error handling for container operations\\n- Fix creature direction field saving mechanism\\n- Modify window behavior to allow background interaction\\n- Maintain data integrity during property updates\\n\\n5. Note:\\nNEVER REMOVE ANY PREVIOUS FUNCTIONALITY UNLESS SPECIFICALLY REQUESTED!\\nKeep all existing features while adding improvements.\\n*/\\n\\nBEGIN_EVENT_TABLE(OldPropertiesWindow, wxDialog)\\nEVT_SET_FOCUS(OldPropertiesWindow::OnFocusChange)\\nEVT_BUTTON(wxID_OK, OldPropertiesWindow::OnClickOK)\\nEVT_BUTTON(wxID_CANCEL, OldPropertiesWindow::OnClickCancel)\\nEND_EVENT_TABLE()\\\
    n\\nstatic constexpr int OUTFIT_COLOR_MAX = 133;\\n\\nOldPropertiesWindow::OldPropertiesWindow(wxWindow* win_parent, const Map* map, const Tile* tile_parent, Item* item, wxPoint pos) :\\n\tObjectPropertiesWindowBase(win_parent, \"Item Properties\", map, tile_parent, item, pos),\\n\tcount_field(nullptr),\\n\tdirection_field(nullptr),\\n\taction_id_field(nullptr),\\n\tunique_id_field(nullptr),\\n\tdoor_id_field(nullptr),\\n\ttier_field(nullptr),\\n\tdepot_id_field(nullptr),\\n\tsplash_type_field(nullptr),\\n\ttext_field(nullptr),\\n\tdescription_field(nullptr) {\\n\tASSERT(edit_item);\\n\\n\twxSizer* topsizer = newd wxBoxSizer(wxVERTICAL);\\n\tif (Container* container = dynamic_cast<Container*>(edit_item)) {\\n\t\t// Container\\n\t\twxSizer* boxsizer = newd wxStaticBoxSizer(wxVERTICAL, this, \"Container Properties\");\\n\\n\t\twxFlexGridSizer* subsizer = newd wxFlexGridSizer(2, 10, 10);\\n\t\tsubsizer->AddGrowableCol(1);\\n\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"ID \"\
    \ + i2ws(item->getID())));\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"\"\" + wxstr(item->getName()) + \"\"\"));\\n\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"Action ID\"));\\n\t\taction_id_field = newd wxSpinCtrl(this, wxID_ANY, i2ws(edit_item->getActionID()), wxDefaultPosition, wxDefaultSize, wxSP_ARROW_KEYS, 0, 0xFFFF, edit_item->getActionID());\\n\t\tsubsizer->Add(action_id_field, wxSizerFlags(1).Expand());\\n\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"Unique ID\"));\\n\t\tunique_id_field = newd wxSpinCtrl(this, wxID_ANY, i2ws(edit_item->getUniqueID()), wxDefaultPosition, wxSize(-1, 20), wxSP_ARROW_KEYS, 0, 0xFFFF, edit_item->getUniqueID());\\n\t\tsubsizer->Add(unique_id_field, wxSizerFlags(1).Expand());\\n\\n\t\tboxsizer->Add(subsizer, wxSizerFlags(0).Expand());\\n\\n\t\t// Now we add the subitems!\\n\t\twxSizer* contents_sizer = newd wxStaticBoxSizer(wxVERTICAL, this, \"Contents\");\\n\\n\t\tbool use_large_sprites = g_settings.getBoolean(Config::USE_LARGE_CONTAINER_ICONS);\\\
    n\t\twxSizer* horizontal_sizer = nullptr;\\n\t\tconst int additional_height_increment = (use_large_sprites ? 40 : 24);\\n\t\tint additional_height = 0;\\n\\n\t\tint32_t maxColumns;\\n\t\tif (use_large_sprites) {\\n\t\t\tmaxColumns = 6;\\n\t\t} else {\\n\t\t\tmaxColumns = 12;\\n\t\t}\\n\\n\t\tfor (uint32_t index = 0; index < container->getVolume(); ++index) {\\n\t\t\tif (!horizontal_sizer) {\\n\t\t\t\thorizontal_sizer = newd wxBoxSizer(wxHORIZONTAL);\\n\t\t\t}\\n\\n\t\t\tItem* item = container->getItem(index);\\n\t\t\tContainerItemButton* containerItemButton = newd ContainerItemButton(this, use_large_sprites, index, map, item);\\n\\n\t\t\tcontainer_items.push_back(containerItemButton);\\n\t\t\thorizontal_sizer->Add(containerItemButton);\\n\\n\t\t\tif (((index + 1) % maxColumns) == 0) {\\n\t\t\t\tcontents_sizer->Add(horizontal_sizer);\\n\t\t\t\thorizontal_sizer = nullptr;\\n\t\t\t\tadditional_height += additional_height_increment;\\n\t\t\t}\\n\t\t}\\n\\n\t\tif (horizontal_sizer != nullptr)\
    \ {\\n\t\t\tcontents_sizer->Add(horizontal_sizer);\\n\t\t\tadditional_height += additional_height_increment;\\n\t\t}\\n\\n\t\tboxsizer->Add(contents_sizer, wxSizerFlags(2).Expand());\\n\\n\t\ttopsizer->Add(boxsizer, wxSizerFlags(0).Expand().Border(wxALL, 20));\\n\\n\t\t// SetSize(260, 150 + additional_height);\\n\t} else if (edit_item->canHoldText() || edit_item->canHoldDescription()) {\\n\t\t// Book\\n\t\twxSizer* boxsizer = newd wxStaticBoxSizer(wxVERTICAL, this, \"Writeable Properties\");\\n\\n\t\twxFlexGridSizer* subsizer = newd wxFlexGridSizer(2, 10, 10);\\n\t\tsubsizer->AddGrowableCol(1);\\n\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"ID \" + i2ws(item->getID())));\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"\"\" + wxstr(item->getName()) + \"\"\"));\\n\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"Action ID\"));\\n\t\taction_id_field = newd wxSpinCtrl(this, wxID_ANY, i2ws(edit_item->getActionID()), wxDefaultPosition, wxDefaultSize, wxSP_ARROW_KEYS,\
    \ 0, 0xFFFF, edit_item->getActionID());\\n\t\taction_id_field->SetSelection(-1, -1);\\n\t\tsubsizer->Add(action_id_field, wxSizerFlags(1).Expand());\\n\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"Unique ID\"));\\n\t\tunique_id_field = newd wxSpinCtrl(this, wxID_ANY, i2ws(edit_item->getUniqueID()), wxDefaultPosition, wxSize(-1, 20), wxSP_ARROW_KEYS, 0, 0xFFFF, edit_item->getUniqueID());\\n\t\tsubsizer->Add(unique_id_field, wxSizerFlags(1).Expand());\\n\\n\t\tboxsizer->Add(subsizer, wxSizerFlags(1).Expand());\\n\\n\t\twxSizer* textsizer = newd wxBoxSizer(wxVERTICAL);\\n\t\ttextsizer->Add(newd wxStaticText(this, wxID_ANY, \"Text\"), wxSizerFlags(1).Center());\\n\t\ttext_field = newd wxTextCtrl(this, wxID_ANY, wxstr(item->getText()), wxDefaultPosition, wxDefaultSize, wxTE_MULTILINE);\\n\t\ttextsizer->Add(text_field, wxSizerFlags(7).Expand());\\n\\n\t\tboxsizer->Add(textsizer, wxSizerFlags(2).Expand());\\n\\n\t\ttopsizer->Add(boxsizer, wxSizerFlags(0).Expand().Border(wxALL, 20));\\\
    n\\n\t\t// SetSize(220, 310);\\n\t} else if (edit_item->isSplash() || edit_item->isFluidContainer()) {\\n\t\t// Splash\\n\t\twxSizer* boxsizer = newd wxStaticBoxSizer(wxVERTICAL, this, \"Splash Properties\");\\n\\n\t\twxFlexGridSizer* subsizer = newd wxFlexGridSizer(2, 10, 10);\\n\t\tsubsizer->AddGrowableCol(1);\\n\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"ID \" + i2ws(item->getID())));\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"\"\" + wxstr(item->getName()) + \"\"\"));\\n\\n\t\tsubsizer->Add(newd wxStaticText(this, wxID_ANY, \"Type\"));"
- file_path: wxwidgets/old_properties_window.h
  description: Header for `OldPropertiesWindow`.
  md5_hash: 17d7f50be73b0facdc2faddc051ae845
  content_lite: "//////////////////////////////////////////////////////////////////////\\n// This file is part of Remere's Map Editor\\n//////////////////////////////////////////////////////////////////////\\n// Remere's Map Editor is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// Remere's Map Editor is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\\n//////////////////////////////////////////////////////////////////////\\n\\n#ifndef RME_OLD_PROPERTIES_WINDOW_H_\\\
    n#define RME_OLD_PROPERTIES_WINDOW_H_\\n\\n#include \"main.h\"\\n\\n#include \"common_windows.h\"\\n\\nclass ContainerItemButton;\\nclass ContainerItemPopupMenu;\\nclass MapWindow;\\n\\nclass OldPropertiesWindow : public ObjectPropertiesWindowBase {\\npublic:\\n\tOldPropertiesWindow(wxWindow* parent, const Map* map, const Tile* tile, Item* item, wxPoint = wxDefaultPosition);\\n\tOldPropertiesWindow(wxWindow* parent, const Map* map, const Tile* tile, Creature* creature, wxPoint = wxDefaultPosition);\\n\tOldPropertiesWindow(wxWindow* parent, const Map* map, const Tile* tile, Spawn* spawn, wxPoint = wxDefaultPosition);\\n\tvirtual ~OldPropertiesWindow();\\n\\n\tvoid OnFocusChange(wxFocusEvent&);\\n\tvoid OnChar(wxKeyEvent& evt);\\n\tvoid OnKeyDown(wxKeyEvent& evt);\\n\tvoid OnTextEnter(wxCommandEvent& evt);\\n\\n\tvoid OnClickOK(wxCommandEvent&);\\n\tvoid OnClickCancel(wxCommandEvent&);\\n\tvoid OnClose(wxCloseEvent& evt);\\n\\n\tvoid Update();\\n\t\\n\t// Non-modal methods\\n\tstatic OldPropertiesWindow*\
    \ getInstance() { return instance; }\\n\tstatic void destroyInstance() { \\n\t\tif (instance) {\\n\t\t\tinstance->Destroy();\\n\t\t\tinstance = nullptr;\\n\t\t}\\n\t}\\n\tstatic bool isActive() { return instance != nullptr; }\\n\t\\n\tvoid CommitChanges();\\n\\nprotected:\\n\t// Singleton instance for non-modal use\\n\tstatic OldPropertiesWindow* instance;\\n\\n\t// item\\n\twxSpinCtrl* count_field;\\n\twxSpinCtrl* action_id_field;\\n\twxSpinCtrl* unique_id_field;\\n\twxSpinCtrl* door_id_field;\\n\twxSpinCtrl* tier_field;\\n\twxChoice* depot_id_field;\\n\twxChoice* splash_type_field;\\n\twxTextCtrl* text_field;\\n\twxTextCtrl* description_field;\\n\\n\t// teleport\\n\twxSpinCtrl* x_field;\\n\twxSpinCtrl* y_field;\\n\twxSpinCtrl* z_field;\\n\\n\t// podium\\n\twxCheckBox* show_outfit;\\n\twxCheckBox* show_mount;\\n\twxCheckBox* show_platform;\\n\twxSpinCtrl* look_type;\\n\twxSpinCtrl* look_head;\\n\twxSpinCtrl* look_body;\\n\twxSpinCtrl* look_legs;\\n\twxSpinCtrl* look_feet;\\n\twxSpinCtrl*\
    \ look_addon;\\n\twxSpinCtrl* look_mount;\\n\twxSpinCtrl* look_mounthead;\\n\twxSpinCtrl* look_mountbody;\\n\twxSpinCtrl* look_mountlegs;\\n\twxSpinCtrl* look_mountfeet;\\n\\n\t// podium and creature\\n\twxChoice* direction_field;\\n\\n\t// container\\n\tstd::vector<ContainerItemButton*> container_items;\\n\\n\tfriend class ContainerItemButton;\\n\tfriend class ContainerItemPopupMenu;\\n\\n\tDECLARE_EVENT_TABLE();\\n};\\n\\n#endif"
documentation_references:
- 'QComboBox: https://doc.qt.io/qt-6/qcombobox.html'
- 'QLineEdit: https://doc.qt.io/qt-6/qlineedit.html'
- 'QListView / QListWidget: https://doc.qt.io/qt-6/qlistwidget.html'
- 'QSpinBox: https://doc.qt.io/qt-6/qspinbox.html'
- 'QRadioButton / QActionGroup: https://doc.qt.io/qt-6/qradiobutton.html'
- 'QFileDialog::getExistingDirectory: https://doc.qt.io/qt-6/qfiledialog.html#getExistingDirectory'
current_functionality_summary: |-
  The creature tooling in wxWidgets is primarily centered around the `CreaturePalettePanel`. This panel allows:
  - Selection of creature types from different tilesets/categories (loaded from XML).
  - Searching for creatures by name.
  - Displaying creatures in a list or a sprite grid.
  - Toggling between a "Creature Brush" (for placing single instances) and a "Spawn Brush".
  - When "Spawn Brush" is active, controls for "Spawn Time" and "Spawn Radius" become relevant.
  - Buttons to load creatures from external NPC/Monster XML definition folders.
  - A button to purge all loaded creature definitions.
  Separately, the `OldPropertiesWindow` has a mode for editing an existing `Creature*` on the map, which allows changing its spawn interval (if part of a spawn) and its facing direction. Full outfit editing for individual map creatures is not a standard feature here (outfits are usually type-defined, except for podiums).
definition_of_done:
- The 'Creature' tab within the main palette system (`UI-02`) is implemented.
- 'This palette tab includes:'
- '  - A `QComboBox` for selecting creature categories/tilesets (e.g., ''All Creatures'', ''NPCs'', ''Monsters'').'
- '  - A `QLineEdit` for searching/filtering creatures by name or by ''lt:<looktype_id>''.'
- '  - A `QListView` (with custom delegate for icon+name) or a custom sprite grid widget to display the filtered list of creatures.'
- '  - `QSpinBox` controls for ''Spawn Time (seconds)'' and ''Spawn Radius''.'
- '  - `QRadioButton`s (or a `QActionGroup`) to toggle between ''Place Single Creature'' mode and ''Place Spawn Area'' mode.'
- '  - `QPushButton`s for ''Load NPCs Folder'', ''Load Monsters Folder'', and ''Purge All Creatures''. These interact with the core creature data management (`Creatures` class from `CORE-02`).'
- Selecting a creature in the palette updates the application's current brush to either a `CreatureBrush` or a `SpawnBrush` based on the mode toggle.
- When 'Place Spawn Area' mode is active and used on the map, the tile's spawn data is configured with the selected creature, and the current Spawn Time and Radius from the palette.
- A new `EditMapCreatureDialog` (subclass of `QDialog`) is created.
- '  - This dialog is used to edit properties of an existing creature instance on the map.'
- '  - It displays the creature''s name (read-only).'
- '  - It provides a `QSpinBox` to edit the ''Spawn Interval'' (if the creature''s tile is a spawn point for this creature).'
- '  - It provides a `QComboBox` to edit the creature''s ''Direction''.'
- '  - (Optional, if decided by core data structure design): If individual creatures on the map can have their outfits customized (beyond their type definition), controls for `lookType`, `head`, `body`, `legs`, `feet`, `addons` are included.'
- The `EditMapCreatureDialog` loads data from a copy of the `Creature` object and applies changes back to the copy upon 'OK', with the caller managing undo actions.
boilerplate_coder_ai_prompt: |
  Your task is to implement the UI components for creature management in Qt6. This includes the 'Creature' tab within the main application palette and a dialog for editing properties of creature instances already placed on the map.

  **Reference Files:** `wxwidgets/palette_creature.cpp`, `wxwidgets/palette_creature.h`, and relevant sections of `wxwidgets/old_properties_window.cpp` (for editing creature instances).

  **1. Creature Palette Tab (within `paletteTabWidget` from `UI-02`):**
     - **Layout:**
       - `QComboBox` (`creatureTilesetCombo`): For selecting creature categories (e.g., "All Creatures", "NPCs", "Forest Monsters"). Populate from `g_materials.tilesets` where category is `TILESET_CREATURE`.
       - `QLineEdit` (`creatureSearchEdit`): For filtering creatures by name or "lt:<looktype_id>".
       - Display Area: `QListView` (`creatureListView`) with a custom model/delegate to show creature sprites and names, or a custom `CreatureSpriteGridWidget`.
       - `QSpinBox` (`spawnTimeSpin`): Label "Spawn Time (s):", range e.g., 1-3600.
       - `QSpinBox` (`spawnRadiusSpin`): Label "Spawn Radius:", range e.g., 1-15.
       - `QRadioButton` (`placeSingleCreatureRadio`): Text "Place Single Creature" (checked by default).
       - `QRadioButton` (`placeSpawnAreaRadio`): Text "Place Spawn Area". Group these two.
       - `QPushButton` (`loadNpcsButton`): Text "Load NPCs Folder...".
       - `QPushButton` (`loadMonstersButton`): Text "Load Monsters Folder...".
       - `QPushButton` (`purgeCreaturesButton`): Text "Purge All Creatures".
       - (Optional: Toggles for "Sprite View" vs "List View", "64x64 Sprites", "Zoom" if implementing advanced sprite views from `CreaturePalettePanel`).
     - **Functionality:**
       - Populate `creatureTilesetCombo`. Selecting a tileset filters the `creatureListView`.
       - `creatureSearchEdit` text changes filter `creatureListView` (case-insensitive name search, or looktype search if "lt:" prefix).
       - Selecting a creature in `creatureListView` sets it as the active creature for the brush.
       - If `placeSingleCreatureRadio` is checked, the active brush becomes a `CreatureBrush` for the selected creature.
       - If `placeSpawnAreaRadio` is checked, the active brush becomes a `SpawnBrush`. When applied to a tile, it uses the selected creature, `spawnTimeSpin->value()`, and `spawnRadiusSpin->value()` to configure the tile's spawn data.
       - "Load NPCs/Monsters" buttons: Open `QFileDialog::getExistingDirectory`. Iterate XML files, call `g_creatures.importXMLFromOT()`. Refresh palette and current list.
       - "Purge All Creatures": Confirm with `QMessageBox`. Clear `g_creatures`, clear relevant `TilesetCategory` entries in `g_materials`, refresh palettes.

  **2. `EditMapCreatureDialog` (inherits `QDialog`):**
     - Constructor: `EditMapCreatureDialog(QWidget* parent, Map* map, Creature* creatureToEditCopy)`.
     - **Layout:**
       - `QLabel` for Creature Name (read-only, from `creatureToEditCopy->getName()`).
       - `QSpinBox` (`spawnIntervalEdit`): Label "Spawn Interval (s):". Load from `creatureToEditCopy->getSpawnTime()`.
       - `QComboBox` (`directionCombo`): Label "Direction:". Populate with "North", "East", "South", "West", etc. Set current from `creatureToEditCopy->getDirection()`.
       - **Outfit Section (Conditional - only if core `Creature` object on map stores its own outfit overrides):**
         - `QSpinBox` `lookTypeEdit`, `lookHeadEdit`, `lookBodyEdit`, `lookLegsEdit`, `lookFeetEdit`, `lookAddonsEdit`.
     - **Functionality:**
       - On "OK": Validate inputs. Update `creatureToEditCopy` with new spawn interval and direction (and outfit if applicable). `accept()` the dialog.

  **Data Interaction:**
  - Creature definitions are managed by `g_creatures` (see `CORE-02`).
  - Palettes display `CreatureBrush` objects, which reference `CreatureType` from `g_creatures`.
  - When placing a spawn, the `Tile` object on the map stores the creature name (or list of names), spawn radius, and spawn time.
  - The `EditMapCreatureDialog` modifies an existing `Creature` object (a copy for undo purposes).
